<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只会飞的旺旺</title>
  
  <subtitle>一只会飞的旺旺,Java,Python,羊毛,hexo,博客</subtitle>
  <link href="https://www.wangwangit.com/atom.xml" rel="self"/>
  
  <link href="https://www.wangwangit.com/"/>
  <updated>2025-09-01T06:44:09.763Z</updated>
  <id>https://www.wangwangit.com/</id>
  
  <author>
    <name>一只会飞的旺旺</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>别再忍受卡顿了！抛开向日葵和ToDesk，这个免费远程神器才是真香(二)</title>
    <link href="https://www.wangwangit.com/%E5%88%AB%E5%86%8D%E5%BF%8D%E5%8F%97%E5%8D%A1%E9%A1%BF%E4%BA%86%EF%BC%81%E6%8A%9B%E5%BC%80%E5%90%91%E6%97%A5%E8%91%B5%E5%92%8CToDesk%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%85%8D%E8%B4%B9%E8%BF%9C%E7%A8%8B%E7%A5%9E%E5%99%A8%E6%89%8D%E6%98%AF%E7%9C%9F%E9%A6%99(%E4%BA%8C)/"/>
    <id>https://www.wangwangit.com/%E5%88%AB%E5%86%8D%E5%BF%8D%E5%8F%97%E5%8D%A1%E9%A1%BF%E4%BA%86%EF%BC%81%E6%8A%9B%E5%BC%80%E5%90%91%E6%97%A5%E8%91%B5%E5%92%8CToDesk%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%85%8D%E8%B4%B9%E8%BF%9C%E7%A8%8B%E7%A5%9E%E5%99%A8%E6%89%8D%E6%98%AF%E7%9C%9F%E9%A6%99(%E4%BA%8C)/</id>
    <published>2025-08-27T22:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.763Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章里，我们聊了网易UU远程，它用完全免费的模式，提供了顶级的远程体验，可以说是目前“开箱即用”场景下的最优解。</p><p>不过，评论区也有朋友提出一个很深刻的问题：<strong>“这么好的东西完全免费，它到底图什么？能一直免费下去吗？”</strong></p><p><img src="https://img.996007.icu/file/1754383501413_image-20250805164455100.png" alt="image-20250805164455100"></p><p>这确实问到了点子上。怎么说呢，就是把所有的便利都建立在商业公司的“善意”上，心里总归有点不踏实。万一哪天它开始收费、或者加入广告、又或者它的隐私政策让你不再信任，我们又该何去何从？</p><p>这种不确定性，正是所有商业软件的通病。</p><p>所以今天，我要分享一个“一劳永逸”的解决方案。它能让你彻底摆脱对任何商业平台的依赖，将数据和连接的控制权100%掌握在自己手里。这条路，就是通往“数字主权”的自建之路，而我们要用的核心工具，就是大名鼎鼎的开源软件——<strong>RustDesk</strong>。</p><p>更关键的一点是，有细心的用户发现，RustDesk的官方公共服务器好像已经屏蔽了国内的直接访问。这意味着，对于咱们国内用户来说，<strong>自建服务几乎已经从一个“可选项”，变成了体验RustDesk的“必选项”</strong>。</p><blockquote><p>官网: <a href="https://rustdesk.com/zh-cn/">https://rustdesk.com/zh-cn/</a></p></blockquote><hr><table><thead><tr><th align="left">特性维度</th><th align="left"><strong>向日葵&#x2F;ToDesk (免费版)</strong></th><th align="left"><strong>网易UU远程</strong></th><th align="left"><strong>自建RustDesk</strong></th></tr></thead><tbody><tr><td align="left"><strong>理想用户</strong></td><td align="left">轻度、应急用户</td><td align="left">游戏玩家、学生、上班族</td><td align="left">技术爱好者、隐私至上者</td></tr><tr><td align="left"><strong>上手难度</strong></td><td align="left">⭐（极简）</td><td align="left">⭐（极简）</td><td align="left">⭐⭐⭐⭐（需要动手）</td></tr><tr><td align="left"><strong>性能体验</strong></td><td align="left">⭐⭐（高峰期卡顿）</td><td align="left">⭐⭐⭐⭐⭐（极致流畅）</td><td align="left">⭐⭐⭐⭐⭐（取决于自己）</td></tr><tr><td align="left"><strong>花费成本</strong></td><td align="left">免费（但体验受限）</td><td align="left"><strong>完全免费</strong></td><td align="left">少量服务器年费+时间成本</td></tr><tr><td align="left"><strong>核心优势</strong></td><td align="left">用户基数大</td><td align="left"><strong>免费提供顶级性能</strong></td><td align="left"><strong>数据主权，绝对隐私</strong></td></tr></tbody></table><p><img src="https://img.996007.icu/file/1754382947637_image-20250805163539252.png" alt="image-20250805163539252"></p><hr><h3 id="实践指南：别怕，搭建过程比想象中简单"><a href="#实践指南：别怕，搭建过程比想象中简单" class="headerlink" title="实践指南：别怕，搭建过程比想象中简单"></a><strong>实践指南：别怕，搭建过程比想象中简单</strong></h3><p>一听到“自建服务器”，很多朋友可能就望而却步了。但相信我，得益于Docker这样的现代化工具，整个过程已经被简化到了极致。下面这份教程，就是我为普通用户量身定制的。</p><p><strong>前提准备：你需要一台云服务器（VPS）</strong></p><p>这个是硬性条件，你得先有个“服务器”。别被名字吓到，它本质上就是一台位于云端的、24小时开机的迷你电脑。</p><ul><li><strong>去哪买？</strong> 国内的阿里云、腾讯云等都有“轻量应用服务器”产品，非常适合新手。</li><li><strong>买多贵？</strong> RustDesk对硬件的要求极低，买<strong>最便宜的入门款（通常是1核CPU&#x2F;2GB内存）就绰绰有余</strong>。得益于激烈的市场竞争，这类服务器针对新用户的价格非常亲民，一年下来大概也就一两百块钱。</li></ul><p><strong>开始搭建：真正的“三步走”</strong></p><p>在你买好服务器，并且能通过工具连接上它的命令行（那个黑底白字的界面）之后，跟着我敲代码就行。这块可能需要一些服务器使用的经验!</p><p><strong>步骤 1：安装 Docker</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash &lt;(wget -qO- https://get.docker.com)</span><br></pre></td></tr></table></figure><p><strong>步骤 2：下载 compose.yml</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget rustdesk.com/oss.yml -O compose.yml</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget rustdesk.com/pro.yml -O compose.yml</span><br></pre></td></tr></table></figure><p><strong>步骤 3：启动 Compose</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://img.996007.icu/file/1754383611911_image-20250805164643695.png" alt="image-20250805164643695"></p><p><strong>注意：配置客户端与防火墙</strong><br>现在，你需要在自己电脑和被控电脑上都装好RustDesk客户端。</p><p><strong>打开服务器的端口</strong>：登录你的云服务商后台，找到防火墙设置，确保TCP协议的<code>21114</code>到<code>21119</code>端口，以及UDP协议的<code>21116</code>端口是开放的。这是为了让你的电脑能顺利连接到服务器。</p><p><img src="https://img.996007.icu/file/1754383316482_image-20250805164144766.png" alt="image-20250805164144766"></p><p><strong>配置客户端</strong>：打开RustDesk客户端的设置，找到“ID&#x2F;中继服务器”选项。</p><ul><li>在“<strong>ID服务器</strong>”一栏，填入你云服务器的<strong>公网IP地址</strong>。</li><li>在“<strong>Key</strong>”一栏，填入一串公钥。这串密钥在你服务器的<code>compose.yml</code>文件中配置的数据目录里，可以在工作目录&#x2F;数据文件夹中的 <code>id_ed25519.pub</code> 文件中找到。</li></ul><p><img src="https://img.996007.icu/file/1754383772805_image-20250805164927987.png" alt="image-20250805164927987"></p><ul><li>其他选项留空，保存即可。</li></ul><p><img src="https://img.996007.icu/file/1754383118532_image-20250805163826311.png" alt="image-20250805163826311"></p><p><img src="https://img.996007.icu/file/1754383156706_image-20250805163902791.png" alt="image-20250805163902791"></p><p>至此，你的所有远程连接都将通过自己的专属服务器进行，大功告成！</p><hr><h3 id="自由的成本：这事儿到底值不值？"><a href="#自由的成本：这事儿到底值不值？" class="headerlink" title="自由的成本：这事儿到底值不值？"></a><strong>自由的成本：这事儿到底值不值？</strong></h3><p>自建服务虽然带来了无与伦比的控制权，但它并非完全没有成本。</p><ul><li><strong>金钱成本</strong>：主要是服务器的年费，<strong>大概每年100-200元人民币</strong>。说实话，这比订阅任何一款主流商业远程软件的年费都便宜得多。</li><li><strong>时间与学习成本</strong>：这才是真正的“隐性成本”。虽然过程已经简化，但它仍然要求你：<ul><li>不害怕黑乎乎的命令行界面。</li><li>愿意去理解IP地址、端口这些基础概念。</li><li>承担起维护服务器的责任（虽然RustDesk本身很稳定，基本不用管）。</li></ul></li></ul><p>总而言之，阻碍普通用户自建RustDesk的，从来不是钱，而是开始动手所需的动力和一点点学习意愿。</p><p><strong>我个人觉得，它更像是一种爱好或一项技能投资。对于那些乐于探索、珍视隐私、并希望将数字生活牢牢掌握在自己手中的朋友来说，自建RustDesk无疑是当前最理想、最酷的解决方案。</strong></p><p>希望这篇详细的指南能打消你的疑虑，给你带来动手的勇气。我们下期再见！</p>]]></content>
    
    
    <summary type="html">在上一篇文章里，我们聊了网易UU远程，它用完全免费的模式，提供了顶级的远程体验，可以说是目前“开箱即用”场景下的最优解。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="工具" scheme="https://www.wangwangit.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="远程" scheme="https://www.wangwangit.com/tags/%E8%BF%9C%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>保姆级攻略：2元搞定一年正版Office，非学生党也能冲！</title>
    <link href="https://www.wangwangit.com/%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%94%BB%E7%95%A5%EF%BC%9A2%E5%85%83%E6%90%9E%E5%AE%9A%E4%B8%80%E5%B9%B4%E6%AD%A3%E7%89%88Office%EF%BC%8C%E9%9D%9E%E5%AD%A6%E7%94%9F%E5%85%9A%E4%B9%9F%E8%83%BD%E5%86%B2%EF%BC%81/"/>
    <id>https://www.wangwangit.com/%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%94%BB%E7%95%A5%EF%BC%9A2%E5%85%83%E6%90%9E%E5%AE%9A%E4%B8%80%E5%B9%B4%E6%AD%A3%E7%89%88Office%EF%BC%8C%E9%9D%9E%E5%AD%A6%E7%94%9F%E5%85%9A%E4%B9%9F%E8%83%BD%E5%86%B2%EF%BC%81/</id>
    <published>2025-08-26T22:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.762Z</updated>
    
    <content type="html"><![CDATA[<p>最近在小红书上看到一个“2块钱用一年个人版Microsoft 365”的教程。本着爱折腾和分享的精神，我赶紧去研究了一下，今天就和大家聊聊这个方法到底是怎么回事。</p><h4 id="个人版订阅都有啥"><a href="#个人版订阅都有啥" class="headerlink" title="个人版订阅都有啥?"></a>个人版订阅都有啥?</h4><p>个人版包含的东西还是挺全的：</p><ul><li>全套的Office应用：Word, Excel, PowerPoint等等。</li><li>1TB的OneDrive云存储空间。</li><li>适用于PC、Mac和移动设备。</li></ul><p><img src="https://img.996007.icu/file/1755762387829_image-20250821154620434.png" alt="image-20250821154620434"></p><h4 id="如何操作"><a href="#如何操作" class="headerlink" title="如何操作?"></a>如何操作?</h4><p>具体的操作步骤大概是这样的：</p><ol><li><p><strong>访问学生优惠页面</strong>：打开微软中国的Microsoft 365学生定价页面</p><blockquote><p><a href="https://www.microsoft.com/zh-cn/microsoft-365/college-student-pricing">https://www.microsoft.com/zh-cn/microsoft-365/college-student-pricing</a></p></blockquote></li><li><p><strong>验证学生身份</strong>：这一步是关键。如果你是大学生，直接用学校提供的 <code>.edu</code> 后缀的邮箱进行验证就行，这是最正规的方式。(<strong>我的账号好像都没让我验证,可能以前绑定过</strong>)</p></li><li><p><strong>“特殊”验证方式</strong>：如果你没有教育邮箱，可以去找一个“临时教育邮箱”来完成验证。</p><blockquote><p>我的导航站里也有临时邮箱,可以自己去试试 <a href="https://nav.wangwangit.com/">https://nav.wangwangit.com</a></p></blockquote><p><img src="https://img.996007.icu/file/1755762592909_image-20250821154940640.png" alt="image-20250821154940640"></p></li><li><p><strong>订阅和支付</strong>：验证通过后，登录自己的微软账号，绑定支付宝，然后会看到一个订阅价格，比如18元&#x2F;月。先选择这个订阅。</p></li><li><p><strong>修改订阅</strong>：最关键的一步来了。在完成支付后，可以去订阅管理页面，把月度订阅改成年度订阅，这时候价格就会显示为每年2元。</p></li></ol><p><img src="https://img.996007.icu/file/1755762661269_image-20250821155049354.png" alt="image-20250821155049354"></p><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>说实话，这个方法我研究下来，感觉更像是一个有时效性的漏洞，而不是一个可以长期依赖的羊毛。</p><p><strong>1. 成功率不确定</strong><br>这个方法不适合所有人，而且很可能随时会“失效”。微软一旦修复了这个价格显示的Bug，或者加强了对临时邮箱的验证，这条路子就走不通了。你看到这篇文章的时候，可能已经无法复现了。</p><p><strong>2. 临时邮箱的风险</strong><br>用临时邮箱注册的账号，稳定性和安全性是个大问题。我个人不太推荐这种方式。首先，你无法长期持有这个邮箱，如果后续需要接收验证邮件，会非常麻烦。其次，微软会定期或不定期地重新验证用户的学生身份，一旦验证失败，账号的订阅资格就可能被取消。你存在OneDrive里的1TB文件，到时处理起来会相当棘手。</p><p><strong>3. “2元”价格能维持多久？</strong><br>即便你成功了，这个价格大概率也只是一次性的。明年续费的时候，基本不可能还是这个价。所以，它更适合那些有短期应急需求，比如就这一两个月需要用Office做个毕业设计之类的朋友。</p><h4 id="更稳妥的替代方案？"><a href="#更稳妥的替代方案？" class="headerlink" title="更稳妥的替代方案？"></a>更稳妥的替代方案？</h4><p>如果你需要长期、稳定地使用Office，我还是建议考虑下面两种更靠谱的方案：</p><ul><li><p><strong>方案一：和朋友合租“家庭版”</strong><br>这是我个人最推荐的方式。Microsoft 365家庭版最多支持6个用户，每个人都有独立的1TB云存储空间。找齐6个“车友”，在官方渠道或者靠谱的第三方渠道购买，平摊下来每个人一年也就几十块钱。安全、稳定，还省心。</p></li><li><p><strong>方案二：查询学校的免费福利</strong><br>很多国内外的大学本身就和微软有合作，会为在校学生提供免费的Office 365 A1账户。这个账户虽然云存储空间和功能上可能和个人版略有差异，但日常使用完全足够，而且是完全免费和正规的。你可以先去自己学校的IT部门网站或者信息化中心查一下，说不定有惊喜。</p></li></ul>]]></content>
    
    
    <summary type="html">最近在小红书上看到一个“2块钱用一年个人版Microsoft 365”的教程。本着爱折腾和分享的精神，我赶紧去研究了一下，今天就和大家聊聊这个方法到底是怎么回事。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Office" scheme="https://www.wangwangit.com/tags/Office/"/>
    
    <category term="工具" scheme="https://www.wangwangit.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>不用花一分钱！教你搭建专属文字转语音网站，支持20+种声音</title>
    <link href="https://www.wangwangit.com/%E4%B8%8D%E7%94%A8%E8%8A%B1%E4%B8%80%E5%88%86%E9%92%B1-%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BA%E4%B8%93%E5%B1%9E%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3%E7%BD%91%E7%AB%99-%E6%94%AF%E6%8C%8120%E5%A4%9A%E7%A7%8D%E5%A3%B0%E9%9F%B3/"/>
    <id>https://www.wangwangit.com/%E4%B8%8D%E7%94%A8%E8%8A%B1%E4%B8%80%E5%88%86%E9%92%B1-%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BA%E4%B8%93%E5%B1%9E%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3%E7%BD%91%E7%AB%99-%E6%94%AF%E6%8C%8120%E5%A4%9A%E7%A7%8D%E5%A3%B0%E9%9F%B3/</id>
    <published>2025-08-25T22:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Edge-TTS？"><a href="#什么是Edge-TTS？" class="headerlink" title="什么是Edge TTS？"></a>什么是Edge TTS？</h2><p>Edge TTS（Text-to-Speech）是微软Edge浏览器内置的语音合成技术，它具有以下惊人特点：</p><ul><li><strong>声音丰富</strong>：支持20+种高质量中文声音，包括晓晓、云希、晓伊等</li><li><strong>完全免费</strong>：无需API密钥，无使用限制</li><li><strong>响应迅速</strong>：毫秒级生成，体验流畅</li><li><strong>参数丰富</strong>：支持语速、音调、音量、语音风格调节</li><li><strong>跨平台</strong>：支持所有现代浏览器和移动设备</li></ul><blockquote><p>直接使用: <a href="https://tts.wangwangit.com/">https://tts.wangwangit.com</a></p></blockquote><p><img src="https://img.996007.icu/file/1754988428646_image-20250812164659353.png" alt="image-20250812164659353"></p><h2 id="实战教程"><a href="#实战教程" class="headerlink" title="实战教程"></a>实战教程</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>你只需要：</p><ul><li>一个GitHub账号</li><li>一个Cloudflare账号（免费）</li><li>5分钟时间</li></ul><h3 id="第一步：获取项目代码"><a href="#第一步：获取项目代码" class="headerlink" title="第一步：获取项目代码"></a>第一步：获取项目代码</h3><ol><li>访问项目地址：<code>https://github.com/wangwangit/tts</code></li><li>点击右上角的 <code>Fork</code> 按钮，将项目复制到你的GitHub账号</li></ol><h3 id="第二步：一键部署到Cloudflare-Workers"><a href="#第二步：一键部署到Cloudflare-Workers" class="headerlink" title="第二步：一键部署到Cloudflare Workers"></a>第二步：一键部署到Cloudflare Workers</h3><ol><li><p><strong>注册Cloudflare账号</strong></p><ul><li>访问 <a href="https://cloudflare.com/">cloudflare.com</a></li><li>注册免费账号</li></ul></li><li><p><strong>一键部署</strong></p><ul><li>点击项目中的部署按钮：</li></ul><p><img src="https://img.996007.icu/file/1754988168810_image-20250812164236857.png" alt="image-20250812164236857"></p><ul><li>授权GitHub访问权限</li><li>选择要部署的仓库</li></ul><p><img src="https://img.996007.icu/file/1754988204911_image-20250812164318127.png" alt="image-20250812164318127"></p><ul><li>等待部署完成</li></ul></li><li><p><strong>获取访问地址</strong></p><ul><li>部署成功后，你会得到一个类似 <code>https://your-app.workers.dev</code> 的地址</li><li>这就是你的专属语音合成网站！</li></ul></li></ol><p><img src="https://img.996007.icu/file/1754988251075_image-20250812164405087.png" alt="image-20250812164405087"></p><h3 id="第三步：自定义域名（可选）"><a href="#第三步：自定义域名（可选）" class="headerlink" title="第三步：自定义域名（可选）"></a>第三步：自定义域名（可选）</h3><ol><li>在Cloudflare控制台中找到你的Worker</li><li>添加自定义域名</li><li>配置DNS解析</li></ol><p><img src="https://img.996007.icu/file/1754988273478_image-20250812164430064.png" alt="image-20250812164430064"></p><h3 id="API调用示例"><a href="#API调用示例" class="headerlink" title="API调用示例"></a>API调用示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础调用</span></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://your-domain.com/v1/audio/speech&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="attr">input</span>: <span class="string">&quot;你好，这是一个测试&quot;</span>,</span><br><span class="line">        <span class="attr">voice</span>: <span class="string">&quot;zh-CN-XiaoxiaoNeural&quot;</span>,</span><br><span class="line">        <span class="attr">speed</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">pitch</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&quot;general&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> audioBlob = <span class="keyword">await</span> response.<span class="title function_">blob</span>();</span><br></pre></td></tr></table></figure><h3 id="批量处理脚本"><a href="#批量处理脚本" class="headerlink" title="批量处理脚本"></a>批量处理脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 批量转换文本文件</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *.txt; <span class="keyword">do</span></span><br><span class="line">    curl -X POST <span class="string">&quot;https://your-domain.com/v1/audio/speech&quot;</span> \</span><br><span class="line">      -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">      -d <span class="string">&quot;&#123;\&quot;input\&quot;: \&quot;<span class="subst">$(cat $file)</span>\&quot;, \&quot;voice\&quot;: \&quot;zh-CN-XiaoxiaoNeural\&quot;&#125;&quot;</span> \</span><br><span class="line">      --output <span class="string">&quot;<span class="variable">$&#123;file%.txt&#125;</span>.mp3&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="注意事项与最佳实践"><a href="#注意事项与最佳实践" class="headerlink" title="注意事项与最佳实践"></a>注意事项与最佳实践</h2><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><ul><li>遵守微软服务条款</li><li>避免大量并发请求</li><li>不要用于商业用途的大规模部署</li></ul>]]></content>
    
    
    <summary type="html">还在为找不到合适的语音合成工具而烦恼吗？今天教你用微软Edge TTS技术，零成本搭建一个专属的文字转语音网站！</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="工具" scheme="https://www.wangwangit.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="TTS" scheme="https://www.wangwangit.com/tags/TTS/"/>
    
  </entry>
  
  <entry>
    <title>别再忍受卡顿了！抛开向日葵和ToDesk，这个免费远程神器才是真香(一)</title>
    <link href="https://www.wangwangit.com/%E5%88%AB%E5%86%8D%E5%BF%8D%E5%8F%97%E5%8D%A1%E9%A1%BF%E4%BA%86%EF%BC%81%E6%8A%9B%E5%BC%80%E5%90%91%E6%97%A5%E8%91%B5%E5%92%8CToDesk%EF%BC%8C%E8%BF%992%E4%B8%AA%E5%85%8D%E8%B4%B9%E8%BF%9C%E7%A8%8B%E7%A5%9E%E5%99%A8%E6%89%8D%E6%98%AF%E7%9C%9F%E9%A6%99/"/>
    <id>https://www.wangwangit.com/%E5%88%AB%E5%86%8D%E5%BF%8D%E5%8F%97%E5%8D%A1%E9%A1%BF%E4%BA%86%EF%BC%81%E6%8A%9B%E5%BC%80%E5%90%91%E6%97%A5%E8%91%B5%E5%92%8CToDesk%EF%BC%8C%E8%BF%992%E4%B8%AA%E5%85%8D%E8%B4%B9%E8%BF%9C%E7%A8%8B%E7%A5%9E%E5%99%A8%E6%89%8D%E6%98%AF%E7%9C%9F%E9%A6%99/</id>
    <published>2025-08-23T22:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.763Z</updated>
    
    <content type="html"><![CDATA[<p>最近有几个朋友不约而同地跟我吐槽，说手里的远程控制软件越来越不好用了。具体来说，就是我们最熟悉的向日葵和ToDesk，免费版用起来是肉眼可见的卡，尤其在晚上高峰期，操作延迟高得能让人抓狂。</p><img src="https://img.996007.icu/file/1754379070175_image-20250805153104134.png" alt="image-20250805153104134" style="zoom:200%;" /><p><img src="https://img.996007.icu/file/1754379015296_image-20250805153007317.png" alt="image-20250805153007317"></p><p>我也用了很久，深有同感。其实这背后原因不复杂，任何软件做大了，用户多了，自然要考虑赚钱。于是，通过限制免费版的性能和功能，引导你升级付费，就成了一种心照不宣的“常规操作”。咱们普通用户，就成了被“挤压”的对象。</p><p>最烦人的是，有时候只是连接时间长一点，或者在工作时间用了一下，就会被弹窗警告“疑似商业用途”，连接说断就断。这种不确定性，让原本方便的工具变得一点也不可靠了。</p><p>难道就没有又免费、又好用的远程控制软件了吗？</p><p>当然有！经过我一番折腾和深度试用，今天就给大家带来一个主打开箱即用的神器!</p><table><thead><tr><th align="left">特性维度</th><th align="left"><strong>向日葵&#x2F;ToDesk (免费版)</strong></th><th align="left"><strong>网易UU远程</strong></th></tr></thead><tbody><tr><td align="left"><strong>理想用户</strong></td><td align="left">轻度、应急用户</td><td align="left">游戏玩家、学生、上班族</td></tr><tr><td align="left"><strong>上手难度</strong></td><td align="left">⭐（极简）</td><td align="left">⭐（极简）</td></tr><tr><td align="left"><strong>性能体验</strong></td><td align="left">⭐⭐（高峰期卡顿）</td><td align="left">⭐⭐⭐⭐⭐（极致流畅）</td></tr><tr><td align="left"><strong>花费成本</strong></td><td align="left">免费（但体验受限）</td><td align="left"><strong>完全免费</strong></td></tr><tr><td align="left"><strong>核心优势</strong></td><td align="left">用户基数大</td><td align="left"><strong>免费提供顶级性能</strong></td></tr></tbody></table><hr><h3 id="网易UU远程"><a href="#网易UU远程" class="headerlink" title="网易UU远程"></a><strong>网易UU远程</strong></h3><blockquote><p>官网: <a href="https://uuyc.163.com/">https://uuyc.163.com</a></p></blockquote><p><strong>真4K、真免费、真好用，目前普通用户的“最优解”。</strong></p><p><img src="https://img.996007.icu/file/1754376857437_image-20250805145408656.png" alt="image-20250805145408656"></p><p><img src="https://img.996007.icu/file/1754376774799_image-20250805145241352.png" alt="image-20250805145241352"></p><p>无意中发现了这个工具，试用后我直接把电脑上其他的远程软件都给卸了。网易做游戏加速器起家，“UU加速器”在玩家圈里口碑一直不错。现在，他们把这套成熟的网络优化技术和服务器资源，拿来做了个远程控制软件，属于是“降维打击”了。</p><p>先说好,不是打广告,不过目前用下来,在还没有开始收割用户之前,还是非常不错的! 总结下来它有几个让我拍案叫绝的优点：</p><p><strong>1. 性能强到离谱，而且完全免费</strong><br>这可能是它最核心的竞争力。UU远程直接把付费级的功能全都免费了：</p><ul><li><strong>画质超清</strong>：支持到4K分辨率和144Hz刷新率，还提供了“真彩模式”。这是什么概念？就是你用手机或平板远程连接电脑，看到的画面色彩、清晰度，几乎和直接坐在电脑前一模一样。我试着用它在平板上串流玩《原神》，延迟低到几乎感觉不到，体验极佳。</li><li><strong>连接丝滑</strong>：得益于网易的加速技术，连接速度和稳定性确实没得说。我这边测试，基本都是秒连，操作起来行云流水，跟在本地用没啥区别，告别了传统免费软件那种PPT式的卡顿感。</li><li><strong>文件传输不限速</strong>：这个功能，说实话，太实用了！之前用其他软件的免费版传个大点的文件，那速度能让你等到花儿都谢了。UU远程直接不限速、不限文件大小和数量，我经常用它在公司和家里的电脑间传几十个G的视频素材，非常方便。</li></ul><p><img src="https://img.996007.icu/file/1754381519467_wechat_2025-08-05_161117_314.png" alt="wechat_2025-08-05_161117_314"></p><p><img src="https://img.996007.icu/file/1754377122539_work_0ac97461.gif" alt="work_0ac97461"></p><p><strong>2. 贴心好用，是个“细节控”</strong></p><img src="https://img.996007.icu/file/1754381156207_image-20250805160544284.png" alt="image-20250805160544284" style="zoom:200%;" /><p>除了性能，它的界面简洁, 易用性也做得很好。比如支持远程开机、一键隐藏被控电脑屏幕的“隐私模式”、多显示器协同等等。界面设计也很现代化，用设备码和验证码就能连接，小白用户也能轻松上手。</p><p>对了，还有个细节差点忘了，它对外设的支持特别好。不仅支持游戏手柄，甚至连iPad的妙控键盘都能完美适配，对移动办公和娱乐用户来说绝对是福音。</p><p><strong>适用人群：</strong></p><ul><li><strong>游戏玩家</strong>：随时随地在手机、平板上畅玩你的PC大作。</li><li><strong>学生&#x2F;上班族</strong>：远程修改论文、传输资料、临时处理工作，体验一流。</li><li><strong>创意工作者</strong>：虽然达不到最顶级的专业色彩标准，但其高清低延迟的特性，处理一般的设计稿和视频剪辑也绰绰有余。</li></ul><p>网易UU远程凭借其免费且强大的性能，是目前绝大多数普通用户的首选。不过也要坦诚一点，这种完全免费的模式能持续多久是个未知数，未来可能会加入广告或付费版。但至少在当下，它就是那个“我全都要”的完美答案。</p><p>当然,你也可以去看看我前几期推荐的组网工具,然后搭配微软官方的RDP进行远程!</p><blockquote><p><a href="https://mp.weixin.qq.com/s/Bx7MmQ5kOL0pfov9geFogQ">https://mp.weixin.qq.com/s/Bx7MmQ5kOL0pfov9geFogQ</a></p></blockquote><p><img src="https://img.996007.icu/file/1754377981602_image-20250805151253855.png" alt="image-20250805151253855"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>希望今天的分享能对你有所帮助！如果你有其他好用的工具，也欢迎在评论区留言交流。我们下期再见！下期我将分享更加极客的远程工具!</p>]]></content>
    
    
    <summary type="html">最近有几个朋友不约而同地跟我吐槽，说手里的远程控制软件越来越不好用了。具体来说，就是我们最熟悉的向日葵和ToDesk，免费版用起来是肉眼可见的卡，尤其在晚上高峰期，操作延迟高得能让人抓狂。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="工具" scheme="https://www.wangwangit.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="远程" scheme="https://www.wangwangit.com/tags/%E8%BF%9C%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>解锁听书新姿势，这个神仙TTS搭档你还没用上吗？</title>
    <link href="https://www.wangwangit.com/%E8%A7%A3%E9%94%81%E5%90%AC%E4%B9%A6%E6%96%B0%E5%A7%BF%E5%8A%BF%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%A5%9E%E4%BB%99TTS%E6%90%AD%E6%A1%A3%E4%BD%A0%E8%BF%98%E6%B2%A1%E7%94%A8%E4%B8%8A%E5%90%97%EF%BC%9F/"/>
    <id>https://www.wangwangit.com/%E8%A7%A3%E9%94%81%E5%90%AC%E4%B9%A6%E6%96%B0%E5%A7%BF%E5%8A%BF%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%A5%9E%E4%BB%99TTS%E6%90%AD%E6%A1%A3%E4%BD%A0%E8%BF%98%E6%B2%A1%E7%94%A8%E4%B8%8A%E5%90%97%EF%BC%9F/</id>
    <published>2025-08-23T22:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.767Z</updated>
    
    <content type="html"><![CDATA[<p>前几天写了一篇文章,介绍如何自建一个免费的TTS网站,有留言说能不能用来听小说,手机自带的音频都太生硬,听起来容易出戏, 像微信读书之类的APP又听着听着就让你开通会员了!</p><p>所以，今天就直接上干货，给大家介绍一款能让朗读效果天翻地覆的工具——MultiTTS。它和“阅读”APP组合起来，绝对能让你惊喜。</p><h3 id="一、MultiTTS-是什么？"><a href="#一、MultiTTS-是什么？" class="headerlink" title="一、MultiTTS 是什么？"></a>一、MultiTTS 是什么？</h3><p>简单来说，MultiTTS 是一款免费的安卓文本转语音（TTS）工具。你可以把它理解成一个“语音引擎”的空壳，它的强大之处在于可以导入各种第三方的语音包，实现非常丰富和逼真的朗读效果，甚至可以做到离线使用。</p><p>相比手机系统自带的TTS，它的优点很明显：</p><ul><li><strong>音色丰富</strong>：从普通话、方言到外语，各种AI主播的声音几乎都能找到。</li><li><strong>离线使用</strong>：导入离线语音包后，不用联网也能听书，不耗流量。</li><li><strong>高度自定义</strong>：可以调整语速、音量，甚至设置多角色对话朗读。</li></ul><p><img src="https://img.996007.icu/file/1755495306867_image-20250818133453881.png" alt="image-20250818133453881"></p><h3 id="二、手把手教你用-MultiTTS"><a href="#二、手把手教你用-MultiTTS" class="headerlink" title="二、手把手教你用 MultiTTS"></a>二、手把手教你用 MultiTTS</h3><p>第一次使用可能会觉得有点复杂，但跟着步骤走一遍，其实很简单。</p><blockquote><p>下载地址:</p><p>● 百度网盘(订阅有更新提醒)：<br><a href="https://pan.baidu.com/s/1BrdTby1W_zkQBNh0AdELfQ?pwd=0000">https://pan.baidu.com/s/1BrdTby1W_zkQBNh0AdELfQ?pwd=0000</a><br>提取码:0000</p><p>● 城通网盘：<br><a href="https://url85.ctfile.com/d/55370485-63896491-039200?p=1324">https://url85.ctfile.com/d/55370485-63896491-039200?p=1324</a><br>密码：1324</p><p>● 123云盘：<br><a href="https://www.123pan.com/s/6chuVv-yiqWd.html">https://www.123pan.com/s/6chuVv-yiqWd.html</a><br><a href="https://www.123pan.cn/s/6chuVv-yiqWd.html">https://www.123pan.cn/s/6chuVv-yiqWd.html</a></p><p>● 夸克网盘：<br><a href="https://pan.quark.cn/s/c3b5f9152054">https://pan.quark.cn/s/c3b5f9152054</a></p><p>● UC网盘：<br><a href="https://drive.uc.cn/s/742d2cb4b9584?public=1">https://drive.uc.cn/s/742d2cb4b9584?public=1</a></p><p>● 迅雷云盘：<br><a href="https://pan.xunlei.com/s/VOC6fFRhiDVvI7iwOwIy8_TyA1?pwd=dbvm#">https://pan.xunlei.com/s/VOC6fFRhiDVvI7iwOwIy8_TyA1?pwd=dbvm#</a></p></blockquote><p><strong>第一步：安装软件本体</strong></p><p>MultiTTS 本身只是一个引擎框架。首先，你需要安装它的主程序。</p><p><img src="https://img.996007.icu/file/1755495445922_image-20250818133719581.png" alt="image-20250818133719581"></p><p><strong>第二步：下载并导入语音包</strong></p><p>这是最关键的一步。MultiTTS 安装好后是个空壳，没有任何声音，需要我们手动导入“声音数据”，也就是语音包。这些语音包通常是以<code>.zip</code>压缩文件的形式提供的。可以先下载一个试试,然后没有合适的再去下载其他的语音包就可以啦!</p><p><img src="https://img.996007.icu/file/1755495457565_image-20250818133738885.png" alt="image-20250818133738885"></p><p><strong>直接导入（推荐新手使用）</strong>：</p><ul><li>启动 MultiTTS 应用。</li><li>点击界面右上角的三个点按钮，选择“导入数据”。</li><li>在弹出的文件管理器中，找到你下载好的语音包压缩文件（比如 <code>voice.zip</code>），直接选择它。注意，<strong>不需要解压</strong>这个文件。</li><li>导入过程需要一点时间，特别是语音包比较大的时候，耐心等待一下。</li></ul><p><img src="https://img.996007.icu/file/1755495562337_image-20250818133919174.png" alt="image-20250818133919174"></p><p><strong>第三步：设置为系统默认 TTS 引擎</strong></p><p>语音包导入成功后，你会在 MultiTTS 的主界面看到很多语音角色。接下来，将系统TTS引擎修改为这个软件即可。</p><ul><li>同样是点击右上角的三个点，选择“设置TTS”。</li><li>这时会跳转到手机系统的“文字转语音设置”页面。</li><li>在“首选引擎”或类似选项中，选择“MultiTTS”。</li></ul><p><img src="https://img.996007.icu/file/1755495687364_image-20250818134125731.png" alt="image-20250818134125731"></p><p>完成这三步，基础配置就算完成了。</p><h3 id="三、实际使用效果与技巧"><a href="#三、实际使用效果与技巧" class="headerlink" title="三、实际使用效果与技巧"></a>三、实际使用效果与技巧</h3><p>设置好之后，就可以去支持朗读功能的APP（比如各种阅读软件）里体验了。在阅读软件的朗读设置里，把朗读引擎切换为“系统默认TTS”，它就会自动调用 MultiTTS 来为你朗读。</p><p><img src="https://img.996007.icu/file/1755496593587_1755496097896_image-20250818134812478.png" alt="image-20250818134812478"></p><p><strong>我个人比较喜欢的一个功能是“多角色朗读”</strong>。在 MultiTTS 里长按一个语音角色，可以将其设置为“对话合成引擎”。这样一来，朗读小说时，旁白和人物对话就会由不同的声音来朗读，听起来非常有沉浸感，怎么说呢，就是那种听广播剧的感觉。</p><p><strong>对了，还有个细节差点忘了</strong>：为了防止朗读过程中被系统“杀后台”导致中断，最好给 MultiTTS 加上后台运行权限。在应用的设置里，找到“电池优化”选项，允许它后台高耗电运行。</p><p><img src="https://img.996007.icu/file/1755496596748_1755496176784_image-20250818134932122.png" alt="image-20250818134932122"></p><h3 id="五、最后"><a href="#五、最后" class="headerlink" title="五、最后"></a>五、最后</h3><ul><li><strong>局限性</strong>：这个方法目前只适用于安卓系统。另外，语音包的质量参差不齐，需要自己多试试才能找到喜欢的声音。</li><li><strong>替代方案</strong>：如果你觉得手动导入语音包太麻烦，也可以考虑一些集成的听书软件，比如“微信阅读”APP之类的!</li></ul><p>总的来说，MultiTTS 虽然前期配置需要花一点点时间，但一旦配置完成，它带来的听书体验提升是巨大的。从生硬的机器音到媲美真人的多角色朗读，这个转变绝对值得你花时间去尝试一下。当然,软件还有更多强大的功能,就需要自己去探索了, 希望这篇分享对你有帮助！</p>]]></content>
    
    
    <summary type="html">所以，今天就直接上干货，给大家介绍一款能让朗读效果天翻地覆的工具——MultiTTS。它和“阅读”APP组合起来，绝对能让你惊喜。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="工具" scheme="https://www.wangwangit.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="TTS" scheme="https://www.wangwangit.com/tags/TTS/"/>
    
  </entry>
  
  <entry>
    <title>运营商不想让你知道的秘密：超低价套餐办理全指南</title>
    <link href="https://www.wangwangit.com/%E8%BF%90%E8%90%A5%E5%95%86%E4%B8%8D%E6%83%B3%E8%AE%A9%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E7%A7%98%E5%AF%86%EF%BC%9A%E8%B6%85%E4%BD%8E%E4%BB%B7%E5%A5%97%E9%A4%90%E5%8A%9E%E7%90%86%E5%85%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://www.wangwangit.com/%E8%BF%90%E8%90%A5%E5%95%86%E4%B8%8D%E6%83%B3%E8%AE%A9%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E7%A7%98%E5%AF%86%EF%BC%9A%E8%B6%85%E4%BD%8E%E4%BB%B7%E5%A5%97%E9%A4%90%E5%8A%9E%E7%90%86%E5%85%A8%E6%8C%87%E5%8D%97/</id>
    <published>2025-08-23T22:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.768Z</updated>
    
    <content type="html"><![CDATA[<p>每次看到手机账单，你是不是都有一种“被套路”的感觉？</p><p>几百分钟用不完的通话时长，像是上个时代的标配；而真正当饭吃的流量，却总在月底前就早早告急。我们明明活在靠视频、社交和游戏续命的时代，为什么手机套餐却还停留在过去？</p><p>告诉你一个公开的秘密：<strong>这一切，都是设计好的。</strong></p><p>运营商们陷入了一个自己制造的“怪圈”, 一方面，社会责任让他们必须保留那些几乎不赚钱的低价套餐；但作为生意人，他们又希望我们每个人都花更多的钱。这种矛盾，让他们选择把最划算、最适合“保号”的套餐“雪藏”起来。</p><p>这篇指南，我会先带你撕开信息壁垒，手把手教你办下那个被藏起来的官方保号套餐。还会带你探索各种流量卡,让你转变为一个精明的消费者!</p><p>先说一下我的保号方案吧!我目前采用的是“<strong>保号套餐 + 流量卡</strong>”双卡组合策略.其核心逻辑是：</p><ol><li><strong>主号保号</strong>：将自己长期使用、绑定了银行、微信、支付宝等关键服务的主力手机号，更换为运营商提供的月租最低的官方“保号套餐”。其唯一目的，是以最低成本（通常在每月5至8元）维持号码有效，确保能正常接听电话、接收短信验证码。</li><li><strong>副卡上网</strong>：另外办理一张高性价比的“流量卡”，专门用于满足日常所有的上网需求。这类卡通常提供海量数据流量，而月租远低于三大运营商主营业厅的同等流量套餐。</li></ol><p><img src="https://img.996007.icu/file/1753514674206_20250726152424551.png" alt="image-20250726152424310"></p><p><img src="https://img.996007.icu/file/1753514681503_20250726152434906.png" alt="image-20250726152434650"></p><h2 id="四大运营商保底套餐详细对比"><a href="#四大运营商保底套餐详细对比" class="headerlink" title="四大运营商保底套餐详细对比"></a>四大运营商保底套餐详细对比</h2><table><thead><tr><th>运营商</th><th>套餐名称</th><th>月租</th><th>通话分钟</th><th>流量</th><th>短信</th><th>超出资费</th></tr></thead><tbody><tr><td><strong>中国电信</strong></td><td>5元无忧卡保号套餐</td><td><strong>5元</strong></td><td>0分钟</td><td>200MB</td><td>0条</td><td>通话0.1元&#x2F;分钟<br/>流量阶梯收费</td></tr><tr><td><strong>中国移动</strong></td><td>8元4G飞享套餐</td><td><strong>8元</strong></td><td>30分钟</td><td>10MB+500MB优惠包</td><td>0条</td><td>通话0.25元&#x2F;分钟<br/>流量0.29元&#x2F;MB</td></tr><tr><td><strong>中国联通</strong></td><td>8元流量王套餐</td><td><strong>8元</strong></td><td>30分钟</td><td>200MB</td><td>0条</td><td>通话0.15元&#x2F;分钟<br/>流量0.1元&#x2F;MB</td></tr><tr><td><strong>中国广电</strong></td><td>精彩套餐</td><td><strong>23元</strong></td><td>50分钟</td><td>10GB</td><td>0条</td><td>按套餐规定</td></tr></tbody></table><p><strong>最优选择</strong>：纯保号选电信5元套餐，轻度使用选联通8元套餐，移动老用户选8元飞享套餐配合优惠包。</p><h2 id="保底套餐办理实战攻略"><a href="#保底套餐办理实战攻略" class="headerlink" title="保底套餐办理实战攻略"></a>保底套餐办理实战攻略</h2><h3 id="中国移动8元套餐办理方法"><a href="#中国移动8元套餐办理方法" class="headerlink" title="中国移动8元套餐办理方法"></a>中国移动8元套餐办理方法</h3><p><strong>推荐方法：移动APP在线客服</strong></p><ol><li>打开中国移动APP，找到客服入口</li><li>输入”8元套餐”查询确认存在</li><li>输入”转人工”进入人工客服</li><li><strong>开场白</strong>：直接说”我要办理8元自由选套餐”</li><li>提供6位服务密码验证身份</li><li>选择30分钟通话版（推荐）</li><li>办理成功，次月生效</li></ol><p><strong>备用方法：10086电话客服</strong></p><ul><li>直拨10086转人工</li><li>坚持要求办理，不接受推诿</li></ul><h3 id="中国联通8元套餐办理方法"><a href="#中国联通8元套餐办理方法" class="headerlink" title="中国联通8元套餐办理方法"></a>中国联通8元套餐办理方法</h3><p><strong>微信公众号办理</strong>：</p><ol><li>关注”中国联通客服”微信公众号</li><li>选择在线客服→转人工</li><li>明确要求办理”全国流量王8元套餐”</li><li><strong>特殊要求</strong>：需现场拍摄身份证正反面上传</li><li>按提示完成办理</li></ol><p><strong>备用方法：10010客服</strong></p><ul><li>直拨10086转人工</li><li>坚持要求办理，不接受推诿</li></ul><h3 id="中国电信5元套餐办理方法"><a href="#中国电信5元套餐办理方法" class="headerlink" title="中国电信5元套餐办理方法"></a>中国电信5元套餐办理方法</h3><p><strong>最简单</strong>：直接拨打10000客服，表明办理5元保底套餐需求。电信客服阻挠相对最少。</p><h2 id="办理前必要条件"><a href="#办理前必要条件" class="headerlink" title="办理前必要条件"></a>办理前必要条件</h2><h3 id="必备条件检查清单"><a href="#必备条件检查清单" class="headerlink" title="必备条件检查清单"></a>必备条件检查清单</h3><ul><li><strong>号码状态</strong>：无欠费，账户余额充足</li><li><strong>绑定业务</strong>：未绑定宽带、副卡等业务</li><li><strong>合约状态</strong>：无保底消费合约限制</li><li><strong>服务密码</strong>：准备6位服务密码</li><li><strong>身份证件</strong>：确保信息准确无误</li></ul><h3 id="办理失败的主要原因"><a href="#办理失败的主要原因" class="headerlink" title="办理失败的主要原因"></a>办理失败的主要原因</h3><ol><li><strong>合约限制</strong>：有保底消费合约未到期</li><li><strong>绑定业务</strong>：宽带、副卡等绑定业务</li><li><strong>欠费状态</strong>：账户有未结清费用</li><li><strong>地区限制</strong>：部分地区政策收紧</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>通常,我们去联系客服更改套餐时,客服可能会做一些阻挠,只要坚持态度,一般都是能正常办理成功的! <strong>正常业务办理可以态度坚决一些,另外不推荐大家以这种方式去获取一些不符合规则的流量套餐之类的!</strong></p><table><thead><tr><th>客服话术</th><th>应对方法</th></tr></thead><tbody><tr><td>“套餐已下架，无法办理”</td><td>“请帮我查询确认，我看APP上还有这个套餐”</td></tr><tr><td>“18元以下需要营业厅办理”</td><td>“为什么之前可以在线办理？我记录客服工号准备投诉”</td></tr><tr><td>“系统升级，暂时无法办理”</td><td>“请明确回答能或不能，我已录音并准备投诉工信部”</td></tr><tr><td>“需要老年证&#x2F;贫困证明”</td><td>“工信部未规定需要额外证件，这是违规要求”</td></tr></tbody></table><p>最后,实在没有办法,可以前往工信部进行投诉,这是我们的正常权益!</p><p><strong>投诉步骤</strong>：</p><ol><li>访问工信部投诉网站：yhssglxt.miit.gov.cn</li><li>投诉类型选择：”限制办理业务”</li><li>投诉内容：”运营商拒绝办理8元套餐，限制用户选择权”</li><li>等待运营商主动联系处理</li></ol><h2 id="如何选择流量卡"><a href="#如何选择流量卡" class="headerlink" title="如何选择流量卡?"></a>如何选择流量卡?</h2><p>很多人担心这些流量卡会跑路,实际上,抖音,淘宝等平台的号卡都是这种,也会有物联网卡类似的,下面给大家介绍一下两者的区别!</p><h3 id="物联网卡"><a href="#物联网卡" class="headerlink" title="物联网卡"></a>物联网卡</h3><p>在所有风险中，最需要警惕的是买到被违规销售的“物联网卡”（IoT卡）。</p><ul><li><strong>本质区别</strong>：物联网卡是运营商为企业用户设计的，用于连接物联网设备（如共享单车、智能电表、POS机等），而非个人手机。工信部明令禁止向个人用户销售物联网卡，也禁止个人用户在手机上使用 。</li><li><strong>灰色产业</strong>：一些不法商家通过非正规渠道套取企业用的物联网卡，包装成“流量卡”卖给个人用户，形成了灰色产业链 。</li><li><strong>巨大风险</strong>：使用物联网卡的风险极高。首先，卡的所有权不在您名下，您的权益无法得到保障。其次，代理商随时可能“跑路”，您充值的钱款和未使用的流量将血本无归。最重要的是，运营商一旦检测到物联网卡被用于个人手机，有权（且被要求）随时封停该卡，届时您将面临突然断网的窘境，且难以维权 。</li></ul><h3 id="流量卡"><a href="#流量卡" class="headerlink" title="流量卡"></a>流量卡</h3><p>一个典型的流量卡分销价值链条如下：</p><ol><li><strong>运营商</strong>：设计基础的促销资费方案。</li><li><strong>省级&#x2F;市级总代理</strong>：与运营商签约，批量获取号卡资源。</li><li><strong>分销平台（如172号卡）</strong>：与总代理合作，将号卡产品上架至平台，并提供技术支持和佣金结算。</li></ol><blockquote><p>流量卡一般都是有一年两年的优惠价格,到期后会恢复原价,当然,也有长期优惠的,这个看个人选择,比我们日常在营业厅办理的套餐肯定是优惠很多的!</p></blockquote><p><img src="https://img.996007.icu/file/1753516090759_20250726154806766.png" alt="image-20250726154806523"></p><h3 id="流量卡分销平台运作模式"><a href="#流量卡分销平台运作模式" class="headerlink" title="流量卡分销平台运作模式"></a>流量卡分销平台运作模式</h3><p><strong>172号卡平台核心模式</strong>：</p><ul><li><strong>规模</strong>：下单用户已超5000万</li><li><strong>佣金机制</strong>：”秒返+月返”复合结算，首充返现80-180元</li><li><strong>层级体系</strong>：金钻、黑钻、一级、二级代理等多级分销</li><li><strong>结算方式</strong>：平台自动分佣，抽取6%税费</li></ul><p><strong>其他主流平台对比</strong>：</p><ul><li><strong>卡博世</strong>：注册需299元代理费，5天提取佣金</li><li><strong>感叹号平台</strong>：C2C模式，风险较高</li><li><strong>秒返、号易等</strong>：数百个大小平台并存</li></ul><h3 id="流量卡选择的风险与防范"><a href="#流量卡选择的风险与防范" class="headerlink" title="流量卡选择的风险与防范"></a>流量卡选择的风险与防范</h3><p><strong>主要骗局类型</strong>：</p><ol><li><strong>货不对板</strong>：用便宜卡吸引下单，推销高价产品</li><li><strong>信息诈骗</strong>：骗取身份信息申请合约产品</li><li><strong>返费陷阱</strong>：承诺补贴需主动申请，经常”忘记”</li><li><strong>虚假宣传</strong>：物联卡冒充流量卡，无法正常使用</li><li><strong>商家跑路</strong>：收费后直接失联</li></ol><p><strong>用户防范建议</strong>：</p><ul><li>选择正规平台，避免无备案小平台</li><li>仔细阅读协议期、违约金等条款</li><li>核实归属地，避免异地办理麻烦</li><li>保留购买记录等维权证据</li><li>可向工信部12381或12315投诉</li></ul><h2 id="最佳省钱方案推荐"><a href="#最佳省钱方案推荐" class="headerlink" title="最佳省钱方案推荐"></a>最佳省钱方案推荐</h2><h3 id="方案一：保底套餐-流量卡组合"><a href="#方案一：保底套餐-流量卡组合" class="headerlink" title="方案一：保底套餐+流量卡组合"></a>方案一：保底套餐+流量卡组合</h3><ul><li><strong>主卡</strong>：电信5元保底套餐（保号）</li><li><strong>副卡</strong>：19元大流量卡（185G流量）</li><li><strong>总费用</strong>：24元&#x2F;月，年省费用2000+元</li></ul><h3 id="方案二：单独保底套餐-活动流量"><a href="#方案二：单独保底套餐-活动流量" class="headerlink" title="方案二：单独保底套餐+活动流量"></a>方案二：单独保底套餐+活动流量</h3><ul><li><strong>选择</strong>：联通8元套餐+官方APP流量活动</li><li><strong>优势</strong>：操作简单，风险较低</li><li><strong>费用</strong>：约15-25元&#x2F;月</li></ul><h3 id="方案三：移动用户专属"><a href="#方案三：移动用户专属" class="headerlink" title="方案三：移动用户专属"></a>方案三：移动用户专属</h3><ul><li><strong>套餐</strong>：移动8元飞享+6元流量优惠包</li><li><strong>流量扩容</strong>：签到领流量、咪咕赠送等</li><li><strong>总费用</strong>：14元&#x2F;月+额外福利</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>有需要172平台邀请码的,可以给公众号留言,我看到后会回复,或者有需要办卡的,可以去这里看一下!</p><p><img src="https://img.996007.icu/file/1753516175199_20250726154925268.png" alt="image-20250726154925111"></p>]]></content>
    
    
    <summary type="html">这篇指南，我会先带你撕开信息壁垒，手把手教你办下那个被藏起来的官方保号套餐。还会带你探索各种流量卡,让你转变为一个精明的消费者!</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="手机卡" scheme="https://www.wangwangit.com/tags/%E6%89%8B%E6%9C%BA%E5%8D%A1/"/>
    
    <category term="低价套餐" scheme="https://www.wangwangit.com/tags/%E4%BD%8E%E4%BB%B7%E5%A5%97%E9%A4%90/"/>
    
  </entry>
  
  <entry>
    <title>求你了，买东西前先搜一下，能省下一顿火锅钱</title>
    <link href="https://www.wangwangit.com/%E6%B1%82%E4%BD%A0%E4%BA%86%EF%BC%8C%E4%B9%B0%E4%B8%9C%E8%A5%BF%E5%89%8D%E5%85%88%E6%90%9C%E4%B8%80%E4%B8%8B%EF%BC%8C%E8%83%BD%E7%9C%81%E4%B8%8B%E4%B8%80%E9%A1%BF%E7%81%AB%E9%94%85%E9%92%B1/"/>
    <id>https://www.wangwangit.com/%E6%B1%82%E4%BD%A0%E4%BA%86%EF%BC%8C%E4%B9%B0%E4%B8%9C%E8%A5%BF%E5%89%8D%E5%85%88%E6%90%9C%E4%B8%80%E4%B8%8B%EF%BC%8C%E8%83%BD%E7%9C%81%E4%B8%8B%E4%B8%80%E9%A1%BF%E7%81%AB%E9%94%85%E9%92%B1/</id>
    <published>2025-08-21T22:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.766Z</updated>
    
    <content type="html"><![CDATA[<p>哥们，我先摊牌了。</p><p>我现在买东西，几乎都能有优惠价。</p><p>不是我抠，是真的肉疼。上个月，我原价买了双鞋，399。两天后，我一哥们儿也买了，他花了多少？100出头。</p><p>我当时就炸了，直接微信电话轰炸他：“你丫是不是有内部渠道？！”</p><p>他悠悠地回了我一句：“渠道个屁，你不会用返利啊？”</p><p>那一刻，我感觉我过去二十多年网购，花的钱都跟大风刮来的一样。</p><blockquote><p>下面是我京东试用中奖领到的一台空调,有兴趣的也可以去了解一下京东试用!</p></blockquote><p><img src="https://img.996007.icu/file/1753857624530_image-20250730144020001.png" alt="image-20250730144020001"></p><p>今天，我就给你讲讲“羊毛党”背后的秘密，让你也感受一下，每次下单都能省钱的快乐。</p><h3 id="这优惠到底哪来的？合法吗？"><a href="#这优惠到底哪来的？合法吗？" class="headerlink" title="这优惠到底哪来的？合法吗？"></a>这优惠到底哪来的？合法吗？</h3><p>我知道你第一个问题肯定是这个：“这玩意儿靠谱吗？别是骗人的吧？”</p><p>我一开始也这么想。总觉得是占了平台便宜，心里发虚。</p><p>后来我那哥们儿给我画了个图，我秒懂了：</p><p><strong>商家（比如卖鞋的那个店） → 想多卖货 → 找人推广（比如我哥们儿）→ 推广成功了 → 商家给推广的人发佣金 → 我哥们儿把佣金分我一点，拉我下次还找他。</strong></p><p>看明白没？</p><p>你收到的那点“返利”，就是推广的人，从商家给的广告费里，分给你的“辛苦费”。</p><p>这事儿对三方都有好处：</p><ul><li><strong>商家</strong>：卖出货才给钱，不亏。</li><li><strong>推广的人</strong>：赚了点零花钱。</li><li><strong>咱</strong>：实打实地省钱了。</li></ul><p>所以，这不是什么见不得人的事儿，是淘宝、京东官方都点头认可的正规玩法。咱不是在钻空子，是在理直气壮地拿回本该属于消费者的福利。</p><h3 id="我能自己推广么"><a href="#我能自己推广么" class="headerlink" title="我能自己推广么?"></a>我能自己推广么?</h3><p>市面上一堆返利APP，名字五花八门，其实说白了就下面几种，你按需取用就行。<br><strong>第一种：官方推广，安全可靠</strong></p><p>各大电商平台都拥有自己的官方推广平台，这是整个生态的源头。有网站也有APP,可以自行搜索下载!官方的返利都是有等级制度的,可以自行与第三方平台对比一下返利,因为这里第三方一般是按最高级别获取的返利!</p><p><strong>淘宝: 淘宝联盟</strong></p><blockquote><p>地址: <a href="https://aff-open.taobao.com/">https://aff-open.taobao.com</a></p></blockquote><p><img src="https://img.996007.icu/file/1753856668516_image-20250730142423573.png" alt="image-20250730142423573"></p><p><strong>京东: 京粉</strong></p><p><img src="https://img.996007.icu/file/1753860524658_image-20250730152836042.png" alt="image-20250730152836042"></p><p><strong>拼多多: 多多进宝</strong></p><p><img src="https://img.996007.icu/file/1753856705825_image-20250730142501827.png" alt="image-20250730142501827"></p><p><strong>第二种：懒人必备，主打一个“方便”</strong><br>（比如什么蜜源、一淘、返利网……名字不重要，逻辑都一样）</p><p>这就是我现在的日常主力。操作简单到发指：</p><blockquote><p><strong>淘宝看中东西 → 复制标题&#x2F;链接 → 打开这类APP → 自动弹出优惠券和返利 → 点一下跳回淘宝下单。</strong></p></blockquote><p><img src="https://img.996007.icu/file/1753856622628_image-20250730142338235.png" alt="image-20250730142338235"></p><p>完事儿。</p><p>**优点：**傻瓜式操作，一个APP能搜淘宝、京东、拼多多甚至美团饿了么，简直是省钱界的“万能钥匙”。<br>**缺点：**它作为“二道贩子”，会抽一点点佣金。比如商家给了10块推广费，它可能给你8块，自己留2块。</p><p>但讲真，为了这份方便，让它赚两块，我认了。</p><p><strong>第二种：买大件、做研究必备，主打一个“专业”</strong><br>（我就直说吧，就是“什么值得买”，人称张大妈）</p><p>这家伙跟上面那些完全不是一个路子。</p><p>你什么时候用它？<strong>当你要买个贵的东西，又怕买错的时候。</strong></p><p>比如你要买手机、买冰箱、买车，你上去一搜，铺天盖地的真实用户评测(<strong>曾经</strong>)、长文分析、优缺点对比，能把你从小白直接武装成半个专家。实际上每个平台刚开始出来的时候,都比较真诚,没有那么多套路,现在<strong>张大妈里面也各种刷好评,商家套路了,需要自己分辨!</strong></p><p>它帮你省的，不只是钱，更是买回来就后悔的“沉没成本”。</p><p><strong>我的建议，简单粗暴：</strong></p><ul><li><strong>日常买小东西，用第一种，无脑省钱。</strong></li><li><strong>要花大钱了，先去“什么值得买”泡一天，看看别人怎么说，再决定买不买，怎么买。</strong></li></ul><p>为了更清晰地对比，下表总结了三大主流返利平台的模式：</p><table><thead><tr><th>平台</th><th>核心模式</th><th>主要优点</th><th>主要缺点</th><th>适合人群</th></tr></thead><tbody><tr><td>**淘宝联盟&#x2F;京粉 **</td><td>官方CPS直连</td><td>佣金比例最高，无中间商</td><td>操作复杂，对普通用户不友好</td><td>专业的推广者，有技术能力的资深玩家</td></tr><tr><td>**返利网&#x2F;蜜源 **</td><td>第三方API聚合</td><td>操作简单，一站式覆盖多平台</td><td>佣金被中间商抽成，返利非最高</td><td>追求方便快捷的普通购物者</td></tr><tr><td>**什么值得买 **</td><td>内容驱动+CPS</td><td>专业评测和导购，避免踩坑</td><td>返利并非核心，需要主动搜索</td><td>做购物研究，购买高价值或不熟悉品类的消费者</td></tr></tbody></table><h3 id="返利群是咋实现的"><a href="#返利群是咋实现的" class="headerlink" title="返利群是咋实现的?"></a>返利群是咋实现的?</h3><p>这里就需要大家去看看我公众号<code>一只会飞的旺旺</code>前段时间写的微信机器人的文章了!</p><p><img src="https://img.996007.icu/file/1753857401111_image-20250730143634300.png" alt="image-20250730143634300"></p><p>你可能正在某个“XX好物分享”、“XX妈咪内买”、“XX内部优惠”的群里待着。群主每天不知疲倦地发着各种带链接的商品，从十几块的垃圾袋到几千块的手机，号称都是“神价”。</p><p>说白了，<strong>群主就是个“人工选品机”+“推广员”</strong>。</p><p>他干的活，就是把咱们用返利APP要做的“搜索”那一步，替你干了。他会花大量时间在各种渠道里找那些折扣力度大、佣金高的商品，然后把链接转换成他自己的推广链接，再一股脑地扔进群里。</p><p>群里只要有任何一个人，通过他发的链接买了东西，这笔佣金就归群主所有。他一个人，赚整个群的钱。</p><p><strong>那为啥有人愿意待在群里，而不是自己搜？</strong></p><p>一个字：<strong>懒</strong>。而且，群里偶尔真的会冒出一些 <strong>“神车”</strong>。</p><p>啥叫“神车”？就是商家因为各种原因（比如价格设置错误、优惠券力度太大、或者为了冲销量亏本赚吆喝），搞出来的限时、限量的超低价商品。比如一件衣服标价199，结果弹出张180的券，你10几块就到手了。</p><p>这种好事，手快有，手慢无。而群主这种“职业选手”，往往是消息最灵通的，能第一时间发现并分享出来。所以，很多人待在群里，就是为了等这种可遇不可求的“捡漏”机会。</p><p>但说实话，<strong>这种“神车”一年也碰不到几次。群里99%的内容，还是那些常规的、咱们自己用APP也能搜到的返利商品。</strong> 群主只是把它们筛选打包，喂到你嘴边而已。</p><blockquote><p>针对商家误操作之类的优惠价格,还是希望大家手下留情,毕竟做生意也不容易!薅羊毛也得有道德是不!</p></blockquote><h3 id="最重要的来了！千万别让“省钱”变成“被骗”！"><a href="#最重要的来了！千万别让“省钱”变成“被骗”！" class="headerlink" title="最重要的来了！千万别让“省钱”变成“被骗”！"></a>最重要的来了！千万别让“省钱”变成“被骗”！</h3><p>朋友，前面说的都是怎么捡钱，现在我要跟你说的，是怎么保命。</p><p><strong>你一定，一定，一定听过“刷单”吧？</strong></p><p>我发誓，这是我见过最蠢、也最狠的骗局。它就是蹭了“返利”这个词的热度，来骗你钱的。</p><p><strong>求你了，人间清醒一点！天上不会掉馅饼，只会掉铁饼！</strong></p><p>骗子的套路，我都能背下来了：</p><ol><li>用“日赚800”、“点赞赚钱”的短信当诱饵。</li><li>让你下载个来路不明的APP，先给你个100块的小单子，刷完，立马返你105。</li><li>你信了。然后告诉你，有个“组合任务”，要刷满5000块，才能一次性返你6000。</li><li>你东拼西凑投了5000进去。然后……就没有然后了。对方会用“系统卡单”、“账户冻结”各种理由，让你继续投钱，直到把你骨髓都榨干。</li></ol><p>每年都有人因为这个家破人亡，新闻都报烂了。</p><p><strong>怎么分辨？我给你一个100%管用的方法，记住这条铁律，能保住你的钱包：</strong></p><blockquote><p><strong>咱玩的购物返利，从头到尾，钱都是付给淘宝、京东的官方订单。</strong></p><p><strong>骗子玩的刷单，第一步就是要你“垫付”！让你把钱转给他们！</strong></p></blockquote><p><strong>一句话总结：</strong></p><h3 id="凡是要你先掏钱垫付的，全是诈骗！一个字都别信！"><a href="#凡是要你先掏钱垫付的，全是诈骗！一个字都别信！" class="headerlink" title="凡是要你先掏钱垫付的，全是诈骗！一个字都别信！"></a><strong>凡是要你先掏钱垫付的，全是诈骗！一个字都别信！</strong></h3><p>咱们是在规则里<strong>省钱</strong>，不是在规则外<strong>送钱</strong>。</p><p>还有，如果一个APP，不教你怎么买东西省钱，天天催你“交99块升级”、“拉人头拿提成”，你也赶紧跑，那是传销的坑。</p><p>好了，掏心窝子的话就说这么多了。</p><p>这门省钱手艺，说难不难，说简单，也得你亲自试试。</p><p>秘籍交给你了，下次买东西前，花个10秒钟搜一下，省下的钱，给自己加个鸡腿，不香吗？</p><p>如果觉得这篇文章帮助到你了,请动动小手,一键三连一下!!</p>]]></content>
    
    
    <summary type="html">今天，我就给你讲讲“羊毛党”背后的秘密，让你也感受一下，每次下单都能省钱的快乐。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="购物" scheme="https://www.wangwangit.com/tags/%E8%B4%AD%E7%89%A9/"/>
    
    <category term="羊毛" scheme="https://www.wangwangit.com/tags/%E7%BE%8A%E6%AF%9B/"/>
    
  </entry>
  
  <entry>
    <title>人人都能看懂的HTTP学习笔记</title>
    <link href="https://www.wangwangit.com/HTTP%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.wangwangit.com/HTTP%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-07-25T09:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP的基本概念"><a href="#HTTP的基本概念" class="headerlink" title="HTTP的基本概念"></a>HTTP的基本概念</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">  %% 配色和样式</span><br><span class="line">  classDef title fill:#6366f1,stroke:#1e3a8a,color:#fff,stroke-width:2px;</span><br><span class="line">  classDef group fill:#c7d2fe,stroke:#4f46e5,stroke-width:1px;</span><br><span class="line">  classDef detail fill:#eff6ff,stroke:#60a5fa,stroke-width:1px,color:#111827;</span><br><span class="line"></span><br><span class="line">  %% 节点定义</span><br><span class="line">  A[&quot;📘 章1: Web与网络基础&quot;]:::title</span><br><span class="line"></span><br><span class="line">  A --&gt; B[&quot;🧱 网络基石：TCP/IP 协议族&quot;]:::group</span><br><span class="line">  B --&gt; B1[&quot;📐 分层管理&quot;]:::group</span><br><span class="line">  B1 --&gt; B1a[&quot;🌐 应用层 (HTTP, DNS, FTP...)&quot;]:::detail</span><br><span class="line">  B1 --&gt; B1b[&quot;📦 传输层 (TCP, UDP)&quot;]:::detail</span><br><span class="line">  B1 --&gt; B1c[&quot;🛰️ 网络层 (IP, ARP)&quot;]:::detail</span><br><span class="line">  B1 --&gt; B1d[&quot;🧩 链路层 (驱动, 网卡)&quot;]:::detail</span><br><span class="line">  B --&gt; B2[&quot;🔁 通信流程&quot;]:::group</span><br><span class="line">  B2 --&gt; B2a[&quot;📤 封装（从上到下加头）&quot;]:::detail</span><br><span class="line">  B2 --&gt; B2b[&quot;📥 解封装（从下到上拆头）&quot;]:::detail</span><br><span class="line"></span><br><span class="line">  A --&gt; C[&quot;🤝 HTTP 的三大协作伙伴&quot;]:::group</span><br><span class="line">  C --&gt; C1[&quot;📍 IP：负责寻址和路由&quot;]:::detail</span><br><span class="line">  C --&gt; C2[&quot;🔐 TCP：可靠传输（三次握手）&quot;]:::detail</span><br><span class="line">  C --&gt; C3[&quot;🔎 DNS：域名到 IP 的解析&quot;]:::detail</span><br><span class="line"></span><br><span class="line">  A --&gt; D[&quot;🗺️ Web 资源定位&quot;]:::group</span><br><span class="line">  D --&gt; D1[&quot;🆔 URI vs URL&quot;]:::group</span><br><span class="line">  D1 --&gt; D1a[&quot;📎 URI（标识符）是父集&quot;]:::detail</span><br><span class="line">  D1 --&gt; D1b[&quot;📍 URL（定位符）是子集&quot;]:::detail</span><br><span class="line">  D --&gt; D2[&quot;📑 URL 格式&quot;]:::group</span><br><span class="line">  D2 --&gt; D2a[&quot;scheme://user:pass@host:port/path?query#fragment&quot;]:::detail</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="HTTP请求-响应流程图"><a href="#HTTP请求-响应流程图" class="headerlink" title="HTTP请求-响应流程图"></a>HTTP请求-响应流程图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant User as 👤 用户</span><br><span class="line">    participant Browser as 🧭 浏览器 (客户端)</span><br><span class="line">    participant DNS as 🌐 DNS服务器</span><br><span class="line">    participant Server as 🖥️ 服务器</span><br><span class="line"></span><br><span class="line">    User-&gt;&gt;Browser: 输入 www.example.com&lt;br&gt;并回车</span><br><span class="line">    Browser-&gt;&gt;DNS: 查询域名 IP</span><br><span class="line">    DNS--&gt;&gt;Browser: 返回 IP 地址</span><br><span class="line">    Browser-&gt;&gt;Server: 建立TCP连接</span><br><span class="line">    Browser-&gt;&gt;Server: 发送 HTTP 请求&lt;br&gt;(GET / HTTP/1.1)</span><br><span class="line">    Note over Server: 服务器处理请求，查找资源</span><br><span class="line">    Server--&gt;&gt;Browser: 返回 HTTP 响应&lt;br&gt;(200 OK, HTML)</span><br><span class="line">    Browser-&gt;&gt;User: 解析 HTML&lt;br&gt;渲染页面并显示</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生活案例"><a href="#生活案例" class="headerlink" title="生活案例"></a>生活案例</h3><p>把HTTP通信想象成你去一家图书馆借书。</p><ul><li><strong>你（客户端）</strong> 想借一本书（资源）。</li><li>你知道书的准确位置（URL），比如“三楼社科区A-18架第3排”。</li><li>你填写一张借书单（<strong>HTTP请求</strong>）并交给图书管理员（<strong>服务器</strong>）。</li><li>图书管理员根据单子找到书，连同借阅凭证一起给你（<strong>HTTP响应</strong>）。</li><li>如果书不在或者你没借书证，他会告诉你“没找到”（404）或“请出示证件”（401）。</li></ul><h3 id="真实案例"><a href="#真实案例" class="headerlink" title="真实案例"></a>真实案例</h3><p>在一个电商网站中，当你点击“我的订单”时：</p><ol><li>你的浏览器（前端应用，如Vue&#x2F;React）会发起一个HTTP GET 请求，URL可能是 <a href="https://api.ecommerce.com/orders?user_id=123%E3%80%82">https://api.ecommerce.com/orders?user_id=123。</a></li><li>这个请求通过互联网发送到电商的后端API服务器。</li><li>服务器验证你的身份，然后去数据库查询用户123的所有订单信息。</li><li>服务器将订单信息打包成一个JSON格式的字符串，放入HTTP响应体中，并返回给你的浏览器。</li><li>浏览器接收到JSON数据后，动态地将订单列表渲染到页面上。</li></ol><p>在这个案例中，HTTP扮演了前后端数据通信的“信使”角色。</p><h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>问题: 当你在浏览器地址栏里输入一个URL，然后按下回车，直到你看到页面，这中间发生了什么？</p></blockquote><p><strong>1. 应用层 - URL解析与HTTP请求构建：</strong></p><ul><li>浏览器首先会解析我输入的URL，识别出协议（HTTP&#x2F;HTTPS）、域名、端口、路径等信息。</li><li>它会构建一个HTTP请求报文，最核心的是请求行，比如 GET &#x2F;index.html HTTP&#x2F;1.1，以及包含Host在内的各种请求头。</li></ul><p><strong>2. 应用层 - DNS解析：</strong></p><ul><li>浏览器需要将URL中的域名（比如 <a href="http://www.example.com)解析成服务器的ip地址./">www.example.com）解析成服务器的IP地址。</a></li><li>它会依次查询：浏览器缓存 -&gt; 操作系统缓存 -&gt; 本地Hosts文件 -&gt; 本地DNS服务器。如果都找不到，本地DNS服务器会向根DNS服务器发起递归查询，最终找到目标IP地址。</li></ul><p><strong>3. 传输层 - TCP连接（三次握手）：</strong></p><ul><li>知道了服务器IP和端口（HTTP默认80，HTTPS默认443）后，浏览器会通过TCP协议与服务器建立连接。</li><li>这个过程就是著名的“三次握手”：客户端发送SYN包，服务器回复SYN+ACK包，客户端再回复ACK包，连接建立。如果是HTTPS，这里还会进行TLS握手。</li></ul><p><strong>4. 网络层 - IP寻址与路由：</strong></p><ul><li>TCP将HTTP请求报文分割成TCP报文段，并打包成IP数据包。通过IP寻址和路由器一跳一跳的转发，最终将数据包发送到目标服务器。</li></ul><p><strong>5. 服务器处理请求：</strong></p><ul><li>服务器接收到请求后，Web服务器（如Nginx）会进行处理，可能会将请求转发给后端的业务逻辑（如Node.js, Tomcat）。</li><li>后端应用处理请求，可能涉及数据库查询等操作，然后生成一个HTTP响应报文。</li></ul><p><strong>6. 返回响应与浏览器渲染：</strong></p><ul><li>服务器将HTTP响应报文（包含状态码200 OK和HTML页面内容）通过TCP连接发回给浏览器。</li><li>浏览器接收到响应后，开始解析HTML，构建DOM树。同时，如果HTML中包含CSS、JavaScript、图片等外部资源，浏览器会重复上述过程为每个资源发起新的HTTP请求。</li><li>最终，浏览器将DOM树、CSSOM树结合，进行布局（Layout）和绘制（Paint），将完整的页面呈现给我。</li></ul><p><strong>7. 连接关闭（四次挥手）：</strong></p><ul><li>在HTTP&#x2F;1.1的持久连接下，TCP连接可能不会立即关闭，以便复用。但最终会通过“四次挥手”来断开连接。</li></ul><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><ul><li>流程中的位置：DNS解析阶段</li></ul><ul><li><strong>核心概念：</strong> CDN（Content Delivery Network，内容分发网络）本质上是一个<strong>分布式的缓存系统</strong>。它将网站的静态资源（如图片、CSS、JavaScript文件，甚至部分动态内容）缓存到全球各地、靠近用户的“边缘节点”（Edge Node）上。</li><li><strong>解决的问题：</strong> <strong>物理延迟</strong>。如果你的服务器在纽约，上海的用户访问它，数据来回需要跨越太平洋，光速的限制是无法逾越的。CDN通过让用户访问离他最近的节点来获取资源，极大地缩短了物理距离，从而降低延迟。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant User as 👤 用户&lt;br&gt;(上海)</span><br><span class="line">    participant SmartDNS as 🌐 智能DNS&lt;br&gt;(CDN)</span><br><span class="line">    participant CdnNode as 🏢 CDN边缘节点&lt;br&gt;(香港)</span><br><span class="line">    participant OriginServer as 🖥️ 源服务器&lt;br&gt;(纽约)</span><br><span class="line"></span><br><span class="line">    User-&gt;&gt;SmartDNS: DNS查询&lt;br&gt;www.example.com</span><br><span class="line">    Note over SmartDNS: 检测到用户来自上海&lt;br&gt;（基于IP地理定位）</span><br><span class="line">    SmartDNS--&gt;&gt;User: 返回IP&lt;br&gt;香港CDN节点IP地址</span><br><span class="line"></span><br><span class="line">    User-&gt;&gt;CdnNode: HTTP请求&lt;br&gt;访问资源</span><br><span class="line">    alt 缓存命中 (Cache Hit)</span><br><span class="line">        CdnNode--&gt;&gt;User: 直接返回&lt;br&gt;缓存资源</span><br><span class="line">    else 缓存未命中 (Cache Miss)</span><br><span class="line">        CdnNode-&gt;&gt;OriginServer: 回源请求资源</span><br><span class="line">        OriginServer--&gt;&gt;CdnNode: 返回资源</span><br><span class="line">        Note over CdnNode: 缓存资源&lt;br&gt;并返回给用户</span><br><span class="line">        CdnNode--&gt;&gt;User: 返回资源</span><br><span class="line">    end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul><li>流程中的位置：TCP连接建立阶段</li></ul><ul><li><strong>核心概念：</strong> 负载均衡器是服务器集群的“交通警察”。当大量请求涌入时，它会将这些请求根据预设的策略（如轮询、最少连接数、IP哈希）分发到后方的多台Web服务器上。</li><li><strong>解决的问题：</strong> <strong>单点瓶颈和可扩展性</strong>。单个服务器的处理能力是有限的，无法应对高并发场景。负载均衡能将压力均分，使得系统可以通过简单地增加服务器数量（水平扩展）来提升整体处理能力。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    %% 样式定义</span><br><span class="line">    classDef req fill:#fee2e2,stroke:#ef4444,stroke-width:2px,color:#b91c1c;</span><br><span class="line">    classDef lb fill:#fef9c3,stroke:#eab308,stroke-width:2px,color:#a16207;</span><br><span class="line">    classDef server fill:#e0f2fe,stroke:#2563eb,stroke-width:2px,color:#0c4a6e;</span><br><span class="line">    classDef serverN fill:#f3f4f6,stroke:#9ca3af,stroke-dasharray:5 3,color:#6b7280;</span><br><span class="line"></span><br><span class="line">    %% 节点定义</span><br><span class="line">    Request(&quot;🌐 来自CDN/用户的&lt;br&gt;HTTP请求&quot;):::req</span><br><span class="line">    LB(&quot;🎛️ 负载均衡器&quot;):::lb</span><br><span class="line">    Server1(&quot;🖥️ Web服务器 1&quot;):::server</span><br><span class="line">    Server2(&quot;🖥️ Web服务器 2&quot;):::server</span><br><span class="line">    Server3(&quot;🖥️ Web服务器 3&quot;):::server</span><br><span class="line">    ServerN(&quot;🖥️ Web服务器 N&quot;):::serverN</span><br><span class="line"></span><br><span class="line">    %% 分组</span><br><span class="line">    subgraph 数据中心</span><br><span class="line">        LB</span><br><span class="line">        Server1</span><br><span class="line">        Server2</span><br><span class="line">        Server3</span><br><span class="line">        ServerN</span><br><span class="line">        LB --&gt;|分发策略| Server1</span><br><span class="line">        LB --&gt;|分发策略| Server2</span><br><span class="line">        LB --&gt;|分发策略| Server3</span><br><span class="line">        LB --&gt;|分发策略| ServerN</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    Request --&gt; LB</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="HTTP-2多路复用"><a href="#HTTP-2多路复用" class="headerlink" title="HTTP&#x2F;2多路复用"></a>HTTP&#x2F;2多路复用</h3><ul><li>流程中的位置：浏览器获取页面资源阶段</li><li><strong>核心概念：</strong> HTTP&#x2F;1.1存在“队头阻塞”（Head-of-Line Blocking）问题。虽然浏览器可以开多个TCP连接（通常6-8个），但每个连接同一时间只能处理一个请求-响应。而HTTP&#x2F;2的<strong>多路复用</strong>（Multiplexing）允许在<strong>单个TCP连接</strong>上同时发送和接收多个请求和响应，它们被分解成更小的帧，可以并行、交错地传输。</li><li><strong>解决的问题：</strong> <strong>网络传输效率</strong>。它消除了队头阻塞，减少了TCP连接建立的开销，使得页面资源加载速度更快。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    %% 样式</span><br><span class="line">    classDef http1 fill:#fee2e2,stroke:#ef4444,color:#b91c1c,stroke-width:2px;</span><br><span class="line">    classDef http2 fill:#d1fae5,stroke:#10b981,color:#065f46,stroke-width:2px;</span><br><span class="line">    classDef req fill:#fef9c3,stroke:#eab308,color:#b45309;</span><br><span class="line">    classDef stream fill:#e0e7ff,stroke:#6366f1,color:#312e81;</span><br><span class="line">    classDef compare fill:#f3f4f6,stroke:#a3a3a3,color:#111827,stroke-dasharray:5 3;</span><br><span class="line">    </span><br><span class="line">    %% HTTP/1.1</span><br><span class="line">    subgraph HTTP1[&quot;🌐 HTTP/1.1 (多连接, 队头阻塞)&quot;]</span><br><span class="line">        direction LR</span><br><span class="line">        TCP1(&quot;🔗 TCP连接1&quot;):::http1 --&gt; R1(&quot;📄 请求1&quot;):::req --&gt; R2(&quot;📄 请求2&quot;):::req</span><br><span class="line">        TCP2(&quot;🔗 TCP连接2&quot;):::http1 --&gt; R3(&quot;📄 请求3&quot;):::req --&gt; R4(&quot;📄 请求4&quot;):::req</span><br><span class="line">        TCP3(&quot;🔗 TCP连接3&quot;):::http1 --&gt; R5(&quot;📄 请求5&quot;):::req --&gt; R6(&quot;📄 请求6&quot;):::req</span><br><span class="line">        classDef HTTP1 fill:#fee2e2,stroke:#ef4444,stroke-width:2px;</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    %% HTTP/2</span><br><span class="line">    subgraph HTTP2[&quot;🚀 HTTP/2 (单连接, 多路复用)&quot;]</span><br><span class="line">        direction LR</span><br><span class="line">        subgraph &quot;🔗 一个TCP连接&quot;</span><br><span class="line">            direction TB</span><br><span class="line">            S1(&quot;🔀 流1: 请求HTML&quot;):::stream</span><br><span class="line">            S2(&quot;🔀 流2: 请求CSS&quot;):::stream</span><br><span class="line">            S3(&quot;🔀 流3: 请求JS&quot;):::stream</span><br><span class="line">            S4(&quot;🔀 流4: 请求Img1&quot;):::stream</span><br><span class="line">            S1 &lt;--&gt; S2</span><br><span class="line">            S2 &lt;--&gt; S3</span><br><span class="line">            S3 &lt;--&gt; S4</span><br><span class="line">        end</span><br><span class="line">        classDef HTTP2 fill:#d1fae5,stroke:#10b981,stroke-width:2px;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    HTTP1 -- &quot;🆚对比&quot; compare --&gt; HTTP2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>“无状态”是HTTP协议最根本的设计哲学之一。理解它，是理解为何需要Cookie、Session、Token等会话管理技术的起点。这是架构设计和面试中的高频话题。</p><p>在现代的分布式、微服务架构和云原生环境下，服务的“无状态性”变得前所未有的重要。因为一个无状态的服务可以被轻易地水平扩展（简单地增加服务器实例），也可以被负载均衡器自由地调度到任何一台机器上，而无需担心会话数据丢失。<strong>将“无状态”与“可伸缩性(Scalability)”强关联，是现代架构师的必备思维。</strong></p><ul><li><strong>Cookie-Session 时代：</strong> Cookie只在客户端存储一个无意义的session_id，所有用户的具体状态数据（如购物车、登录信息）都保存在<strong>服务器端的内存或数据库</strong>中。</li><li><strong>Token-Based (JWT) 时代：</strong> 为了让后端服务也“无状态”，我们不再在服务器端存储会话数据。取而代之的是，服务器在用户认证成功后，生成一个加密的、包含用户信息的<strong>Token (如JWT)</strong>，并将其发送给客户端。客户端在后续请求中携带这个Token，服务器只需验证Token的合法性即可，无需查询自己的“会话存储”。这使得后端服务可以无限水平扩展。</li></ul><p><img src="https://s2.loli.net/2025/07/11/ZjEnYaINp3Rv7bs.png" alt="http"></p><h3 id="生活案例-1"><a href="#生活案例-1" class="headerlink" title="生活案例"></a>生活案例</h3><ul><li><strong>无状态协议</strong>就像是与一个记忆力很差的<strong>自动售货机</strong>打交道。你每次投币买东西，它都会给你对应的商品，但它完全不记得你之前买过什么。如果你想连续买两瓶可乐，你必须完整地做两次“投币-按按钮”的操作。</li><li><strong>有状态协议</strong>则像是你和一个熟悉的<strong>酒吧老板</strong>打交道。你第一次去说：“我是张三，以后我的酒都记在账上。” 老板记住了。之后你每次去，只需要说：“老样子，来一杯。” 他就知道该给你什么，并记在你的账上。</li></ul><h3 id="真实案例-1"><a href="#真实案例-1" class="headerlink" title="真实案例"></a>真实案例</h3><p>考虑一个大型电商的“购物车”功能。</p><ul><li><strong>早期设计（有状态）：</strong> 每个用户的购物车内容都存在Web服务器的内存（Session）里。当用户量巨大时，服务器内存会成为瓶颈。如果该服务器宕机，用户的购物车数据就全部丢失了。而且，负载均衡器必须使用“粘性会话”（Sticky Session），把同一个用户的请求始终转发到同一台服务器，这降低了负载均衡的灵活性。</li><li><strong>现代设计（无状态）：</strong> 用户在<strong>未登录</strong>时，购物车信息被加密存储在<strong>客户端的Cookie或LocalStorage</strong>里。用户<strong>登录</strong>后，购物车信息被同步到<strong>服务端的分布式缓存（如Redis）或数据库</strong>中。Web服务器本身不存储任何购物车状态，每次请求过来，它都根据请求中的用户信息（可能是session_id或JWT）去后端存储中查询购物车数据。这样的服务器可以无限水平扩展。</li></ul><h3 id="经典问题-1"><a href="#经典问题-1" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>面试题: 既然HTTP是无状态的，那我们是如何实现用户登录状态的保持的？请比较一下基于Session和基于JWT的两种主要方案。</p></blockquote><p>是的，HTTP的无状态性意味着服务器本身不记录客户端的状态，这就需要我们引入额外的机制来管理会话，其中最主流的就是基于Session和基于Token（特别是JWT）的方案。</p><p><strong>1. 基于Cookie-Session的方案（传统方案）：</strong><br>* <strong>流程：</strong> 客户端首次登录成功后，服务器会创建一个Session对象，里面存储着用户的状态信息（如用户ID、角色等），并为这个Session生成一个唯一的session_id。然后，服务器通过Set-Cookie响应头将这个session_id返回给客户端。客户端浏览器会自动保存这个Cookie。在后续的每次请求中，浏览器都会自动带上这个session_id。服务器收到请求后，通过session_id找到对应的Session，从而识别出用户身份。<br>* <strong>优点：</strong> 状态数据存储在服务端，相对安全；客户端Cookie中只存储无意义的ID，数据量小。<br>* <strong>缺点：</strong> <strong>服务器有状态，不易扩展</strong>。在分布式环境下，需要解决Session共享问题，比如使用粘性会话、Session复制或集中的Session存储（如Redis），这增加了架构复杂性。</p><p><strong>2. 基于JWT（JSON Web Token）的方案（现代主流）：</strong><br>* <strong>流程：</strong> 客户端登录成功后，服务器不再创建Session。而是将用户的核心信息（如用户ID、角色、过期时间）编码成一个JWT字符串。这个JWT本身包含了签名，可以防止被篡改。服务器将这个JWT直接返回给客户端。客户端通常将其存储在LocalStorage或HttpOnly Cookie中。在后续请求中，客户端通过HTTP的Authorization头（通常是Bearer <token>）将JWT发送给服务器。<br>* <strong>优点：</strong> <strong>服务器完全无状态</strong>。服务器无需存储任何会话信息，只需验证JWT签名的有效性即可。这使得后端服务可以非常容易地进行水平扩展。天然地避免了CSRF攻击（如果存储在LocalStorage中）。<br>* <strong>缺点：</strong> Token本身可能较大；一旦签发，在过期前难以强制吊销；由于信息存在客户端，不适合存放敏感数据。</p><p><strong>总结对比：</strong> Session方案将状态的包袱留给了服务端，而JWT方案则将状态（以加密Token的形式）“甩”给了客户端。在当今追求<strong>高可伸缩性、跨域通信和微服务</strong>的架构下，JWT这种<strong>服务端无状态</strong>的方案已成为事实上的主流选择。</p><h3 id="补充知识-1"><a href="#补充知识-1" class="headerlink" title="补充知识"></a>补充知识</h3><h4 id="请求与线程的关系"><a href="#请求与线程的关系" class="headerlink" title="请求与线程的关系"></a>请求与线程的关系</h4><p><img src="https://s2.loli.net/2025/07/11/irIwBycGYnHtV6g.png" alt="req"></p><p><strong>一个HTTP请求通常会由一个后台线程来处理，但这只是最终呈现的结果。前端请求与后台线程的真正关系，取决于Web服务器的I&#x2F;O模型和并发模型。</strong></p><p>这个关系取决于服务器的并发模型。</p><ol><li>在传统的<strong>阻塞I&#x2F;O模型</strong>下，可以近似地认为<strong>一个请求独占一个线程</strong>。这种模式简单直观，但由于线程开销巨大，无法支持高并发。</li><li>在现代高性能服务器普遍采用的<strong>非阻塞I&#x2F;O（或异步I&#x2F;O）模型</strong>下，这种关系被解耦了。前端的大量请求首先由<strong>少数几个I&#x2F;O线程</strong>来接收和分发，这些I&#x2F;O线程利用事件循环机制，可以高效地管理成千上万的并发连接。而请求中真正的<strong>业务逻辑处理</strong>，则被封装成任务，交由一个<strong>数量固定的后台工作线程池</strong>来执行。</li></ol><p>因此，前端的请求和后台的多线程是<strong>多对多</strong>的关系，但中间通过一个高效的<strong>I&#x2F;O事件分发层</strong>进行了调度。我们Java后台开发中讨论的‘线程共享’，通常指的是工作线程池中的线程共享数据库连接池、缓存等公共资源。而我们说‘这个请求很耗时’，通常是指它在工作线程中执行业务逻辑（比如一个复杂的数据库查询）花费了很长时间，但这并不会阻塞I&#x2F;O线程接收其他新的请求。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie是一种允许服务器在客户端（浏览器）上存储少量文本信息的机制。其核心流程是：</p><ol><li>服务器通过在HTTP响应报文中添加Set-Cookie头部，将信息“种”到客户端。</li><li>客户端收到后，会将这些信息存储起来。</li><li>当客户端再次向<strong>同一个服务器</strong>发起请求时，会自动在HTTP请求报文中添加Cookie头部，将之前存储的信息回传给服务器。</li></ol><p><strong>HttpOnly属性：</strong></p><ul><li><strong>作用：</strong> 这是最重要的安全属性。设置了HttpOnly的Cookie，将<strong>无法通过JavaScript的document.cookie API进行读写</strong>。</li><li><strong>解决的问题：</strong> 有效地防御了绝大部分的<strong>跨站脚本攻击（XSS）</strong>。黑客即使在你的页面注入了恶意脚本，也无法窃取到这个Cookie，从而无法轻易地劫持你的会话。</li><li><strong>业界标准：</strong> 所有承载敏感信息（如session_id, token）的Cookie，<strong>必须</strong>设置为HttpOnly。</li></ul><p><strong>Secure属性：</strong></p><ul><li><strong>作用：</strong> 设置了Secure的Cookie，只有在<strong>HTTPS</strong>连接中才会被发送。在HTTP连接中，浏览器会忽略这个Cookie，不会发送它。</li><li><strong>解决的问题：</strong> 防止Cookie在不安全的HTTP连接中被中间人嗅探和窃取。</li><li><strong>业界标准：</strong> 所有承载敏感信息的Cookie，<strong>必须</strong>设置为Secure。</li></ul><p><strong>SameSite属性：</strong></p><ul><li><strong>作用：</strong> 这是防御**跨站请求伪造（CSRF）**攻击的利器。它定义了浏览器在**跨站请求**时是否应发送Cookie。</li><li><strong>它有三个值：</strong><ul><li>Strict: 最严格。任何跨站请求（比如从A网站点击链接到B网站），都不会携带B网站的Cookie。</li><li>Lax: (目前多数浏览器的默认值) 在一些安全的顶层导航（如点击链接、GET表单）时允许发送Cookie，但在POST请求、img、iframe等加载中则会禁止。</li><li>None: 任何跨站请求都会发送Cookie。但<strong>必须同时设置Secure属性</strong>，否则无效。常用于需要跨域认证的API场景。</li></ul></li><li><strong>解决的问题：</strong> CSRF攻击的核心是利用了用户在A网站的操作，会<strong>自动携带</strong>B网站的Cookie去请求B网站。SameSite属性正是打破了这个“自动携带”的链条。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%%&#123;init: &#123; &quot;themeVariables&quot;: &#123; &quot;sequenceNumberColor&quot;: &quot;#546E7A&quot;, &quot;actorBorder&quot;: &quot;#78909C&quot;, &quot;actorBkg&quot;: &quot;#E3F2FD&quot;, &quot;actorTextColor&quot;: &quot;#1E88E5&quot;, &quot;noteBkgColor&quot;: &quot;#fffde7&quot;, &quot;noteBorderColor&quot;: &quot;#FFD600&quot; &#125;, &quot;theme&quot;: &quot;neo&quot; &#125; &#125;%%</span><br><span class="line">sequenceDiagram</span><br><span class="line">    participant Client as 浏览器</span><br><span class="line">    participant Server as 服务器</span><br><span class="line"></span><br><span class="line">    Client-&gt;&gt;Server: 1. 登录请求 (POST /login) user: a, pass: b</span><br><span class="line">    Note over Server: 验证成功，创建会话</span><br><span class="line">    Server--&gt;&gt;Client: 2. 响应: Set-Cookie: session_id=xyz123 HttpOnly Secure SameSite=Strict</span><br><span class="line">    Note over Client: 浏览器存储了安全 Cookie</span><br><span class="line"></span><br><span class="line">    Client-&gt;&gt;Server: 3. 后续请求 (GET /my/orders) Cookie: session_id=xyz123</span><br><span class="line">    Note over Server: session_id 识别用户，返回数据</span><br><span class="line">    Server--&gt;&gt;Client: 4. 响应: [订单数据]</span><br><span class="line"></span><br><span class="line">    Note over Client: 用户点击了恶意网站链接…</span><br><span class="line">    participant AttackerSite as 恶意网站</span><br><span class="line">    Client-&gt;&gt;AttackerSite: 访问恶意网站</span><br><span class="line">    AttackerSite--&gt;&gt;Client: 页面包含 &lt;img src=&quot;https://server.com/delete_account&quot;&gt;</span><br><span class="line">    Note over Client: 浏览器尝试加载图片，向服务器发起请求（CSRF攻击尝试）</span><br><span class="line">    Note over Client: 因 SameSite=Strict，浏览器拒绝在此跨站请求中发送 Cookie！</span><br><span class="line">    Client-xServer: 请求被发送（但不带 Cookie）</span><br><span class="line">    Note over Server: 服务器因收不到 Cookie，认证失败，CSRF防御成功！</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生活案例-2"><a href="#生活案例-2" class="headerlink" title="生活案例"></a>生活案例</h3><p><strong>Cookie</strong>就像是游乐场的<strong>腕带</strong>。</p><ul><li>你买票入场时（<strong>登录</strong>），工作人员（<strong>服务器</strong>）给你戴上一个腕带（<strong>Set-Cookie</strong>），上面有个独一无二的条形码（<strong>session_id</strong>）。</li><li><strong>HttpOnly</strong>属性就像这个腕带是<strong>一次性锁死</strong>的，你自己用手摘不下来（JS无法读取），只能由专门的机器（浏览器协议）来识别。</li><li><strong>Secure</strong>属性意味着只有在游乐场<strong>官方通道</strong>（HTTPS）才能扫描这个腕带，你在外面的小卖部（HTTP）用不了。</li><li><strong>SameSite&#x3D;Strict</strong>属性就像是规定，这个腕带<strong>只能在游乐场内部</strong>使用。如果你跑到隔壁的商场，想用这个腕带打折，商场的扫描仪（其他网站）会拒绝识别。</li></ul><h3 id="真实案例-2"><a href="#真实案例-2" class="headerlink" title="真实案例"></a>真实案例</h3><p><strong>场景：</strong> 设计一个银行网站的“记住我”功能。</p><ul><li><strong>错误实践：</strong> 将用户的明文用户名和密码保存在普通Cookie中。这是极度危险的，一旦被XSS攻击，用户的凭证将立刻泄露。</li><li><strong>正确实践：</strong><ol><li>用户登录时，如果勾选了“记住我”，服务器会生成一个<strong>长期的、高熵的、随机的令牌（Token）</strong>。</li><li>服务器在数据库中存储这个令牌，并关联到该用户，同时设置一个较长的过期时间（比如30天）。</li><li>服务器通过Set-Cookie将这个令牌返回给客户端，并<strong>必须</strong>设置以下属性：token&#x3D;abc…xyz; Expires&#x3D;…; HttpOnly; Secure; SameSite&#x3D;Lax。</li><li>用户下次访问时，浏览器会自动携带这个令牌Cookie。服务器端的“自动登录”过滤器会检查这个令牌，在数据库中验证其有效性。如果有效，则为用户自动创建一次性的登录会话，实现“记住我”功能。</li></ol></li></ul><h3 id="经典问题-2"><a href="#经典问题-2" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>HttpOnly和SameSite这两个Cookie属性分别是为了解决什么安全问题的？请具体说明。</p></blockquote><p>这两个属性是现代Web安全中用于加固Cookie、防御两大核心攻击的关键手段。</p><ol><li><strong>HttpOnly 主要防御的是跨站脚本攻击（XSS）。</strong> XSS攻击的核心是攻击者在网页中注入了恶意的JavaScript脚本。在没有HttpOnly的情况下，这个脚本可以通过document.cookie窃取到用户的会话Cookie（比如session_id），然后发送到攻击者的服务器，攻击者就可以利用这个Cookie伪装成用户进行操作，这就是“会话劫持”。而设置了HttpOnly属性后，JavaScript就无法再访问这个Cookie，从根本上切断了XSS攻击窃取会话Cookie的路径，极大地提升了安全性。</li><li><strong>SameSite 主要防御的是跨站请求伪造（CSRF）。</strong> CSRF攻击的核心是利用了浏览器在发送跨站请求时会自动携带目标站点Cookie的特性。攻击者会诱导已登录的用户（比如银行网站的用户）去点击一个恶意链接，这个链接会向银行服务器发起一个转账请求。由于浏览器会自动带上银行的Cookie，银行服务器会误以为这是用户的真实操作，从而导致资金被盗。SameSite属性通过限制跨站请求发送Cookie来防御这种攻击。SameSite&#x3D;Strict最为严格，几乎禁止所有跨站Cookie发送；而Lax模式则是一种平衡，它允许在用户主动导航（如点击链接）这种风险较低的场景下发送Cookie，但在高风险的场景（如POST请求或通过<img>、<iframe>发起的请求）下则会阻止，这已经能防御绝大多数CSRF攻击了。</li></ol><p><strong>总结来说，HttpOnly保护Cookie不被“内鬼”（页面内的JS）偷走，而SameSite保护Cookie不被“外人”（其他网站）利用。</strong> 在实际开发中，对敏感Cookie同时设置这两个属性，是构建安全防线的标准操作。</p><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    autonumber</span><br><span class="line"></span><br><span class="line">    participant C1 as Client 1</span><br><span class="line">    participant S1 as Server 1</span><br><span class="line">    participant C2 as Client 2</span><br><span class="line">    participant S2 as Server 2</span><br><span class="line">    participant C3 as Client 3</span><br><span class="line">    participant S3 as Server 3</span><br><span class="line"></span><br><span class="line">    rect rgba(240,248,255,0.4)</span><br><span class="line">    Note over C1,S1: HTTP/1.0 短连接（3个资源）</span><br><span class="line">        C1-&gt;&gt;S1: TCP Handshake</span><br><span class="line">        C1-&gt;&gt;S1: Request 1 (HTML)</span><br><span class="line">        S1--&gt;&gt;C1: Response 1</span><br><span class="line">        C1--&gt;&gt;S1: TCP Teardown</span><br><span class="line"></span><br><span class="line">        C1-&gt;&gt;S1: TCP Handshake</span><br><span class="line">        C1-&gt;&gt;S1: Request 2 (CSS)</span><br><span class="line">        S1--&gt;&gt;C1: Response 2</span><br><span class="line">        C1--&gt;&gt;S1: TCP Teardown</span><br><span class="line"></span><br><span class="line">        C1-&gt;&gt;S1: TCP Handshake</span><br><span class="line">        C1-&gt;&gt;S1: Request 3 (JS)</span><br><span class="line">        S1--&gt;&gt;C1: Response 3</span><br><span class="line">        C1--&gt;&gt;S1: TCP Teardown</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    rect rgba(224,255,255,0.4)</span><br><span class="line">    Note over C2,S2: HTTP/1.1 持久连接</span><br><span class="line">        C2-&gt;&gt;S2: TCP Handshake</span><br><span class="line">        C2-&gt;&gt;S2: Request 1 (HTML)</span><br><span class="line">        S2--&gt;&gt;C2: Response 1</span><br><span class="line">        C2-&gt;&gt;S2: Request 2 (CSS)</span><br><span class="line">        S2--&gt;&gt;C2: Response 2</span><br><span class="line">        C2-&gt;&gt;S2: Request 3 (JS)</span><br><span class="line">        S2--&gt;&gt;C2: Response 3</span><br><span class="line">        Note over C2,S2: Reuse 连接，响应完再发下一个请求</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    rect rgba(255,240,245,0.4)</span><br><span class="line">    Note over C3,S3: HTTP/1.1 管线化（理论）</span><br><span class="line">        C3-&gt;&gt;S3: TCP Handshake</span><br><span class="line">        C3-&gt;&gt;S3: Request 1 (HTML)</span><br><span class="line">        C3-&gt;&gt;S3: Request 2 (CSS)</span><br><span class="line">        C3-&gt;&gt;S3: Request 3 (JS)</span><br><span class="line">        S3--&gt;&gt;C3: Response 1</span><br><span class="line">        S3--&gt;&gt;C3: Response 2</span><br><span class="line">        S3--&gt;&gt;C3: Response 3</span><br><span class="line">        Note over C3,S3: 请求并行发出，但响应需按顺序返回</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><h3 id="生活案例-3"><a href="#生活案例-3" class="headerlink" title="生活案例"></a>生活案例</h3><ul><li><strong>短连接</strong>就像是每次去超市买一件商品，你都要完整地经历一次“开车去 -&gt; 停车 -&gt; 进店 -&gt; 结账 -&gt; 开车回家”的流程。买三件商品，就要跑三趟。</li><li><strong>持久连接</strong>就像是你开车到超市后，把车停在停车场，然后进店里把购物车装满，最后统一结账再开车回家。你只跑了一趟，节省了大量的“开车”和“停车”时间（TCP握手和慢启动）。</li><li><strong>管线化</strong>则像是，你把购物清单一口气全扔给一个超市导购员，但他必须严格按照清单的顺序一件一件找齐了，再统一给你。如果第一件商品（比如进口奶酪）特别难找，你就要一直等到他找到为止，即使他已经路过了后面清单上的所有商品。</li></ul><h3 id="真实案例-3"><a href="#真实案例-3" class="headerlink" title="真实案例"></a>真实案例</h3><ul><li>几乎所有现代Web网站的性能都受益于持久连接。以加载一个新闻门户网站为例，主页面index.html加载完成后，浏览器需要继续加载数十个CSS文件、JS文件、logo图片、广告图片、文章缩略图等。</li><li>如果没有持久连接，每个资源的加载都需要一次独立的TCP连接建立和关闭，页面加载时间可能会从2-3秒延长到10秒以上，用户体验将是灾难性的。</li><li><strong>HTTP&#x2F;1.1的持久连接机制</strong>，配合浏览器的<strong>并行连接</strong>（通常对一个域名开6-8个持久连接），是支撑现代复杂网页快速加载的基础。</li></ul><h3 id="经典问题-3"><a href="#经典问题-3" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>HTTP&#x2F;1.1的持久连接相比于HTTP&#x2F;1.0的短连接，主要解决了什么问题？它自身又有什么局限性，而HTTP&#x2F;2又是如何解决这些局限性的？</p></blockquote><p>HTTP&#x2F;1.1的持久连接主要解决了HTTP&#x2F;1.0短连接模型的两大性能瓶颈：</p><ol><li><strong>高昂的连接建立开销：</strong> 短连接模型下，每个HTTP请求都需要经过一次TCP三次握手，这至少会产生一个RTT的延迟。对于包含大量小资源的页面，这些握手延迟累加起来非常可观。持久连接通过复用同一个TCP连接，完全避免了后续请求的握手开销。</li><li><strong>TCP慢启动的性能影响：</strong> 每个新的TCP连接都会经历一个“慢启动”过程，即连接的传输速度会从一个较低的值开始，慢慢提升。对于小文件频繁的Web请求，连接很可能在速度还没达到峰值时就被关闭了，导致TCP的性能优势无法发挥。持久连接由于长时间保持，可以使得连接“预热”，始终工作在较高的传输速率下。</li></ol><p><strong>然而，HTTP&#x2F;1.1的持久连接自身也存在一个核心局限性，那就是队头阻塞（Head-of-Line Blocking）：</strong></p><ul><li>在一个TCP连接上，虽然可以发送多个请求，但响应必须按请求的顺序串行返回。如果第一个请求的服务器处理时间很长，它就会阻塞后面所有请求的响应，即使后面的响应早已准备就绪。虽然管线化（Pipelining）技术试图解决这个问题，但由于其自身的复杂性和兼容性问题，并未被广泛采用。</li></ul><p><strong>HTTP&#x2F;2则通过引入“多路复用”（Multiplexing）机制，完美地解决了队头阻塞问题：</strong></p><ul><li>HTTP&#x2F;2允许在<strong>单个TCP连接</strong>上，将多个请求&#x2F;响应分割成更小的、独立的<strong>帧（Frame）</strong>，并将它们交错地发送和接收。每个帧都带有自己的流标识符（Stream ID），所以接收端可以根据ID将它们重新组装成完整的请求或响应。这样，一个慢请求的响应就不会再阻塞其他快速的响应，真正实现了并行传输。</li></ul><h2 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    subgraph &quot;HTTP/1.1 报文 (纯文本)&quot;</span><br><span class="line">        direction TB</span><br><span class="line">        A[&quot;&lt;b&gt;请求行:&lt;/b&gt; GET /index.html HTTP/1.1\r\n&quot;]:::request</span><br><span class="line">        B[&quot;&lt;b&gt;首部:&lt;/b&gt; Host: example.com\r\nUser-Agent: ...\r\n&quot;]:::headers</span><br><span class="line">        C[&quot;&lt;b&gt;空行:&lt;/b&gt; \r\n&quot;]:::emptyline</span><br><span class="line">        D[&quot;&lt;b&gt;(无主体)&lt;/b&gt;&quot;]:::noBody</span><br><span class="line">        A --&gt; B --&gt; C --&gt; D</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph &quot;HTTP/2 报文 (二进制帧流)&quot;</span><br><span class="line">        direction LR</span><br><span class="line">        H1[HEADERS Frame&lt;br&gt;包含:method, path, host等&lt;br&gt;&lt;b&gt;经过HPACK压缩&lt;/b&gt;]:::headers2 --&gt; D1[DATA Frame&lt;br&gt;可选的主体数据]:::data</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    classDef request fill:#f9f,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef headers fill:#ccf,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef emptyline fill:#fff,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef noBody fill:#fdd,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef headers2 fill:#ddf,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef data fill:#cfc,stroke:#333,stroke-width:2px;</span><br><span class="line">    class A,B,C,D,H1,D1 fill:#fff,stroke:#ddd,stroke-width:1px;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生活案例-4"><a href="#生活案例-4" class="headerlink" title="生活案例"></a>生活案例</h3><ul><li><strong>HTTP&#x2F;1.1的报文</strong>就像一封传统的<strong>信件</strong>。有信封上的地址和收件人（<strong>起始行</strong>），有信头写的日期和主题（<strong>首部</strong>），还有信纸上的正文内容（<strong>主体</strong>）。它们是作为一个整体寄送的。</li><li><strong>HTTP&#x2F;2的报文</strong>则像是把这封信的内容拆分成了很多张标准大小的<strong>卡片（帧）</strong>，并进行了编码。HEADERS帧就像是包含了所有收发件人信息的“地址卡”，DATA帧就像是一张张写着正文内容的“内容卡”。这些卡片可以和其他信件的卡片混在一起（<strong>多路复用</strong>）寄送，到了目的地再根据信件编号重新组装起来。</li></ul><h3 id="真实案例-4"><a href="#真实案例-4" class="headerlink" title="真实案例"></a>真实案例</h3><p>当你在Chrome开发者工具（F12）的Network面板中查看一个请求时，你看到的“Headers”和“Payload”&#x2F;“Response”标签页，就是对HTTP报文逻辑结构的完美呈现。</p><ul><li><strong>General</strong> 和 <strong>Request&#x2F;Response Headers</strong> 部分对应<strong>起始行和首部</strong>。</li><li><strong>Payload</strong>（对于POST）或 <strong>Response</strong>（对于GET）标签页的内容对应<strong>主体</strong>。</li></ul><h3 id="经典问题-4"><a href="#经典问题-4" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>HTTP&#x2F;1.1和HTTP&#x2F;2在报文结构上最核心的区别是什么？这个区别带来了什么好处？</p></blockquote><p>最核心的区别在于，<strong>HTTP&#x2F;1.1是一个文本协议，其报文结构是基于文本的，而HTTP&#x2F;2是一个二进制协议，它引入了全新的帧（Frame）层。</strong></p><p>具体来说：</p><ol><li><strong>HTTP&#x2F;1.1</strong>的报文是由可读的ASCII文本构成的，包括起始行、首部和主体，它们之间通过换行符（CRLF）分隔。这种格式对人类友好，但对机器解析效率不高，且存在安全注入的风险。</li><li><strong>HTTP&#x2F;2</strong>则将一个逻辑上的请求或响应，在传输时分解为多个二进制编码的帧。比如，所有首部信息被打包到一个HEADERS帧中，而响应主体则被放入一个或多个DATA帧中。</li></ol><p>这个从“文本”到“二进制帧”的根本转变，带来了两大革命性的好处：</p><ul><li><strong>实现了多路复用（Multiplexing）：</strong> 来自不同请求的帧可以在同一个TCP连接上交错传输，每个帧都带有流ID，从而解决了HTTP&#x2F;1.1的队头阻塞问题，极大地提高了并发传输效率。</li><li><strong>实现了头部压缩（HPACK）：</strong> 由于首部被独立成HEADERS帧，HTTP&#x2F;2可以对大量重复的头部字段（如User-Agent, Accept等）使用HPACK算法进行高效压缩，显著减少了请求的体积，这在移动网络环境下尤其重要。</li></ul><h2 id="内容编码与传输编码"><a href="#内容编码与传输编码" class="headerlink" title="内容编码与传输编码"></a>内容编码与传输编码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    subgraph &quot;服务器处理流程&quot;</span><br><span class="line">        direction TB</span><br><span class="line">        A[原始资源&lt;br&gt;&lt;b&gt;实体主体&lt;/b&gt;&lt;br&gt;例如: 10KB的HTML]:::raw</span><br><span class="line">        B[Content-Encoding: gzip&lt;br&gt;压缩后的实体主体&lt;br&gt;例如: 2KB]:::encoded</span><br><span class="line">        C[Transfer-Encoding: chunked&lt;br&gt;将压缩后的数据分块&lt;br&gt;例如: Chunk1+Chunk2...]:::chunked</span><br><span class="line">        D[通过TCP连接发送&lt;br&gt;&lt;b&gt;报文主体&lt;/b&gt;]:::transferred</span><br><span class="line">        A --&gt;|Step 1: 内容编码| B --&gt;|Step 2: 传输编码| C --&gt; D</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph &quot;编码目的&quot;</span><br><span class="line">        Content_Encoding[&quot;&lt;b&gt;内容编码 (Content-Encoding)&lt;/b&gt;&lt;br&gt;为&lt;b&gt;资源&lt;/b&gt;瘦身, 节省带宽&lt;br&gt;作用于&lt;b&gt;实体主体&lt;/b&gt;&quot;]:::purpose</span><br><span class="line">        Transfer_Encoding[&quot;&lt;b&gt;传输编码 (Transfer-Encoding)&lt;/b&gt;&lt;br&gt;为&lt;b&gt;传输&lt;/b&gt;服务, 改变报文结构&lt;br&gt;作用于&lt;b&gt;报文主体&lt;/b&gt;&quot;]:::purpose</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    style Content_Encoding fill:#cde,stroke:#333,stroke-width:2px</span><br><span class="line">    style Transfer_Encoding fill:#fce,stroke:#333,stroke-width:2px</span><br><span class="line">    classDef raw fill:#f9f,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef encoded fill:#ccf,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef chunked fill:#cfc,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef transferred fill:#fdd,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef purpose fill:#fff,stroke:#333,stroke-width:2px;</span><br><span class="line"></span><br><span class="line">    class A,B,C,D Content_Encoding,Transfer_Encoding;</span><br></pre></td></tr></table></figure><h3 id="生活案例-5"><a href="#生活案例-5" class="headerlink" title="生活案例"></a>生活案例</h3><p>想象你要寄送一个大型的<strong>乐高模型（原始资源）</strong>。</p><ul><li><strong>内容编码 (gzip&#x2F;Brotli)</strong>：你发现直接寄送盒子太大、运费太贵。于是你把乐高模型<strong>拆散成一个个零件</strong>，并用<strong>真空压缩袋</strong>把它们打包起来。这样体积就大大减小了。这个“真空压缩”的过程，就是<strong>内容编码</strong>，它改变了“内容”本身（从组装好的模型变成了零件袋），目的是让它变得更小。</li><li><strong>传输编码 (chunked)</strong>：现在你有一包压缩好的零件，但你没有一个足够大的箱子一次装下。于是你决定<strong>分批寄送</strong>。你找了几个小盒子，在第一个盒子上写“第1箱，共3箱”，在第二个盒子上写“第2箱，共3箱”… 这就是<strong>分块传输编码</strong>。它没有改变盒子里的内容（零件还是那些零件），而是改变了“寄送的方式”（从一个大包裹变成几个小包裹）。</li></ul><h3 id="真实案例-5"><a href="#真实案例-5" class="headerlink" title="真实案例"></a>真实案例</h3><ul><li><strong>内容编码 (gzip&#x2F;Brotli)：</strong> 你打开任何一个现代网站，查看其HTML、CSS、JS文件的网络请求，你都会在响应头中看到Content-Encoding: gzip或Content-Encoding: br。这表明服务器对这些文本资源进行了压缩，你的浏览器在接收到后会自动解压。这是前端性能优化的标准操作。</li><li><strong>传输编码 (chunked)：</strong> 当你访问一个需要大量后台计算的报表页面时，比如“生成过去一年的销售报告”。服务器可能不会等所有数据都计算完毕（可能需要几十秒），而是采用<strong>流式处理</strong>：每计算出一部分数据，就立刻通过<strong>分块传输</strong>将这部分数据发送给浏览器。这样，用户很快就能看到页面的头部和第一部分数据，而不是面对一个长时间的白屏等待。你在开发者工具中会看到响应头里有Transfer-Encoding: chunked，并且看不到Content-Length头。</li></ul><h3 id="经典问题-5"><a href="#经典问题-5" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>Content-Encoding和Transfer-Encoding这两个HTTP头部有什么区别？</p></blockquote><p>Content-Encoding和Transfer-Encoding虽然都涉及“编码”，但它们是HTTP中两个完全不同层面、用于解决不同问题的机制。</p><ol><li><strong>目的不同：</strong><ul><li>Content-Encoding（内容编码）的目的是<strong>压缩实体主体</strong>，减少传输数据的大小，从而节省带宽、加快传输速度。常见的编码有gzip, deflate, br。它作用的对象是<strong>资源本身</strong>。</li><li>Transfer-Encoding（传输编码）的目的是<strong>改变报文的传输方式</strong>，以利于网络传输。目前唯一的标准值是chunked（分块传输）。它解决的是服务器无法在传输前确定整个响应体大小的问题（比如动态生成的内容），使得服务器可以流式地发送数据。它作用的对象是<strong>整个报文</strong>的结构。</li></ul></li><li><strong>作用位置不同：</strong><ul><li>内容编码是在<strong>服务器生成响应后，发送给客户端前</strong>对实体主体进行的“端到端”编码。客户端接收后需要先解码，才能得到原始的实体内容。</li><li>传输编码是<strong>逐跳</strong>的，它只在相邻的两个节点间有效。一个代理接收到chunked编码的报文后，必须先解码（将分块数据合并），然后再决定是否以chunked或其他方式转发给下一个节点。</li></ul></li><li><strong>与Content-Length的关系：</strong><ul><li>当使用Content-Encoding时，Content-Length头部的值是**编码后（压缩后）**的实体主体大小。</li><li>当使用Transfer-Encoding: chunked时，<strong>必须不能</strong>出现Content-Length头部，因为内容的长度是未知的，由最后一个大小为0的块来表示结束。</li></ul></li></ol><p><strong>总结来说，Content-Encoding是给“货物”做真空包装，而Transfer-Encoding是改变“送货”的方式。</strong></p><h2 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    subgraph &quot;服务器上的完整资源 (比如一个10MB的视频文件)&quot;</span><br><span class="line">        A[0MB] --&gt; B[2MB] --&gt; C[4MB] --&gt; D[6MB] --&gt; E[8MB] --&gt; F[10MB]</span><br><span class="line">        style A fill:#eee,stroke:#333</span><br><span class="line">        style B fill:#eee,stroke:#333</span><br><span class="line">        style C fill:#eee,stroke:#333</span><br><span class="line">        style D fill:#eee,stroke:#333</span><br><span class="line">        style E fill:#eee,stroke:#333</span><br><span class="line">        style F fill:#eee,stroke:#333</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph &quot;客户端的操作与请求&quot;</span><br><span class="line">        direction LR</span><br><span class="line">        P1[&quot;1. 正常播放&lt;br&gt;请求 Range: bytes=0-1999999&quot;] --&gt;|获取前2MB| S1[服务器]</span><br><span class="line">        P2[&quot;2. 拖动进度条到中段&lt;br&gt;请求 Range: bytes=4000000-5999999&quot;] --&gt;|只获取4-6MB| S1</span><br><span class="line">        P3[&quot;3. 多线程下载&lt;br&gt;T1: Range: 0-4999999&lt;br&gt;T2: Range: 5000000-&quot;] --&gt;|同时请求两部分| S1</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    S1 -- &quot;响应: 206 Partial Content&lt;br&gt;Content-Range: bytes 0-1999999/10000000&quot; --&gt; P1</span><br><span class="line">    S1 -- &quot;响应: 206 Partial Content&lt;br&gt;Content-Range: bytes 4000000-5999999/10000000&quot; --&gt; P2</span><br><span class="line">    S1 -- &quot;响应: 206 Partial Content (给T1)&lt;br&gt;响应: 206 Partial Content (给T2)&quot; --&gt; P3</span><br><span class="line"></span><br><span class="line">    style P1 fill:#ccf,stroke:#333,stroke-width:2px;</span><br><span class="line">    style P2 fill:#ccf,stroke:#333,stroke-width:2px;</span><br><span class="line">    style P3 fill:#ccf,stroke:#333,stroke-width:2px;</span><br><span class="line">    style S1 fill:#ddf,stroke:#333,stroke-width:2px;</span><br><span class="line">    class P1,P2,P3,S1 fill:#fff,stroke:#ddd,stroke-width:1px;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><strong>多线程下载器的工作原理：</strong> 现代的下载工具（如迅雷、IDM）和一些浏览器插件，正是利用了范围请求的**多部分请求（Multipart Ranges）**能力来加速下载。它们会同时对一个资源发起多个范围请求，每个请求下载文件的一部分，最后在本地将这些部分拼接起来。</li><li><strong>视频流媒体的“拖动”播放：</strong> 当你在B站或YouTube上观看视频并拖动进度条时，你实际上触发了一个新的范围请求。播放器会计算出你想看的时间点对应于整个视频文件（比如一个mp4文件）的哪个字节范围，然后向服务器发起一个Range请求，只获取那一小段数据，从而实现快速的“空降”播放，而无需下载整个文件。</li><li><strong>大文件上传的断点续传：</strong> 虽然范围请求主要用于下载，但其理念也被应用于上传。客户端可以先向服务器查询已上传了多少字节，然后通过类似Content-Range的机制（通常是自定义头部）从断点处继续上传剩余部分。</li></ol><h3 id="生活案例-6"><a href="#生活案例-6" class="headerlink" title="生活案例"></a>生活案例</h3><p>想象你在读一本非常厚的<strong>电子书（资源）</strong>。</p><ul><li><strong>没有范围请求：</strong> 你每次打开书，都必须从第一页开始下载整本书，即使你只想看第500页。</li><li><strong>有范围请求：</strong> 你可以直接告诉服务器：“我只想看第500页到第510页的内容”（Range: pages&#x3D;500-510，如果是字节就是bytes&#x3D;…）。服务器就只把这10页的内容发给你，非常高效。这就是<strong>断点续传和跳转阅读</strong>的原理。</li></ul><h3 id="真实案例-6"><a href="#真实案例-6" class="headerlink" title="真实案例"></a>真实案例</h3><p>除了上面提到的视频播放和下载工具，<strong>云存储服务</strong>（如阿里云OSS、AWS S3）的API也大量使用了范围请求。当你需要从云端下载一个几GB大的备份文件时，它们的SDK（软件开发工具包）在底层就是利用范围请求，将文件分块下载，并支持在网络中断后从失败的块开始续传，大大提升了大文件操作的稳定性和效率。</p><h3 id="经典问题-6"><a href="#经典问题-6" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>HTTP的206状态码是什么含义？它通常与哪两个头部字段一起工作来实现什么功能？</p></blockquote><p>206 Partial Content是HTTP中一个表示<strong>部分内容</strong>的成功状态码。它表明服务器成功处理了客户端的<strong>范围请求（Range Request）</strong>，并且响应体中只包含了资源的一部分，而不是全部。</p><p>它通常与以下两个核心的头部字段协同工作：</p><ol><li><strong>请求头：Range</strong><ul><li>由客户端发送，用于告诉服务器它想要获取资源的哪个或哪些部分。其值的单位最常见的是bytes，例如Range: bytes&#x3D;0-499表示请求资源的前500个字节。</li></ul></li><li><strong>响应头：Content-Range</strong><ul><li>由服务器在返回206响应时发送，用于告诉客户端这次返回的部分内容在整个资源中的位置。它的格式通常是bytes <start>-<end>&#x2F;<total>，例如Content-Range: bytes 0-499&#x2F;1234，表示这次发送的是第0到499字节，而整个资源的总长度是1234字节。</li></ul></li></ol><p>这套机制协同工作的核心功能是<strong>实现资源的部分获取</strong>，其最重要的两大应用场景是：</p><ul><li><strong>断点续传：</strong> 当下载大文件时，如果网络中断，客户端可以记录下已下载的字节数，然后通过Range头请求剩余的部分，服务器返回206响应，从而实现从断点继续下载。</li><li><strong>流媒体播放：</strong> 在线视频播放器通过发送带有不同字节范围的Range请求，来获取用户当前想观看或者预加载的视频片段，实现了“即点即播”和进度条拖动的功能。</li></ul><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[章4: HTTP状态码] </span><br><span class="line">    A1[1xx: 信息性]:::info</span><br><span class="line">    A2[2xx: 成功]:::success</span><br><span class="line">    A3[3xx: 重定向]:::redirect</span><br><span class="line">    A4[4xx: 客户端错误]:::clientError</span><br><span class="line">    A5[5xx: 服务器错误]:::serverError</span><br><span class="line"></span><br><span class="line">    A --&gt; A1</span><br><span class="line">    A --&gt; A2</span><br><span class="line">    A --&gt; A3</span><br><span class="line">    A --&gt; A4</span><br><span class="line">    A --&gt; A5</span><br><span class="line"></span><br><span class="line">    A1 --&gt; B1[100 Continue]</span><br><span class="line">    A2 --&gt; B2[200 OK]</span><br><span class="line">    A2 --&gt; B3[204 No Content]</span><br><span class="line">    A2 --&gt; B4[206 Partial Content]</span><br><span class="line">    A3 --&gt; B5[301 Moved Permanently - 面试重点]</span><br><span class="line">    A3 --&gt; B6[302 Found - 面试重点]</span><br><span class="line">    A3 --&gt; B7[304 Not Modified - 面试重点]</span><br><span class="line">    A3 --&gt; B8[307 Temporary Redirect]</span><br><span class="line">    A4 --&gt; B9[400 Bad Request]</span><br><span class="line">    A4 --&gt; B10[401 Unauthorized]</span><br><span class="line">    A4 --&gt; B11[403 Forbidden]</span><br><span class="line">    A4 --&gt; B12[404 Not Found]</span><br><span class="line">    A5 --&gt; B13[500 Internal Server Error]</span><br><span class="line">    A5 --&gt; B14[502 Bad Gateway]</span><br><span class="line">    A5 --&gt; B15[503 Service Unavailable]</span><br><span class="line"></span><br><span class="line">    classDef info fill:#cfe,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef success fill:#cfc,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef redirect fill:#ffb,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef clientError fill:#fcc,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef serverError fill:#fdd,stroke:#333,stroke-width:2px;</span><br><span class="line">    class A1,A2,A3,A4,A5 fill:#fff,stroke:#ddd,stroke-width:1px;</span><br><span class="line">    class B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B11,B12,B13,B14,B15 fill:#fff,stroke:#ddd,stroke-width:1px;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3xx重定向状态码"><a href="#3xx重定向状态码" class="headerlink" title="3xx重定向状态码"></a>3xx重定向状态码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant B as 浏览器/搜索引擎</span><br><span class="line">    participant S1 as 旧地址 (example.com/old)</span><br><span class="line">    participant S2 as 新地址 (example.com/new)</span><br><span class="line"></span><br><span class="line">    %% Permanent Redirect (301)</span><br><span class="line">    B-&gt;&gt;S1: GET /old</span><br><span class="line">    S1--&gt;&gt;B: 301 Moved Permanently&lt;br&gt;Location: /new</span><br><span class="line">    B-&gt;&gt;S2: GET /new</span><br><span class="line">    Note over B: 记住! 下次直接访问/new</span><br><span class="line">    B-&gt;&gt;S2: (下次) GET /new</span><br><span class="line"></span><br><span class="line">    %% Temporary Redirect (302/307)</span><br><span class="line">    B-&gt;&gt;S1: GET /old</span><br><span class="line">    S1--&gt;&gt;B: 302 Found&lt;br&gt;Location: /new</span><br><span class="line">    B-&gt;&gt;S2: GET /new</span><br><span class="line">    Note over B: 只是临时跳转, 下次还访问/old</span><br><span class="line">    B-&gt;&gt;S1: (下次) GET /old</span><br></pre></td></tr></table></figure><ul><li><strong>301 Moved Permanently (永久重定向):</strong> 表示请求的资源已被<strong>永久</strong>地移动到了新的URL。浏览器和搜索引擎在收到301后，会更新自己的书签和索引，未来会直接访问新的URL。</li><li><strong>302 Found (临时重定向):</strong> 表示请求的资源<strong>临时</strong>被移动到了新的URL。浏览器和搜索引擎不会更新记录，下次还是会访问原始的URL。</li><li><strong>304 Not Modified (未修改):</strong> 这是服务器对一个<strong>附带条件的请求</strong>（Conditional Request，通常是带有If-Modified-Since或If-None-Match头部）的回应。它告诉客户端，你本地缓存的资源还是最新的，直接用缓存吧，我这次就不给你发内容了。</li></ul><h4 id="生活案例-7"><a href="#生活案例-7" class="headerlink" title="生活案例"></a>生活案例</h4><ul><li><strong>301 永久重定向</strong>：你搬家了，你去邮局办理了<strong>地址永久迁移</strong>。从此以后，所有寄给你的信件，邮局都会<strong>直接改投到你的新家</strong>，并且会通知你的朋友们：“他搬家了，以后请直接寄到新地址。”</li><li><strong>302&#x2F;307 临时重定向</strong>：你只是去朋友家<strong>暂住几天</strong>。你告诉邮局，这几天的信件<strong>临时转寄</strong>到朋友家。邮局不会更改你的档案，你的朋友们也不知道你出门了，信件还是会先寄到你家，再由邮局转送。</li></ul><h4 id="真实案例-7"><a href="#真实案例-7" class="headerlink" title="真实案例"></a>真实案例</h4><ul><li><strong>301 永久重定向的典型应用：</strong><ul><li><strong>网站换域名：</strong> 当公司将域名从 old-brand.com 更换为 new-brand.com 时，必须在旧域名的服务器上配置对所有请求返回301，指向新域名对应的页面。这对**SEO（搜索引擎优化）**至关重要，它能告诉搜索引擎将旧域名的权重和排名**全部转移**到新域名上。</li><li><strong>URL规范化：</strong> 确保 <a href="http://example.com、http//www.example.com">http://example.com、http://www.example.com</a> 等多个入口都301重定向到唯一的、规范的URL（比如 <a href="https://www.example.com),避免搜索引擎认为这是重复内容./">https://www.example.com），避免搜索引擎认为这是重复内容。</a></li></ul></li><li><strong>302&#x2F;307 临时重定向的典型应用：</strong><ul><li><strong>未登录用户访问受限页面：</strong> 用户访问 my.example.com&#x2F;dashboard，服务器发现用户未登录，会返回一个302&#x2F;307重定向到登录页 my.example.com&#x2F;login，并在URL中附带一个参数告诉登录页登录成功后应该跳回dashboard。</li><li><strong>服务维护：</strong> 网站进行短暂维护时，可以临时将所有请求302重定向到一个静态的“维护中”页面。</li></ul></li></ul><h4 id="经典问题-7"><a href="#经典问题-7" class="headerlink" title="经典问题"></a>经典问题</h4><blockquote><p> 301和302在实际应用中，特别是对SEO，有什么本质区别？</p></blockquote><p>301和302最本质的区别在于它们向客户端和搜索引擎传递的<strong>语义</strong>完全不同，这直接影响了<strong>缓存行为和SEO权重</strong>。</p><ol><li><strong>301 (永久重定向)</strong> 告诉浏览器和搜索引擎：“这个地址<strong>永远废弃</strong>了，请以后都去访问新的地址”。因此：<ul><li><strong>浏览器行为：</strong> 浏览器会强烈地缓存这个重定向关系。在缓存有效期内，下次访问旧地址时，它可能<strong>不再向旧地址发请求</strong>，而是直接从本地缓存读取新地址并发起请求。</li><li><strong>SEO影响：</strong> 这是对SEO最友好的方式。搜索引擎会理解为网站<strong>权重和排名的永久性转移</strong>，它会把旧URL积累的“链接权重”（link juice）几乎全部传递给新的URL。</li></ul></li><li><strong>302 (临时重定向)</strong> 告诉浏览器和搜索引擎：“这个地址<strong>只是临时不在</strong>，请这次先去新地址访问，但下次还应该来访问我这个旧地址”。因此：<ul><li><strong>浏览器行为：</strong> 浏览器<strong>不会缓存</strong>这个重定向关系，每次访问旧地址时，它还是会先请求旧地址，然后再根据服务器的302响应进行跳转。</li><li><strong>SEO影响：</strong> 搜索引擎会认为旧URL依然是主体，<strong>不会将权重传递给新URL</strong>。如果长期错误地使用302进行永久性的域名或URL更换，将导致新页面的权重始终无法提升，对SEO是灾难性的。</li></ul></li></ol><p><strong>总结来说，网站改版、换域名等永久性变更必须使用301；而像登录跳转、服务临时维护等临时性跳转，则应该使用302（或者更精确的303&#x2F;307）。</strong></p><h3 id="4xx-客户端错误-5xx-服务器错误"><a href="#4xx-客户端错误-5xx-服务器错误" class="headerlink" title="4xx 客户端错误 &amp; 5xx 服务器错误"></a>4xx 客户端错误 &amp; 5xx 服务器错误</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Client as 客户端</span><br><span class="line">    participant Gateway as API网关 (Nginx)</span><br><span class="line">    participant ServiceA as 后端服务A</span><br><span class="line"></span><br><span class="line">    %% 场景一: 触发 502 Bad Gateway</span><br><span class="line">    Client -&gt;&gt; Gateway: 请求 /service-a/data</span><br><span class="line">    Gateway -&gt;&gt; ServiceA: 转发请求</span><br><span class="line">    Note over ServiceA: 服务A内部崩溃或&lt;br&gt;配置错误, 返回了&lt;br&gt;一个无效的响应/或直接断开连接</span><br><span class="line">    ServiceA --x Gateway: 返回无效响应 / 连接重置</span><br><span class="line">    Gateway --&gt;&gt; Client: &lt;b&gt;502 Bad Gateway&lt;/b&gt;</span><br><span class="line"></span><br><span class="line">    %% 场景二: 触发 504 Gateway Timeout</span><br><span class="line">    Client -&gt;&gt; Gateway: 请求 /service-a/report</span><br><span class="line">    Gateway -&gt;&gt; ServiceA: 转发请求</span><br><span class="line">    Note over ServiceA: 这是一个非常耗时的&lt;br&gt;报表计算任务</span><br><span class="line">    loop 等待响应 (例如超过30秒)</span><br><span class="line">        ServiceA -&gt;&gt; ServiceA: 仍在处理中...</span><br><span class="line">    end</span><br><span class="line">    Note over Gateway: 等待超时!</span><br><span class="line">    Gateway --&gt;&gt; Client: &lt;b&gt;504 Gateway Timeout&lt;/b&gt;</span><br><span class="line"></span><br><span class="line">    %% 场景三: 触发 401 Unauthorized</span><br><span class="line">    Client -&gt;&gt; Gateway: 请求 /service-a/secure-data</span><br><span class="line">    Gateway -&gt;&gt; ServiceA: 转发请求</span><br><span class="line">    Note over ServiceA: 服务A检查权限，&lt;br&gt;但客户端未提供有效的认证信息</span><br><span class="line">    ServiceA --x Gateway: 返回 401 Unauthorized</span><br><span class="line">    Gateway --&gt;&gt; Client: &lt;b&gt;401 Unauthorized&lt;/b&gt;</span><br><span class="line"></span><br><span class="line">    %% 场景四: 触发 403 Forbidden</span><br><span class="line">    Client -&gt;&gt; Gateway: 请求 /service-a/private-data</span><br><span class="line">    Gateway -&gt;&gt; ServiceA: 转发请求</span><br><span class="line">    Note over ServiceA: 客户端提供的认证信息&lt;br&gt;无权访问此资源</span><br><span class="line">    ServiceA --x Gateway: 返回 403 Forbidden</span><br><span class="line">    Gateway --&gt;&gt; Client: &lt;b&gt;403 Forbidden&lt;/b&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>4xx (Client Error):</strong> 表明错误是由<strong>客户端</strong>引起的。比如，客户端请求了一个不存在的URL，或者没有提供有效的认证信息。<ul><li><strong>401 (Unauthorized):</strong> <strong>“未认证”</strong>。表示当前请求需要用户认证，但客户端没有提供认证信息，或者认证信息无效（比如Token错误或过期）。它暗示客户端<strong>应该去认证</strong>（或重新认证）。</li><li><strong>403 (Forbidden):</strong> <strong>“未授权”</strong>。表示服务器已经成功识别了客户端的身份，但该用户<strong>没有权限</strong>访问这个资源。它暗示认证是没用的，换个有权限的账号来吧。例如，普通用户尝试访问管理员才能访问的后台接口。</li></ul></li><li><strong>5xx (Server Error):</strong> 表明错误发生在<strong>服务器端</strong>。服务器清楚地知道自己出了问题，无法完成一个看起来有效的请求。<ul><li><strong>502 (Bad Gateway):</strong> 通常是你的<strong>网关（如Nginx）</strong> 尝试去请求后端的<strong>上游服务（如一个Node.js应用）</strong>，但上游服务出了问题，返回了一个无效的响应，或者<strong>上游服务直接挂了，连接被拒绝</strong>。网关无法理解这个响应，于是返回502。<strong>核心是：连接已建立，但上游服务没正常工作。</strong></li><li><strong>504 (Gateway Timeout):</strong> 网关向上游服务发起了请求，但上游服务<strong>在网关设定的超时时间内，一直没有返回任何响应</strong>。网关等不及了，就返回504。<strong>核心是：上游服务活着，但处理太慢了。</strong></li></ul></li></ul><h4 id="生活案例-8"><a href="#生活案例-8" class="headerlink" title="生活案例"></a>生活案例</h4><ul><li><strong>4xx 客户端错误</strong> 就像是你去银行办业务：<ul><li><strong>400 Bad Request:</strong> 你填的表单格式不对，业务员看不懂。</li><li><strong>401 Unauthorized:</strong> 你没带身份证，业务员要求你先证明你是你。</li><li><strong>403 Forbidden:</strong> 你带了身份证，但你想查别人的账户，业务员告诉你“你没这个权限”。</li><li><strong>404 Not Found:</strong> 你要办的这个业务，银行根本就没有。</li></ul></li><li><strong>5xx 服务器错误</strong> 则是银行内部的问题：<ul><li><strong>500 Internal Server Error:</strong> 你的请求完全合规，但银行的电脑系统突然死机了。</li><li><strong>502 Bad Gateway:</strong> 你找的大堂经理（网关）去后台找柜员（上游服务）办业务，结果那个柜员给了他一张错误的单据，经理没法处理。</li><li><strong>503 Service Unavailable:</strong> 银行正在年终决算，所有窗口都暂停服务。</li><li><strong>504 Gateway Timeout:</strong> 大堂经理把你的申请交到后台了，但那个业务流程太复杂，后台一直没办完，经理等得不耐烦了，只能告诉你“超时了”。</li></ul></li></ul><h4 id="真实案例-8"><a href="#真实案例-8" class="headerlink" title="真实案例"></a>真实案例</h4><p>在一次线上问题排查中，监控系统报警大量出现502 Bad Gateway错误。</p><ol><li><strong>第一反应：</strong> 这不是客户端的问题，也不是网关本身的问题，而是<strong>网关后面的上游服务出了问题</strong>。</li><li><strong>排查路径：</strong> 登录到API网关（Nginx）服务器，查看错误日志（error.log）。</li><li><strong>发现日志：</strong> 日志中大量出现类似 (111: Connection refused) while connecting to upstream, client: … 的错误。</li><li><strong>定位问题：</strong> Connection refused（连接被拒绝）是一个非常明确的信号，它表明网关尝试去连接上游服务的IP和端口时，上游服务<strong>进程已经不存在或者端口没有被监听</strong>。</li><li><strong>解决问题：</strong> 登录到上游服务所在的服务器，发现对应的应用进程确实已经崩溃。重启服务后，问题解决。</li></ol><h4 id="经典问题-8"><a href="#经典问题-8" class="headerlink" title="经典问题"></a>经典问题</h4><blockquote><p>用户反馈网站打不开，你作为后端开发，会如何排查？如果抓包发现返回了502，这通常意味着什么？</p></blockquote><p>网站打不开的原因有很多，我会从客户端到服务器逐层排查。但如果明确返回了502状态码，那么排查的焦点就可以非常集中。</p><p>502 Bad Gateway是一个服务器端的错误码，但它特指作为<strong>网关或代理</strong>的服务器，在尝试访问上游服务器时，收到了一个<strong>无效的响应</strong>。在现代微服务架构中，这通常是API网关（比如Nginx）返回的。</p><p>收到502，我基本可以断定：</p><ol><li><strong>客户端到网关的网络是通的</strong>。</li><li><strong>网关本身是正常工作的</strong>。</li><li><strong>问题出在网关与某个上游后端服务之间的通信上</strong>。</li></ol><p>我会立刻采取以下排查步骤：</p><ol><li><strong>定位上游服务：</strong> 首先，我会根据用户访问的URL路径，去Nginx的配置文件中查找这个请求被proxy_pass到了哪个具体的上游服务（upstream）。</li><li><strong>查看网关日志：</strong> 登录Nginx服务器，查看error.log。502错误通常伴随着具体的错误原因，最常见的有：<ul><li>connect() failed (111: Connection refused)：这说明上游服务进程挂了，或者防火墙阻止了连接。我会立刻去检查上游服务的健康状态。</li><li>upstream prematurely closed connection：这说明连接建立了，但上游服务在返回完整响应前就提前关闭了连接，很可能是上游服务代码内部发生了崩溃。</li><li>upstream sent invalid header：上游服务返回的HTTP响应头不规范，Nginx无法解析。</li></ul></li><li><strong>检查上游服务：</strong> 根据网关日志的线索，直接去排查对应的上游服务。查看它的应用日志、系统资源（CPU、内存）使用情况，确定它为什么没有正常响应网关的请求。</li></ol><h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><h3 id="缓存控制首部"><a href="#缓存控制首部" class="headerlink" title="缓存控制首部"></a>缓存控制首部</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A(开始: 浏览器准备发起请求) --&gt; B&#123;检查本地缓存&#125;;</span><br><span class="line">    B -- 有缓存 --&gt; C&#123;检查强制缓存&#125;;</span><br><span class="line">    B -- 无缓存 --&gt; I(直接向服务器发起请求);</span><br><span class="line"></span><br><span class="line">    C -- 缓存有效 --&gt; D[直接使用缓存, 状态码200];</span><br><span class="line">    C -- 缓存无效 --&gt; E[发起协商缓存请求, 携带If-None-Match 或 If-Modified-Since];</span><br><span class="line"></span><br><span class="line">    E --&gt; F&#123;服务器验证&#125;;</span><br><span class="line">    F -- 资源未改变 --&gt; G[返回304 Not Modified];</span><br><span class="line">    F -- 资源已改变 --&gt; H[返回200 OK和新资源];</span><br><span class="line"></span><br><span class="line">    G --&gt; K(浏览器使用本地缓存并更新过期时间);</span><br><span class="line">    H --&gt; L(浏览器使用新资源并更新缓存);</span><br><span class="line">    I --&gt; H;</span><br><span class="line"></span><br><span class="line">    subgraph &quot;客户端决策区&quot;</span><br><span class="line">        A; B; C; E;</span><br><span class="line">    end</span><br><span class="line">    subgraph &quot;服务器决策区&quot;</span><br><span class="line">        F;</span><br><span class="line">    end</span><br><span class="line">    subgraph &quot;最终结果&quot;</span><br><span class="line">         D; K; L;</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    style D fill:#cde,stroke:#333,stroke-width:2px</span><br><span class="line">    style K fill:#cde,stroke:#333,stroke-width:2px</span><br></pre></td></tr></table></figure><p>HTTP缓存分为两大类：**强制缓存（也叫强缓存）*<em>和*<em>协商缓存</em></em>。</p><ul><li><p><strong>强制缓存 (Strong Caching):</strong> 浏览器在发起请求前，先检查本地缓存的副本是否<strong>在有效期内</strong>。如果在，就<strong>不向服务器发送任何请求</strong>，直接使用本地副本，HTTP状态码是 200 OK (from memory cache &#x2F; from disk cache)。</p></li><li><p><strong>协商缓存 (Negotiation Caching):</strong> 当强制缓存失效（过期）后，浏览器会向服务器<strong>发起一个验证请求</strong>。服务器根据请求中的验证信息判断资源是否有更新。如果没有更新，服务器返回一个<strong>极小的304 Not Modified响应</strong>，不包含响应体，告诉浏览器继续使用本地缓存。如果有更新，才返回200 OK和新的完整资源。</p></li><li><p><strong>Cache-Control的绝对统治地位：</strong> 《图解HTTP》中提到的Pragma: no-cache是HTTP&#x2F;1.0的产物，用于兼容性。Expires也是HTTP&#x2F;1.0的，它使用<strong>绝对时间</strong>，如果客户端和服务器时间不同步，就会出问题。在HTTP&#x2F;1.1中，Cache-Control使用<strong>相对时间</strong>（如 max-age&#x3D;3600 秒），并且指令更丰富，<strong>已完全取代了Expires</strong>。当Cache-Control和Expires同时存在时，Cache-Control的优先级更高。</p></li><li><p><strong>ETag优于Last-Modified：</strong></p><ul><li>Last-Modified（最后修改时间）是协商缓存的一种验证方式，但它存在两个问题：1) 时间戳的精度只能到秒，一秒内多次修改无法识别；2) 某些服务器上，只是打开文件但未修改，也可能导致修改时间变化。</li><li>ETag（实体标签）是服务器为资源生成的唯一标识符（类似文件指纹）。只要资源内容有任何变动，ETag就会改变。它比Last-Modified更精确、更可靠。</li><li><strong>业界标准：</strong> 当ETag和Last-Modified同时存在时，服务器<strong>必须优先使用ETag</strong> 来进行验证。</li></ul></li></ul><h4 id="生活案例-9"><a href="#生活案例-9" class="headerlink" title="生活案例"></a>生活案例</h4><ul><li><strong>强制缓存</strong>就像是你冰箱里的<strong>牛奶</strong>。你每次想喝牛奶时，都会先看一眼保质期（Expires &#x2F; Cache-Control: max-age）。只要还在保质期内，你就直接拿出来喝，根本不用出门去超市问。</li><li><strong>协商缓存</strong>就像是牛奶过期了，但你觉得可能还能喝。你不会直接扔掉，而是会<strong>打开闻一闻</strong>（发起协商缓存请求）。如果闻起来没问题（304 Not Modified），你就继续喝了。如果闻起来坏了（200 OK + 新牛奶），你才会去超市买一瓶新的回来。ETag就像是牛奶包装上的一个独特的批次码，比单看生产日期更可靠。</li></ul><h4 id="真实案例-9"><a href="#真实案例-9" class="headerlink" title="真实案例"></a>真实案例</h4><p> 前端性能优化中对不同资源设置缓存策略。</p><ul><li><strong>不常变动的资源（如库文件 antd.js, vue.js, logo图片）：</strong><ul><li><strong>策略：</strong> 设置一个非常长的<strong>强制缓存</strong>时间。比如 Cache-Control: public, max-age&#x3D;31536000 (一年)。</li><li><strong>配合：</strong> 文件名中通常会带上内容的哈希值，如antd.a3b4c5.js。一旦文件内容有变动，哈希值会变，文件名也变了，这会触发一个新的URL请求。这种策略叫**“内容哈希命名”（Content-addressable storage）**。</li><li><strong>效果：</strong> 用户第一次访问后，这些资源会被永久缓存，后续访问速度极快。</li></ul></li><li><strong>经常变动的资源（如业务逻辑index.js, 主index.html）：</strong><ul><li><strong>策略：</strong> 不设置或设置很短的强制缓存，但<strong>必须开启协商缓存</strong>。比如 Cache-Control: no-cache。no-cache并不是“不缓存”，而是“每次都必须去服务器验证一下”。</li><li><strong>效果：</strong> 保证了用户总能获取到最新的业务逻辑，同时在逻辑未变时，又能通过304响应来利用本地缓存，节省带宽。</li></ul></li></ul><h4 id="经典问题-9"><a href="#经典问题-9" class="headerlink" title="经典问题"></a>经典问题</h4><blockquote><p>请详细描述一下浏览器的缓存机制，特别是强制缓存和协商缓存的区别和联系。</p></blockquote><p>浏览器缓存是HTTP性能优化的核心机制，它主要分为强制缓存和协商缓存两大类，两者是协同工作的。</p><p><strong>1. 强制缓存（Strong Caching）：</strong><br>* <strong>触发机制：</strong> 浏览器在请求资源前，会先检查本地缓存的副本是否在有效期内。<br>* <strong>相关头部：</strong> 主要由服务器响应中的Cache-Control头（HTTP&#x2F;1.1，优先级高）和Expires头（HTTP&#x2F;1.0）控制。Cache-Control: max-age&#x3D;3600表示资源在3600秒内有效。<br>* <strong>表现：</strong> 如果缓存有效，浏览器<strong>不会向服务器发送任何请求</strong>，而是直接从本地内存或磁盘中读取资源，网络请求的状态码会是200 OK (from memory cache&#x2F;disk cache)，速度极快。</p><p><strong>2. 协商缓存（Negotiation Caching）：</strong><br>* <strong>触发机制：</strong> 当强制缓存过期后（或者收到了Cache-Control: no-cache指令），浏览器<strong>必须向服务器发起一次验证请求</strong>。<br>* <strong>相关头部：</strong> 这个验证请求会携带一些“凭证”：<br>* If-None-Match: 携带上一次响应中的ETag值。<br>* If-Modified-Since: 携带上一次响应中的Last-Modified值。<br>* <strong>服务器行为：</strong> 服务器收到请求后，会用这些凭证与当前资源进行比对。<br>* 如果资源<strong>未改变</strong>，服务器返回一个<strong>304 Not Modified</strong>状态码，响应体为空，告诉浏览器“你本地的版本还能用”。<br>* 如果资源<strong>已改变</strong>，服务器返回一个<strong>200 OK</strong>状态码，并在响应体中附上<strong>全新的资源内容</strong>和新的ETag&#x2F;Last-Modified。</p><p><strong>区别与联系：</strong></p><ul><li><strong>联系：</strong> 两者是前后衔接的流程。浏览器总是<strong>先检查强制缓存</strong>，强制缓存失效后，<strong>再发起协商缓存</strong>。</li><li><strong>区别：</strong> 强制缓存的核心是**“不问”<strong>，在有效期内完全不与服务器通信；而协商缓存的核心是</strong>“要问”**，每次都会与服务器通信，但服务器可能只返回一个极简的304响应，而不是完整的资源。</li></ul><p>在性能上，<strong>强制缓存 &gt; 协商缓存（命中304） &gt; 无缓存（完整200）</strong>。</p><h3 id="内容协商相关首部"><a href="#内容协商相关首部" class="headerlink" title="内容协商相关首部"></a>内容协商相关首部</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Client as 浏览器</span><br><span class="line">    participant Server as 服务器</span><br><span class="line"></span><br><span class="line">    Client-&gt;&gt;Server: 发起请求 (GET /article/123)</span><br><span class="line">    Note right of Client: 请求头: Accept-Language: zh-CN, Accept-Encoding: br, gzip</span><br><span class="line">    Server-&gt;&gt;Server: 解析请求头，选择压缩方式</span><br><span class="line">    Server--&gt;&gt;Client: 返回响应 (200 OK)</span><br><span class="line">    Note right of Client: Content-Language: zh-CN, Content-Encoding: br</span><br><span class="line"></span><br><span class="line">    Note over Client: 浏览器解压并渲染页面</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>Accept头部的“退化”与“重生”：</strong><ul><li><strong>传统Web页面：</strong> 在过去，浏览器发送的Accept头部非常复杂，比如Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,<em>&#x2F;</em>;q&#x3D;0.8。它试图告诉服务器它能处理的各种内容类型。但实际上，大多数Web服务器都<strong>忽略</strong>了这个复杂的头部，因为它们通常只返回text&#x2F;html。</li><li><strong>现代API（RESTful）：</strong> Accept头部在API交互中迎来了<strong>重生</strong>。一个设计良好的RESTful API，其同一个端点（URL）可以根据客户端Accept头部的不同，返回不同格式的数据。例如：<ul><li>GET &#x2F;api&#x2F;users&#x2F;1 + Accept: application&#x2F;json -&gt; 返回JSON格式的用户数据。</li><li>GET &#x2F;api&#x2F;users&#x2F;1 + Accept: application&#x2F;xml -&gt; 返回XML格式的用户数据。<br>这使得API具有更好的灵活性和向后兼容性。</li></ul></li></ul></li><li><strong>权重值q：</strong> q因子（quality value）是内容协商的量化工具，范围从0到1。它告诉服务器不同选项的<strong>优先级</strong>。例如 Accept-Language: fr-CH, fr;q&#x3D;0.9, en;q&#x3D;0.8 表示客户端最想要瑞士法语，其次是普通法语，再次是英语。</li><li><strong>Accept-Encoding的重要性：</strong> 这是内容协商中<strong>最常用、最有效</strong>的首部。浏览器通过发送 Accept-Encoding: gzip, deflate, br 告诉服务器它支持这三种解压算法，服务器则可以从中选择一种来压缩响应体，显著减少传输体积。</li></ul><h4 id="生活案例-10"><a href="#生活案例-10" class="headerlink" title="生活案例"></a>生活案例</h4><p>内容协商就像你去一家<strong>国际餐厅</strong>点菜。</p><ul><li>你对服务员（<strong>服务器</strong>）说：“我想点一份牛排（<strong>URL</strong>），我能看懂<strong>中文和英文菜单</strong>（Accept-Language），我喜欢吃<strong>七分熟</strong>的（Accept的一个变体，表示偏好），而且我<strong>不吃辣</strong>（Accept-Encoding的一个变体，表示能力限制）。”</li><li>服务员（<strong>服务器</strong>）听了你的要求，去厨房看了一下，发现今天有中文菜单，并且可以做七分熟不辣的牛排。</li><li>最后，他给你端上了<strong>七分熟的牛排</strong>，并附上了一张<strong>中文账单</strong>（Content-Language: zh）。</li></ul><h4 id="真实案例-10"><a href="#真实案例-10" class="headerlink" title="真实案例"></a>真实案例</h4><p>设计一个图片服务API，需要为不同设备提供最优化的图片格式。</p><ul><li><strong>背景：</strong> 现代浏览器（如Chrome）支持一种名为 <strong>WebP</strong> 的新图片格式，它在同等画质下比JPEG和PNG的体积小很多。但老浏览器不支持。</li><li><strong>实现：</strong><ol><li>服务器上为同一张图片存储多个版本，如 image.jpg, image.png, image.webp。</li><li>现代浏览器发起的图片请求，其Accept头会包含image&#x2F;webp，例如：Accept: image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,image&#x2F;<em>,</em>&#x2F;*;q&#x3D;0.8。</li><li>服务器（或CDN边缘节点）接收到请求后，检查Accept头部。如果发现其中包含image&#x2F;webp，就<strong>优先返回image.webp文件</strong>。</li><li>如果Accept头中没有image&#x2F;webp（说明是老浏览器），则根据情况返回image.jpg或image.png。</li></ol></li><li><strong>效果：</strong> 通过内容协商，为现代浏览器用户提供了加载速度更快的WebP图片，同时保持了对老浏览器的兼容性，实现了渐进式增强的性能优化。</li></ul><h4 id="经典问题-10"><a href="#经典问题-10" class="headerlink" title="经典问题"></a>经典问题</h4><blockquote><p>Accept-Encoding和Content-Encoding是如何配合工作的？这个机制有什么好处？</p></blockquote><p>Accept-Encoding和Content-Encoding是HTTP内容协商中用于<strong>传输压缩</strong>的一对核心请求&#x2F;响应头，它们共同实现了一种高效的数据传输机制。</p><p><strong>工作流程如下：</strong></p><ol><li><strong>客户端声明能力：</strong> 浏览器在发起请求时，通过Accept-Encoding请求头告诉服务器自己支持哪些解压算法。例如：Accept-Encoding: gzip, deflate, br，这表示浏览器能处理gzip、deflate和brotli这三种格式的压缩数据。</li><li><strong>服务器选择并执行压缩：</strong> 服务器收到请求后，会检查这个头部。如果服务器也支持这些算法，并且认为对响应内容进行压缩是有益的（通常对文本类资源有效），它就会选择其中一种算法（通常是压缩率最高的Brotli或最通用的gzip）来压缩响应体。</li><li><strong>服务器告知压缩方式：</strong> 服务器在返回的HTTP响应中，通过Content-Encoding响应头明确告知客户端，它实际使用了哪种算法进行压缩。例如：Content-Encoding: br。</li><li><strong>客户端解码：</strong> 浏览器接收到响应后，根据Content-Encoding头的值，调用相应的解压算法对响应体进行解压，最终得到原始的、可渲染的内容。</li></ol><p><strong>这个机制最大的好处是：</strong></p><ul><li><strong>显著减少了网络传输的数据量</strong>，通常能将HTML&#x2F;CSS&#x2F;JS等文本资源压缩到原始大小的20%-30%，从而<strong>大大加快了页面加载速度，降低了带宽成本，并改善了用户体验</strong>，尤其是在移动网络环境下效果非常明显。这是一种对客户端和服务器都非常有益的双赢机制。</li></ul><h3 id="连接管理首部"><a href="#连接管理首部" class="headerlink" title="连接管理首部"></a>连接管理首部</h3><ul><li><strong>Connection 首部：</strong> 这是一个非常特殊的“元”首部，它有两个核心作用：<ol><li><strong>控制连接的关闭&#x2F;保持：</strong> 它的值可以是close或keep-alive。在HTTP&#x2F;1.1中，默认是持久连接，所以通常只有在想明确关闭连接时，才会发送 Connection: close。</li><li><strong>标识“逐跳”首部：</strong> 这是它更复杂也更重要的作用。Connection首部可以列出一些其他的首部字段名，这些被列出的首部字段被认为是“逐跳”的，<strong>绝不能</strong>被代理服务器转发到下一跳。</li></ol></li><li><strong>Keep-Alive 首部：</strong> 这是一个<strong>已过时</strong>的、非标准的头部，最初在HTTP&#x2F;1.0的持久连接中被引入。它通常包含一些参数，比如 timeout（连接空闲超时时间）和 max（此连接上可处理的最大请求数）。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant C as 客户端</span><br><span class="line">    participant P as 代理服务器</span><br><span class="line">    participant S as 源服务器</span><br><span class="line"></span><br><span class="line">    Note over C,S: 客户端想升级到WebSocket协议</span><br><span class="line">    C-&gt;&gt;P: 请求:&lt;br&gt;Host: ...&lt;br&gt;&lt;b&gt;Upgrade: websocket&lt;/b&gt;&lt;br&gt;&lt;b&gt;Connection: Upgrade&lt;/b&gt;</span><br><span class="line"></span><br><span class="line">    Note over P: 代理服务器处理...</span><br><span class="line">    Note over P: 1. 看到Connection: Upgrade&lt;br&gt;2. 知道Upgrade是逐跳首部&lt;br&gt;3. &lt;b&gt;删除这两个首部&lt;/b&gt;再转发</span><br><span class="line">    P-&gt;&gt;S: 转发后的请求:&lt;br&gt;Host: ...&lt;br&gt;(Upgrade和Connection已被删除)</span><br><span class="line">    </span><br><span class="line">    Note over S: 源服务器收到的是一个普通的HTTP请求</span><br></pre></td></tr></table></figure><h4 id="经典问题-11"><a href="#经典问题-11" class="headerlink" title="经典问题"></a>经典问题</h4><blockquote><p>Connection头部字段有什么作用？</p></blockquote><p>Connection头部在HTTP&#x2F;1.1中是一个非常重要的“逐跳”首部（hop-by-hop header），它主要有两个核心作用：</p><ol><li><strong>控制连接的状态：</strong> 它的值可以是keep-alive或close。在HTTP&#x2F;1.1中，连接默认是持久的，所以我们通常只在需要明确指示在响应后关闭连接时，才会发送Connection: close。这可以用来优雅地通知对端，这是我最后一个请求&#x2F;响应了。</li><li><strong>管理逐跳首部：</strong> 这是它更底层、更关键的作用。Connection头部的值可以是一个逗号分隔的<strong>其他首部字段名列表</strong>。所有被列在这里的首部字段，都被认为是“逐跳”的，即它们只对当前的单次TCP连接有效，<strong>绝不能被代理服务器转发给下一个节点</strong>。在转发报文前，代理必须删除Connection首部以及它里面列出的所有首部。最典型的例子就是Upgrade头部（用于协议升级，如WebSocket），它总是与Connection: Upgrade一起出现，以确保只有直接相连的服务器才会处理这个升级请求。</li></ol><h2 id="TCP-IP基础"><a href="#TCP-IP基础" class="headerlink" title="TCP&#x2F;IP基础"></a>TCP&#x2F;IP基础</h2><h3 id="OSI七层-TCP-IP四层模型及协议对应关系"><a href="#OSI七层-TCP-IP四层模型及协议对应关系" class="headerlink" title="OSI七层 &amp; TCP&#x2F;IP四层模型及协议对应关系"></a>OSI七层 &amp; TCP&#x2F;IP四层模型及协议对应关系</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">  %% OSI 七层模型</span><br><span class="line">  subgraph OSI七层模型</span><br><span class="line">    OSI7[&quot;应用层&lt;br&gt;🌐&quot;]:::osi7</span><br><span class="line">    OSI6[&quot;表示层&lt;br&gt;📝&quot;]:::osi6</span><br><span class="line">    OSI5[&quot;会话层&lt;br&gt;🔗&quot;]:::osi5</span><br><span class="line">    OSI4[&quot;传输层&lt;br&gt;📦&quot;]:::osi4</span><br><span class="line">    OSI3[&quot;网络层&lt;br&gt;🌍&quot;]:::osi3</span><br><span class="line">    OSI2[&quot;数据链路层&lt;br&gt;🪢&quot;]:::osi2</span><br><span class="line">    OSI1[&quot;物理层&lt;br&gt;⚡&quot;]:::osi1</span><br><span class="line">    OSI7--&gt;OSI6--&gt;OSI5--&gt;OSI4--&gt;OSI3--&gt;OSI2--&gt;OSI1</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  %% TCP/IP 四层模型</span><br><span class="line">  subgraph TCPIP四层模型</span><br><span class="line">    TCP4[&quot;应用层&lt;br&gt;🌐&quot;]:::tcp4</span><br><span class="line">    TCP3[&quot;传输层&lt;br&gt;📦&quot;]:::tcp3</span><br><span class="line">    TCP2[&quot;网络层&lt;br&gt;🌍&quot;]:::tcp2</span><br><span class="line">    TCP1[&quot;链路层&lt;br&gt;🪢&quot;]:::tcp1</span><br><span class="line">    TCP4--&gt;TCP3--&gt;TCP2--&gt;TCP1</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  %% 协议举例</span><br><span class="line">  subgraph 协议</span><br><span class="line">    APP[&quot;HTTP&lt;br&gt;FTP&lt;br&gt;SMTP&lt;br&gt;DNS&lt;br&gt;Telnet&quot;]:::app</span><br><span class="line">    TRANS[&quot;TCP&lt;br&gt;UDP&quot;]:::trans</span><br><span class="line">    NET[&quot;IP&lt;br&gt;ICMP&lt;br&gt;ARP&quot;]:::net</span><br><span class="line">    LINK[&quot;Ethernet&lt;br&gt;PPP&lt;br&gt;Wi-Fi&quot;]:::link</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  %% 对应关系</span><br><span class="line">  TCP4---APP</span><br><span class="line">  OSI7 &amp; OSI6 &amp; OSI5---APP</span><br><span class="line">  TCP3---TRANS</span><br><span class="line">  OSI4---TRANS</span><br><span class="line">  TCP2---NET</span><br><span class="line">  OSI3---NET</span><br><span class="line">  TCP1---LINK</span><br><span class="line">  OSI2 &amp; OSI1---LINK</span><br><span class="line"></span><br><span class="line">  %% 样式</span><br><span class="line">  classDef osi7 fill:#e0e7ff,stroke:#6366f1,stroke-width:2px;</span><br><span class="line">  classDef osi6 fill:#c7d2fe,stroke:#6366f1,stroke-width:2px;</span><br><span class="line">  classDef osi5 fill:#a5b4fc,stroke:#6366f1,stroke-width:2px;</span><br><span class="line">  classDef osi4 fill:#f9fafb,stroke:#6366f1,stroke-width:2px;</span><br><span class="line">  classDef osi3 fill:#a7f3d0,stroke:#059669,stroke-width:2px;</span><br><span class="line">  classDef osi2 fill:#fde68a,stroke:#b45309,stroke-width:2px;</span><br><span class="line">  classDef osi1 fill:#fca5a5,stroke:#b91c1c,stroke-width:2px;</span><br><span class="line">  classDef tcp4 fill:#e0f2fe,stroke:#0ea5e9,stroke-width:2px;</span><br><span class="line">  classDef tcp3 fill:#bae6fd,stroke:#0369a1,stroke-width:2px;</span><br><span class="line">  classDef tcp2 fill:#a7f3d0,stroke:#059669,stroke-width:2px;</span><br><span class="line">  classDef tcp1 fill:#fef9c3,stroke:#ca8a04,stroke-width:2px;</span><br><span class="line">  classDef app fill:#f3e8ff,stroke:#9333ea,stroke-width:2px;</span><br><span class="line">  classDef trans fill:#fef3c7,stroke:#ca8a04,stroke-width:2px;</span><br><span class="line">  classDef net fill:#bbf7d0,stroke:#22d3ee,stroke-width:2px;</span><br><span class="line">  classDef link fill:#fce7f3,stroke:#db2777,stroke-width:2px;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">  HTTP[&quot;🌐 HTTP数据&lt;br&gt;应用层&quot;]:::app</span><br><span class="line">  HTTP--&quot;封装HTTP头部&quot;--&gt;TCP[&quot;📦 TCP报文段&lt;br&gt;传输层&quot;]:::trans</span><br><span class="line">  TCP--&quot;封装TCP头部&quot;--&gt;IP[&quot;🌍 IP数据包&lt;br&gt;网络层&quot;]:::net</span><br><span class="line">  IP--&quot;封装IP头部&quot;--&gt;ETH[&quot;🪢 以太网帧&lt;br&gt;链路层&quot;]:::link</span><br><span class="line">  ETH--&quot;封装MAC帧头部&quot;--&gt;BITS[&quot;⚡ 比特流&lt;br&gt;物理层&quot;]:::phy</span><br><span class="line"></span><br><span class="line">  BITS--&gt;PHYNET[&quot;🌐 物理网络&quot;]:::phy</span><br><span class="line"></span><br><span class="line">  classDef app fill:#e0e7ff,stroke:#6366f1,stroke-width:2px;</span><br><span class="line">  classDef trans fill:#fef3c7,stroke:#ca8a04,stroke-width:2px;</span><br><span class="line">  classDef net fill:#bbf7d0,stroke:#22d3ee,stroke-width:2px;</span><br><span class="line">  classDef link fill:#fce7f3,stroke:#db2777,stroke-width:2px;</span><br><span class="line">  classDef phy fill:#fca5a5,stroke:#b91c1c,stroke-width:2px;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生活案例-11"><a href="#生活案例-11" class="headerlink" title="生活案例"></a>生活案例</h3><p>TCP&#x2F;IP的数据传输就像一次<strong>国际快递</strong>。</p><ul><li><strong>应用层 (HTTP):</strong> 你要寄送的“商品”（比如一部手机）。</li><li><strong>传输层 (TCP):</strong> 你把手机装进一个<strong>带有联系方式的</strong>快递盒。盒子上写着你和收件人的电话（<strong>端口号</strong>），并选择了“顺丰保价”（<strong>TCP</strong>，确保可靠送达）。</li><li><strong>网络层 (IP):</strong> 快递公司在你的盒子上贴上国际运单，上面有收件人的详细家庭地址（<strong>IP地址</strong>）。</li><li><strong>链路层 (MAC):</strong> 本地快递员来取件，他只关心下一站是哪个集散中心（下一个路由器的<strong>MAC地址</strong>），把你的包裹装上他的车。</li><li>整个过程，你的“商品”被一层层地包装起来，这就是<strong>封装（Encapsulation）</strong>。</li></ul><h3 id="真实案例-11"><a href="#真实案例-11" class="headerlink" title="真实案例"></a>真实案例</h3><p>思考一个在线直播应用。它同时需要传输两种数据：</p><ol><li><strong>控制信令：</strong> 你发送的弹幕、点赞、送礼物。这些信息<strong>绝对不能丢失</strong>，必须准确送达。因此，承载这些信令的协议（比如一个自定义协议或HTTP）必须运行在<strong>TCP</strong>之上。</li><li><strong>音视频流：</strong> 直播的画面和声音。这些数据量巨大，更强调<strong>实时性</strong>。偶尔丢掉一两帧画面（表现为轻微卡顿或花屏）是可以接受的，但不能因为重传一个旧数据包而导致整个画面延迟。因此，音视频流数据通常运行在<strong>UDP</strong>之上（使用RTP&#x2F;RTCP等协议）。</li></ol><h3 id="经典问题-12"><a href="#经典问题-12" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>简单说说TCP和UDP的区别以及它们各自的应用场景。</p></blockquote><p>TCP和UDP都位于传输层，但它们的设计哲学和应用场景完全不同。</p><p><strong>核心区别有三点：</strong></p><ol><li><strong>连接性与可靠性：</strong> TCP是<strong>面向连接</strong>的，通信前必须“三次握手”建立连接，它提供<strong>可靠的、有序的</strong>数据传输，保证不丢包、不乱序。而UDP是<strong>无连接</strong>的，它只管发，不保证对方是否收到，是一种“尽力而为”的<strong>不可靠</strong>传输。</li><li><strong>开销与速度：</strong> 因为TCP要维护连接状态、进行确认、重传和拥塞控制，所以它的头部开销大（至少20字节），速度相对较慢。UDP没有这些复杂的机制，头部开销极小（固定8字节），速度非常快。</li><li><strong>数据形态：</strong> TCP提供的是<strong>字节流</strong>服务，数据像水流一样没有边界。UDP提供的是<strong>数据报</strong>服务，发送方发送一个个独立的数据包，接收方也必须按包接收。</li></ol><p><strong>应用场景的选择完全基于这些区别：</strong></p><ul><li><strong>选择TCP的场景：</strong> 凡是要求数据<strong>绝对完整、准确</strong>的应用，都必须使用TCP。例如：<strong>HTTP&#x2F;HTTPS</strong>浏览网页、<strong>FTP</strong>文件传输、<strong>SMTP&#x2F;POP3</strong>电子邮件。</li><li><strong>选择UDP的场景：</strong> 凡是追求<strong>实时性</strong>、能容忍一定丢包率的应用，都适合UDP。例如：<strong>DNS解析</strong>（追求快速响应）、<strong>音视频通话&#x2F;直播</strong>、<strong>在线游戏</strong>的数据同步。</li></ul><h3 id="补充知识-2"><a href="#补充知识-2" class="headerlink" title="补充知识"></a>补充知识</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    %% 配色阶段一：DNS 查询</span><br><span class="line">    rect rgb(237,247,255)</span><br><span class="line">        participant Browser as 浏览器&lt;br/&gt;&amp;#128187;</span><br><span class="line">        participant DNS_Server as DNS服务器&lt;br/&gt;&amp;#128424;</span><br><span class="line">        participant Web_Server as Web服务器&lt;br/&gt;&amp;#128187;</span><br><span class="line">        Note over Browser, DNS_Server: &lt;b&gt;第一步：域名解析（DNS）&lt;/b&gt;</span><br><span class="line">        Browser-&gt;&gt;DNS_Server: 1. 查询域名IP&lt;br/&gt;（www.example.com）</span><br><span class="line">        DNS_Server--&gt;&gt;Browser: 2. 返回IP地址&lt;br/&gt;（93.184.216.34）</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 配色阶段二：TCP连接（三次握手）</span><br><span class="line">    rect rgb(230,255,239)</span><br><span class="line">        Note over Browser, Web_Server: &lt;b&gt;第二步：建立TCP连接（三次握手）&lt;/b&gt;</span><br><span class="line">        Browser-&gt;&gt;Web_Server: 3. SYN（请求建立连接）</span><br><span class="line">        Web_Server--&gt;&gt;Browser: 4. SYN, ACK（确认+回应请求）</span><br><span class="line">        Browser-&gt;&gt;Web_Server: 5. ACK（连接建立完成）</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 配色阶段三：HTTP/HTTPS请求</span><br><span class="line">    rect rgb(255,248,225)</span><br><span class="line">        Note over Browser, Web_Server: &lt;b&gt;第三步：发送HTTP请求/响应&lt;/b&gt;</span><br><span class="line">        Browser-&gt;&gt;Web_Server: 6. 发送HTTP请求&lt;br/&gt;（如GET /index.html）</span><br><span class="line">        Web_Server--&gt;&gt;Browser: 7. 返回HTTP响应&lt;br/&gt;（如200 OK，网页内容）</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 可选阶段：关闭连接</span><br><span class="line">    rect rgb(245,245,245)</span><br><span class="line">        Note over Browser, Web_Server: &lt;b&gt;第四步：关闭TCP连接（四次挥手）&lt;/b&gt;</span><br><span class="line">        Browser-&gt;&gt;Web_Server: 8. FIN（请求断开连接）</span><br><span class="line">        Web_Server--&gt;&gt;Browser: 9. ACK（确认收到断开请求）</span><br><span class="line">        Web_Server-&gt;&gt;Browser: 10. FIN（服务器断开）</span><br><span class="line">        Browser--&gt;&gt;Web_Server: 11. ACK（断开完成）</span><br><span class="line">    end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>DNS是互联网的基石服务。不理解DNS，你甚至不知道请求该发往何处。它是所有网络请求的第一步。</p><ol><li><strong>缓存是关键：</strong> 为了性能，DNS查询结果会被层层缓存，顺序是：<strong>浏览器缓存 -&gt; 操作系统缓存 -&gt; 路由器缓存 -&gt; 本地DNS服务器缓存</strong>。这极大地减少了对根DNS服务器的请求压力。</li><li><strong>记录类型多样化：</strong> 除了将域名指向IPv4地址的A记录，还有指向IPv6的AAAA记录，定义别名的CNAME记录，以及邮件服务器的MX记录等。</li><li><strong>智能DNS与负载均衡：</strong> 现代DNS服务（如CDN服务商提供的GeoDNS）能识别用户的地理位置，返回离他最近的服务器IP地址，这是实现CDN内容就近分发和全局负载均衡的核心技术。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    subgraph DNS查询流程</span><br><span class="line">        direction TB</span><br><span class="line">        A[&quot;fa:fa-chrome 浏览器&quot;]</span><br><span class="line">        B&#123;&#123;&quot;fa:fa-database 本地缓存有吗?&quot;&#125;&#125;</span><br><span class="line">        C[&quot;fa:fa-arrow-rotate-left 直接返回IP&quot;]</span><br><span class="line">        D[&quot;fa:fa-network-wired 本地DNS服务器&quot;]</span><br><span class="line">        E[&quot;fa:fa-globe 根DNS服务器&quot;]</span><br><span class="line">        F[&quot;fa:fa-layer-group .com顶级域DNS&quot;]</span><br><span class="line">        G[&quot;fa:fa-server 权威DNS example.com&quot;]</span><br><span class="line"></span><br><span class="line">        %% 主流程</span><br><span class="line">        A -- &quot;1. 查缓存&quot; --&gt; B</span><br><span class="line">        B -- &quot;有&quot; --&gt; C</span><br><span class="line">        C -- &quot;返回IP&quot; --&gt; A</span><br><span class="line">        B -- &quot;没有&quot; --&gt; D</span><br><span class="line">        D -- &quot;2. 递归/迭代查询&quot; --&gt; E</span><br><span class="line">        E --&gt; F</span><br><span class="line">        F --&gt; G</span><br><span class="line">        G -- &quot;IP地址&quot; --&gt; D</span><br><span class="line">        D -- &quot;缓存结果并返回&quot; --&gt; A</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 节点配色，兼容性极佳</span><br><span class="line">    style A fill:#e8f4fd,stroke:#1976d2,stroke-width:2px</span><br><span class="line">    style B fill:#fff6db,stroke:#e6a500,stroke-width:2px</span><br><span class="line">    style C fill:#d9f9e5,stroke:#21a366,stroke-width:2px</span><br><span class="line">    style D fill:#f3e8fd,stroke:#9c27b0,stroke-width:2px</span><br><span class="line">    style E fill:#ffe5f1,stroke:#d81b60,stroke-width:2px</span><br><span class="line">    style F fill:#fef6e0,stroke:#ff9800,stroke-width:2px</span><br><span class="line">    style G fill:#ffecec,stroke:#d72638,stroke-width:2px</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>面试题:  除了A记录，你还知道哪些常见的DNS记录类型，它们分别有什么作用？</p></blockquote><p>除了最常见的、将域名映射到IPv4地址的<strong>A记录</strong>外，我还了解以下几种关键的DNS记录：</p><ul><li><strong>AAAA记录：</strong> 功能与A记录类似，但用于将域名映射到<strong>IPv6地址</strong>，是IPv6时代的基础。</li><li><strong>CNAME记录（别名记录）：</strong> 允许将一个域名指向另一个域名。比如，我可以把blog.example.com的CNAME记录指向user.github.io，这样访问我的博客就会被解析到GitHub Pages的服务。它常用于CDN加速，将用户域名指向CDN服务商的域名。</li><li><strong>MX记录（邮件交换记录）：</strong> 指向负责处理该域电子邮件的服务器。比如example.com的MX记录会指向mail.example.com，这样发往<a href="mailto:&#x78;&#120;&#x78;&#64;&#101;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;">xxx@example.com</a>的邮件才知道该送往哪里。</li><li><strong>NS记录（域名服务器记录）：</strong> 指定了哪个DNS服务器是该域的权威服务器，负责该域的解析。</li></ul><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    %% 阶段一：客户端发起 SYN</span><br><span class="line">    rect rgb(220,245,255)</span><br><span class="line">        participant Client as 🧑‍💻 客户端&lt;br/&gt;Client</span><br><span class="line">        participant Server as 🖥️ 服务器&lt;br/&gt;Server</span><br><span class="line">        Client-&gt;&gt;Server: 1. SYN (seq=x, 源端口/目标端口)</span><br><span class="line">        Note over Client,Server: 请求建立连接&lt;br/&gt;SYN=1, ISN=x&lt;br/&gt;“我想建立连接, 我的初始序列号是x”</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 阶段二：服务器响应 SYN, ACK</span><br><span class="line">    rect rgb(228,255,237)</span><br><span class="line">        Server--&gt;&gt;Client: 2. SYN, ACK (seq=y, ack=x+1)</span><br><span class="line">        Note over Client,Server: 同意连接，确认收到SYN&lt;br/&gt;SYN=1, ACK=1, ISN=y, ACK=x+1&lt;br/&gt;“我的初始序列号是y, 我确认收到了你的x”</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 阶段三：客户端确认 ACK</span><br><span class="line">    rect rgb(255,249,220)</span><br><span class="line">        Client-&gt;&gt;Server: 3. ACK (seq=x+1, ack=y+1)</span><br><span class="line">        Note over Client,Server: 确认收到SYN和ACK&lt;br/&gt;ACK=1, seq=x+1, ack=y+1&lt;br/&gt;“我确认收到了你的y, 连接建立”</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 阶段四：连接建立后，传输数据</span><br><span class="line">    rect rgb(237,245,255)</span><br><span class="line">        Client-&gt;&gt;Server: 4. 数据传输（如GET请求）</span><br><span class="line">        Server--&gt;&gt;Client: 5. 数据响应（如HTTP响应）</span><br><span class="line">        Note over Client,Server: 连接已建立，可以开始数据通信</span><br><span class="line">    end</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>面试题:  为什么TCP建立连接需要三次握手，而不是两次或者四次？</p></blockquote><p>这个问题核心在于理解TCP作为<strong>全双工、可靠通信</strong>协议的本质。</p><ul><li><strong>不能是两次的原因：</strong> 无法防止历史的、已失效的连接请求报文突然又传送到了服务器，从而引发错误。如果只有两次握手，服务器收到一个旧的SYN包就会立即建立连接并等待客户端数据，这将浪费服务器资源。而三次握手时，客户端不会对旧连接的SYN+ACK进行确认，服务器收不到ACK就不会建立连接。更关键的是，两次握手无法让双方都确认对方的接收和发送能力都正常。</li><li><strong>不需要四次的原因：</strong> 三次握手已经足够验证双方的收发能力并同步初始序列号了。服务器的确认（ACK）和同步请求（SYN）可以在第二步中合并为一个报文（SYN+ACK）发送，没有必要拆成两次。因此，四次握手虽然也能工作，但效率不如三次。</li></ul><p>总结来说，<strong>三次握手是保证双方建立可靠连接所需的最少步骤。</strong></p><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><ul><li><strong>IPv4地址耗尽：</strong> 32位的IPv4地址空间（约43亿个）已经完全耗尽，这是向IPv6迁移的根本动力。</li><li><strong>IPv6的优势：</strong> 128位的IPv6提供了近乎无限的地址空间，彻底解决了地址短缺问题。同时，它简化了报文头部，提高了路由效率，并且原生支持IPSec，安全性更好。</li><li><strong>NAT的角色：</strong> 了解IPv4时代广泛使用的NAT（网络地址转换）技术，它虽然缓解了地址不足，但也破坏了IP的端到端通信模型，给一些P2P应用带来了麻烦。</li></ul><h4 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h4><p><strong>在应用层重新实现了一个更智能、更适合现代网络的“TCP”</strong>,它之所以能做到这一点，主要依靠三大核心武器：<strong>流（Stream）、0-RTT&#x2F;1-RTT握手、以及连接迁移</strong>。</p><ul><li><p>基于“流”的多路复用，彻底消灭队头阻塞</p><ul><li><p><strong>TCP的问题（传输层队头阻塞）：</strong><br>想象一下TCP连接是一条<strong>单车道的高速公路</strong>。所有的数据包（HTTP请求1、请求2、图片数据等）都必须在这条单车道上排队行驶。如果其中一辆车（一个数据包）在路上抛锚了（网络丢包），后面的所有车都得堵着，等待这辆车被拖走（TCP重传机制）。这就是<strong>传输层的队头阻塞（Head-of-Line Blocking）</strong>。即使HTTP&#x2F;2在应用层实现了多路复用，但它仍然跑在TCP上，这条高速公路还是单车道，堵车问题依旧存在。</p></li><li><p><strong>QUIC的解决方案（在连接内部开辟多条车道）：</strong><br>QUIC依然是建立一个连接，但它在这条连接内部，开辟了<strong>多条逻辑上独立的“流”（Stream）</strong>。每个HTTP请求-响应对（比如一个HTML请求，一个CSS请求）都跑在自己专属的流里。</p><p>现在，如果承载CSS的那个流里的一个数据包丢失了，它<strong>只会阻塞CSS流自己</strong>。承载HTML和图片的流完全不受影响，它们的数据包会绕过这个“事故点”，继续被处理和交付</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    %% --- TCP 部分 ---</span><br><span class="line">    subgraph TCP [TCP 传输层 - 队头阻塞]</span><br><span class="line">        direction LR</span><br><span class="line">        P1[&quot;fa:fa-html5 包1: HTML&quot;]</span><br><span class="line">        P2[&quot;fa:fa-css3-alt 包2: CSS&quot;]</span><br><span class="line">        P3_lost[&quot;fa:fa-css3-alt 包3: CSS 丢失!&quot;]</span><br><span class="line">        P4[&quot;fa:fa-js 包4: JS (必须等待丢失包重传)&quot;]</span><br><span class="line"></span><br><span class="line">        P1 --&gt; P2 --&gt; P3_lost -- X --&gt; P4</span><br><span class="line"></span><br><span class="line">        style P3_lost fill:#ffbcbc,stroke:#c0392b,stroke-width:2px</span><br><span class="line">        style TCP fill:#e7f1fb,stroke:#3498db,stroke-width:3px</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% --- QUIC 部分 ---</span><br><span class="line">    subgraph QUIC [QUIC 多流 无队头阻塞]</span><br><span class="line">        direction LR</span><br><span class="line">        Q1[&quot;fa:fa-html5 流1: HTML 包1 (可立即处理)&quot;]</span><br><span class="line">        Q2[&quot;fa:fa-css3-alt 流2: CSS 包2&quot;]</span><br><span class="line">        Q3_lost[&quot;fa:fa-css3-alt 流2: CSS 包3 丢失!&quot;]</span><br><span class="line">        Q4[&quot;fa:fa-js 流3: JS 包4 (可立即处理)&quot;]</span><br><span class="line"></span><br><span class="line">        Q2 --&gt; Q3_lost</span><br><span class="line"></span><br><span class="line">        style Q3_lost fill:#ffbcbc,stroke:#c0392b,stroke-width:2px</span><br><span class="line">        style QUIC fill:#e8fbe7,stroke:#27ae60,stroke-width:3px</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% --- 节点配色 ---</span><br><span class="line">    classDef html fill:#e3f2fd,stroke:#1976d2;</span><br><span class="line">    classDef css fill:#f9fbe7,stroke:#009688;</span><br><span class="line">    classDef js fill:#fff8e1,stroke:#ffa000;</span><br><span class="line"></span><br><span class="line">    class P1,Q1 html;</span><br><span class="line">    class P2,Q2,Q3_lost css;</span><br><span class="line">    class P4,Q4 js;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>0-RTT&#x2F;1-RTT快速握手，抢占先机</p><ul><li><p><strong>TCP+TLS的问题：握手延迟高</strong></p><ul><li>一个普通的HTTPS连接建立需要：<ol><li>TCP三次握手（耗时1个RTT）</li><li>TLS握手（通常是1-2个RTT）</li></ol></li><li>加起来总共需要<strong>2-3个RTT</strong>才能开始发送第一个HTTP请求数据，这在移动网络环境下延迟非常明显。</li></ul></li><li><p><strong>QUIC的解决方案：集成的加密和传输握手</strong><br>QUIC把“我是谁”（加密认证）和“怎么通信”（传输控制）这两件事合并在一起做了。</p><p><strong>首次连接 (1-RTT)：</strong> 客户端和服务器在第一个RTT内就能完成所有必要的加密和传输参数交换，之后立刻可以开始发送应用数据。</p><p><strong>恢复连接 (0-RTT - 这是真正的黑魔法)：</strong> 如果客户端之前访问过这个服务器，服务器会给它一个“凭证”。下次再访问时，客户端可以在<strong>第一个发送的数据包里就带上这个凭证和加密后的HTTP请求</strong>。服务器验证凭证后，无需任何等待，直接处理请求并返回数据。实现了真正的“零延迟”连接建立。</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    autonumber</span><br><span class="line"></span><br><span class="line">    %% --- TCP + TLS (3 RTT) ---</span><br><span class="line">    participant C1 as 🧑‍💻 Client</span><br><span class="line">    participant S1 as 🖥️ Server</span><br><span class="line"></span><br><span class="line">    C1-&gt;&gt;S1: TCP SYN</span><br><span class="line">    S1--&gt;&gt;C1: TCP SYN ACK</span><br><span class="line">    C1-&gt;&gt;S1: TCP ACK (TCP established)</span><br><span class="line">    Note over C1,S1: RTT 1 (TCP Handshake)</span><br><span class="line">    C1-&gt;&gt;S1: TLS ClientHello</span><br><span class="line">    S1--&gt;&gt;C1: TLS ServerHello, Certificate</span><br><span class="line">    S1--&gt;&gt;C1: TLS Finished</span><br><span class="line">    Note over C1,S1: RTT 2 (TLS Handshake)</span><br><span class="line">    C1-&gt;&gt;S1: TLS Finished</span><br><span class="line">    C1-&gt;&gt;S1: HTTP Data</span><br><span class="line">    Note over C1,S1: RTT 3 (HTTP can be sent)</span><br><span class="line"></span><br><span class="line">    %% --- QUIC (1 RTT) ---</span><br><span class="line">    participant C2 as 🧑‍💻 Client2</span><br><span class="line">    participant S2 as 🖥️ Server2</span><br><span class="line"></span><br><span class="line">    C2-&gt;&gt;S2: QUIC Initial (with TLS info)</span><br><span class="line">    S2--&gt;&gt;C2: QUIC Initial and Handshake (key agreement)</span><br><span class="line">    C2-&gt;&gt;S2: HTTP Data</span><br><span class="line">    Note over C2,S2: RTT 1 (HTTP can be sent)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>连接迁移，无缝切换网络<ul><li><strong>TCP的问题：连接与IP地址强绑定</strong><br>TCP连接由一个四元组定义：(源IP, 源端口, 目标IP, 目标端口)。当你的手机从Wi-Fi切换到4G网络时，你的<strong>源IP地址变了</strong>，这个四元组就失效了，<strong>TCP连接会立刻中断</strong>。所有正在进行中的下载、上传、网页加载都必须重新开始。</li><li><strong>QUIC的解决方案：基于连接ID（Connection ID）</strong><br>QUIC连接不依赖于IP地址，而是由一个64位的<strong>连接ID</strong>来唯一标识。只要这个ID不变，无论你的手机IP地址和端口怎么变，QUIC连接都能继续保持。它会无缝地将数据包从旧地址迁移到新地址上，应用层完全无感。</li><li><strong>生活中的比喻：</strong><ul><li><strong>TCP连接</strong>就像你家的<strong>座机电话</strong>，它绑定在你家的物理地址上，你一出门，电话就断了。</li><li><strong>QUIC连接</strong>就像你的<strong>手机</strong>，它绑定在你的手机号（连接ID）上，无论你是在家、在公司还是在地铁上，电话都能一直保持通话。</li></ul></li></ul></li></ul><h2 id="Http的安全问题"><a href="#Http的安全问题" class="headerlink" title="Http的安全问题"></a>Http的安全问题</h2><p><img src="https://img.996007.icu/file/1752720583236_mermaid-ai-diagram-2025-07-17-024905.png" alt="mermaid-ai-diagram-2025-07-17-024905"></p><p>《图解HTTP》和《权威指南》都明确指出了HTTP协议在设计之初，并未过多考虑安全问题，其核心缺陷主要有三点：</p><ol><li><strong>通信使用明文，内容可能被窃听：</strong> HTTP报文在网络中以纯文本的形式传输，任何在传输路径上的节点（如路由器、网络运营商、黑客）都可以轻易地截获并查看通信内容，包括用户名、密码、信用卡号等敏感信息。</li><li><strong>不验证通信方身份，可能遭遇伪装：</strong> HTTP协议本身无法验证客户端和服务器的真实身份。你以为你在访问银行网站，但实际上可能连接到了一个精心伪装的“钓鱼”网站。反之，服务器也无法确定请求是否真的来自一个合法的用户。</li><li><strong>无法证明报文的完整性，可能遭篡改：</strong> HTTP协议没有提供校验机制来确保报文在传输过程中未被修改。攻击者可以在中途拦截报文，篡改内容（比如在网页中植入恶意广告或脚本），而接收方对此一无所知。这种攻击被称为<strong>中间人攻击（Man-in-the-Middle, MITM）</strong>。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant C as 客户端</span><br><span class="line">    participant M as 中间人攻击者</span><br><span class="line">    participant S as 真实服务器</span><br><span class="line"></span><br><span class="line">    C-&gt;&gt;M: HTTP请求 (发往S)</span><br><span class="line">    Note over C,M: &lt;b&gt;1. 窃听:&lt;/b&gt; 中间人截获了明文请求</span><br><span class="line">    </span><br><span class="line">    M-&gt;&gt;S: 转发/篡改后的请求</span><br><span class="line">    Note over S,M: S以为请求来自C (&lt;b&gt;2. 伪装&lt;/b&gt;)</span><br><span class="line">    </span><br><span class="line">    S--&gt;&gt;M: HTTP响应</span><br><span class="line">    Note over M,C: &lt;b&gt;3. 篡改:&lt;/b&gt; 中间人修改响应内容</span><br><span class="line">    </span><br><span class="line">    M--&gt;&gt;C: 返回篡改后的响应</span><br><span class="line">    Note over C: C以为响应来自S, 未察觉内容被修改</span><br></pre></td></tr></table></figure><h3 id="生活案例-12"><a href="#生活案例-12" class="headerlink" title="生活案例"></a>生活案例</h3><p>使用HTTP通信<strong>就像是在公共场合用</strong>明信片**写信和收信。</p><ul><li><strong>明文传输&#x2F;窃听：</strong> 任何人（邮递员、邻居）在传递过程中都可以看到明信片上写了什么。</li><li><strong>不验证身份&#x2F;伪装：</strong> 你收到一张署名“你妈妈”的明信片，但你没法确定这真是你妈妈写的，可能是骗子冒充的。</li><li><strong>不保完整&#x2F;篡改：</strong> 有人在你的明信片上用涂改液改了几个字，你收到后也无法发现。</li></ul><h3 id="真实案例-12"><a href="#真实案例-12" class="headerlink" title="真实案例"></a>真实案例</h3><ul><li>最典型的案例就是<strong>公共Wi-Fi陷阱</strong>。当你在咖啡馆连接一个不安全的免费Wi-Fi时，这个Wi-Fi的提供者（可能是个黑客）就处在了你的通信链路上，成为了一个“中间人”。</li><li>如果你此时访问一个HTTP的网站并输入密码，黑客可以<strong>直接看到</strong>你的密码。</li><li>黑客还可以将你访问的HTTP网站<strong>重定向</strong>到一个他制作的假冒网站，骗取你的信任和信息。</li><li>他甚至可以在你正常浏览的HTTP网页中，<strong>动态注入</strong>恶意JavaScript脚本，来窃取你的其他信息。</li><li>而如果网站使用了HTTPS，上述所有攻击都将因为无法解密通信内容和伪造证书而失效。</li></ul><h3 id="经典问题-13"><a href="#经典问题-13" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>为什么说HTTP是“不安全”的？请从协议层面具体说明其存在的主要风险。</p></blockquote><p>HTTP协议在设计之初主要目标是高效地传输超文本，因此并未内置安全机制，这使其在今天的互联网环境中存在三大核心风险，通常被称为“不安全”：</p><ol><li><strong>明文传输导致窃听风险：</strong> HTTP报文在网络上是以纯文本形式传输的，没有进行任何加密。这意味着在请求从客户端到服务器的整个传输路径上，任何一个中间节点（如路由器、恶意网关、网络嗅探工具）都能轻易地截获并直接读取通信的全部内容，包括像密码、支付信息这样的敏感数据。</li><li><strong>缺少身份验证导致伪装风险：</strong> HTTP协议本身无法验证通信双方的身份。客户端无法确认它正在对话的服务器就是它声称的那个服务器，这为“钓鱼网站”等中间人攻击提供了可能。同样，服务器也无法确认请求方的真实身份，这使得它容易受到恶意请求的攻击。</li><li><strong>缺乏完整性校验导致篡改风险：</strong> HTTP没有机制来保证报文在传输过程中不被修改。攻击者可以在中间环节拦截报文，任意篡改其内容（比如植入广告、病毒或恶意代码），然后再转发给接收方。由于没有校验机制，接收方无法察觉到报文已经被篡改，从而可能造成严重后果。</li></ol><p>这三个根本性的缺陷——<strong>窃听、伪装、篡改</strong>——使得HTTP在处理任何涉及隐私、交易或需要信任的场景时都是完全不可靠的。而HTTPS正是为了解决这三大问题而诞生的。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p><strong>HTTPS不是一个新协议。</strong> 它的全称是“HTTP over SSL&#x2F;TLS”。它并不是在HTTP基础上修改，而是在HTTP和TCP之间增加了一个<strong>安全层（SSL&#x2F;TLS）</strong>。</p><p>这个安全层提供了三大核心能力，正好对应了HTTP的三大缺陷：</p><ol><li><strong>内容加密：</strong> 通过<strong>混合加密</strong>算法，将HTTP报文加密成密文传输，解决了<strong>窃听</strong>问题。</li><li><strong>身份认证：</strong> 通过<strong>数字证书（CA体系）</strong>，验证服务器的身份，解决了<strong>伪装</strong>问题。</li><li><strong>数据完整性：</strong> 通过<strong>报文摘要（MAC）</strong>，确保数据在传输过程中未被篡改，解决了<strong>篡改</strong>问题。</li></ol><p><strong>SSL已死，TLS当立：</strong> 严格来说，SSL（Secure Sockets Layer）的所有版本都已因安全漏洞被废弃。现在我们使用的协议是其继任者<strong>TLS（Transport Layer Security）</strong>。目前业界主流是 <strong>TLS 1.2</strong>，而 <strong>TLS 1.3</strong> 因为其更高的性能和更强的安全性，正在迅速普及。面试时，能清晰说出TLS 1.2和1.3握手过程的区别，是巨大的加分项。</p><p><strong>握手的核心目标：</strong> 不要陷入繁杂的步骤细节。TLS握手的核心目标只有<strong>两个</strong>：</p><ol><li><strong>安全地协商出会话密钥：</strong> 客户端和服务器需要商定一个<strong>对称加密</strong>的密钥，用于后续的HTTP报文加密。这个协商过程本身必须是安全的，不能被中间人窃听和篡改。</li><li><strong>验证服务器身份：</strong> 客户端必须确认它正在与之通信的服务器是它声称的那个，而不是一个冒牌货。</li></ol><p><strong>混合加密：</strong> 为什么不直接用非对称加密传数据？因为<strong>非对称加密非常慢</strong>，只适合加密少量数据。而<strong>对称加密快得多</strong>，适合加密大量数据。所以TLS采用了<strong>混合加密</strong>的策略：用<strong>非对称加密</strong>来安全地交换<strong>对称加密的密钥</strong>，然后用这个对称密钥来加密真正的HTTP报文。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    autonumber</span><br><span class="line">    participant C as 客户端</span><br><span class="line">    participant S as 服务器</span><br><span class="line"></span><br><span class="line">    C-&gt;&gt;S: SYN</span><br><span class="line">    S--&gt;&gt;C: SYN, ACK</span><br><span class="line">    C-&gt;&gt;S: ACK</span><br><span class="line"></span><br><span class="line">    Note over C,S: TLS 1.2 握手开始 (2个RTT)</span><br><span class="line"></span><br><span class="line">    C-&gt;&gt;S: 1. ClientHello (支持的加密套件, 随机数C)</span><br><span class="line">    S--&gt;&gt;C: 2. ServerHello (选定的加密套件, 随机数S)</span><br><span class="line">    S--&gt;&gt;C: 3. Certificate (服务器的数字证书)</span><br><span class="line">    S--&gt;&gt;C: 4. ServerHelloDone</span><br><span class="line"></span><br><span class="line">    Note right of C: (客户端验证证书)</span><br><span class="line"></span><br><span class="line">    C-&gt;&gt;S: 5. ClientKeyExchange (用证书公钥加密的预主密钥)</span><br><span class="line">    C-&gt;&gt;S: 6. ChangeCipherSpec</span><br><span class="line">    C-&gt;&gt;S: 7. Finished (加密后的握手摘要)</span><br><span class="line"></span><br><span class="line">    S--&gt;&gt;C: 8. ChangeCipherSpec</span><br><span class="line">    S--&gt;&gt;C: 9. Finished (加密后的握手摘要)</span><br><span class="line"></span><br><span class="line">    Note over C,S: 握手结束,双方已安全地生成了会话密钥</span><br><span class="line"></span><br><span class="line">    C-&gt;&gt;S: 加密的HTTP请求</span><br><span class="line">    S--&gt;&gt;C: 加密的HTTP响应</span><br></pre></td></tr></table></figure><h3 id="生活案例-13"><a href="#生活案例-13" class="headerlink" title="生活案例"></a>生活案例</h3><p>HTTPS握手就像一次高度机密的<strong>线下交易</strong>。</p><ul><li><strong>ClientHello:</strong> 你（客户端）对卖家（服务器）说：“我们来交易吧！我懂得用A、B、C三种暗号（加密套件）。”</li><li><strong>ServerHello &amp; Certificate:</strong> 卖家说：“好的，我们就用A暗号吧。这是我的<strong>身份证和营业执照</strong>（数字证书），由工商局（CA）颁发，你可以去验证真伪。”</li><li><strong>客户端验证证书 &amp; ClientKeyExchange:</strong> 你打电话给工商局验证了执照是真的。然后你把交易的**接头暗语（预主密钥）<strong>写在一张纸条上，放进一个只有卖家用他私钥才能打开的</strong>保险箱（证书公钥加密）**里，交给了卖家。</li><li><strong>双方生成会话密钥 &amp; Finished:</strong> 卖家用私钥打开保险箱，拿到接头暗语。现在，你们双方都用这个暗语推算出了今天交易用的<strong>最终密码本（会话密钥）</strong>。为了确认无误，你们各自把之前的对话内容用这个密码本加密算了个摘要，发给对方验证。</li><li><strong>加密通信：</strong> 验证通过，交易正式开始。你们所有的对话（HTTP报文）都用这个最终密码本加密。</li></ul><h3 id="经典问题-14"><a href="#经典问题-14" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>请简述一下HTTPS的握手过程。TLS 1.3相比于1.2做了哪些核心优化？</p></blockquote><p>HTTPS的核心是其底层的TLS握手过程。我以目前最主流的TLS 1.2为例，其握手过程可以概括为以下几个核心步骤，主要目的是<strong>安全地协商会话密钥</strong>并<strong>验证服务器身份</strong>。</p><p><strong>TLS 1.2 握手流程 (简化版):</strong></p><ol><li><strong>客户端问候 (ClientHello):</strong> 客户端向服务器发送它支持的TLS版本、一组加密套件（包含密钥交换算法、对称加密算法、MAC算法）和一个随机数。</li><li><strong>服务器响应 (ServerHello &amp; Certificate):</strong> 服务器从客户端的加密套件中选择一个双方都支持的，并返回给客户端。同时，服务器会将其<strong>数字证书</strong>和另一个随机数一并发送给客户端。</li><li><strong>客户端验证与密钥交换:</strong><ul><li>客户端首先验证服务器证书的有效性，包括检查签发机构是否受信任、是否过期、域名是否匹配等。</li><li>验证通过后，客户端生成一个**“预主密钥”(Pre-Master Secret)<strong>，然后用证书中的</strong>公钥**对其进行加密，并通过ClientKeyExchange消息发送给服务器。</li></ul></li><li><strong>生成会话密钥与结束:</strong><ul><li>服务器用自己的<strong>私钥</strong>解密ClientKeyExchange消息，获取到预主密钥。</li><li>现在，客户端和服务器都拥有了三个相同的输入：客户端随机数、服务器随机数、预主密钥。它们各自使用相同的算法，将这三个输入混合生成最终的<strong>会话密钥（对称密钥）</strong>。</li><li>最后，双方互发一个Finished消息，将之前所有握手报文的摘要用这个刚生成的会话密钥加密后发送给对方，以验证握手过程没有被篡改。</li></ul></li></ol><p><strong>TLS 1.3 的核心优化：</strong><br>TLS 1.3 对这个过程进行了大刀阔斧的简化，主要目标就是<strong>提升性能和安全性</strong>：</p><ol><li><strong>减少RTT：</strong> TLS 1.3的握手过程从2个RTT（往返时延）缩减到了<strong>1个RTT</strong>。它在ClientHello时就会猜测服务器可能支持的加密参数并发过去，服务器在ServerHello中一次性返回所有需要的信息，大大缩短了连接建立时间。</li><li><strong>更安全的加密套件：</strong> 废除了所有不安全的、过时的加密算法（如RC4, MD5）和密钥交换方式（如静态RSA），只保留了少数几个安全性极高的算法。</li><li><strong>0-RTT模式：</strong> 对于恢复连接，TLS 1.3引入了0-RTT模式，允许客户端在第一个包中就带上加密的应用数据，实现了零延迟的连接恢复，这对于API调用和移动端应用是巨大的性能提升。</li></ol><h2 id="Web攻击"><a href="#Web攻击" class="headerlink" title="Web攻击"></a>Web攻击</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[常见Web攻击] --&gt; B[注入型攻击]</span><br><span class="line">    B --&gt; B1[SQL注入]</span><br><span class="line">    B1 --&gt; B1a[攻击点: 后端数据库查询]</span><br><span class="line">    B1 --&gt; B1b[防御: 参数化查询]</span><br><span class="line">    B --&gt; B2[OS命令注入]</span><br><span class="line">    B2 --&gt; B2a[攻击点: 调用系统命令]</span><br><span class="line">    B2 --&gt; B2b[防御: 严格过滤用户输入]</span><br><span class="line"></span><br><span class="line">    A --&gt; C[跨站攻击]</span><br><span class="line">    C --&gt; C1[跨站脚本]</span><br><span class="line">    C1 --&gt; C1a[攻击点: 浏览器渲染HTML]</span><br><span class="line">    C1 --&gt; C1b[防御: 输入过滤]</span><br><span class="line">    C --&gt; C2[跨站请求伪造]</span><br><span class="line">    C2 --&gt; C2a[攻击点: 浏览器携带Cookie]</span><br><span class="line">    C2 --&gt; C2b[防御: SameSite Cookie]</span><br><span class="line"></span><br><span class="line">    A --&gt; D[会话管理攻击]</span><br><span class="line">    D --&gt; D1[会话劫持]</span><br><span class="line">    D1 --&gt; D1a[攻击点: 窃取会话ID]</span><br><span class="line">    D1 --&gt; D1b[防御: HTTPS, HttpOnly Cookie]</span><br><span class="line">    D --&gt; D2[会话固定]</span><br><span class="line">    D2 --&gt; D2a[攻击点: 强行指定会话ID]</span><br><span class="line">    D2 --&gt; D2b[防御: 登录后立即重置Session ID]</span><br></pre></td></tr></table></figure><h3 id="跨站脚本攻击-XSS"><a href="#跨站脚本攻击-XSS" class="headerlink" title="跨站脚本攻击(XSS)"></a>跨站脚本攻击(XSS)</h3><p><strong>核心思想：</strong> XSS的本质是“<strong>恶意代码注入</strong>”。攻击者设法将恶意的HTML或JavaScript代码，注入到一个受信任的网站中。当其他用户访问这个网站时，这些恶意代码就会在用户的<strong>浏览器</strong>中被执行，从而达到窃取信息、破坏页面的目的。</p><p><strong>攻击对象：</strong> XSS攻击的目标是<strong>用户（的浏览器）</strong>，而不是服务器本身。它利用的是网站对用户的<strong>信任</strong>。</p><p><strong>分类：</strong></p><ol><li><strong>存储型XSS (Stored XSS):</strong> 最危险的一种。恶意代码被<strong>存储在服务器的数据库</strong>中（比如一篇包含<script>标签的博客文章）。每个访问这个页面的用户都会被攻击。</li><li><strong>反射型XSS (Reflected XSS):</strong> 恶意代码存在于<strong>URL</strong>中。攻击者需要诱骗用户点击一个构造好的恶意链接，服务器从URL中获取数据并<strong>不加过滤地</strong>在页面上“反射”出来，导致脚本执行。</li><li><strong>DOM型XSS (DOM-based XSS):</strong> 一种特殊的反射型XSS，其攻击的触发完全在<strong>客户端</strong>发生。恶意代码在URL中，但服务器并未参与，是客户端的JavaScript代码在处理URL时，不慎将恶意代码执行了。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Attacker as 攻击者</span><br><span class="line">    participant Server as 易受攻击的网站 (如: 博客)</span><br><span class="line">    participant Victim as 普通用户</span><br><span class="line">    </span><br><span class="line">    Attacker-&gt;&gt;Server: 1. 发布一篇包含恶意脚本的文章&lt;br&gt;内容: &quot;文章内容...&lt;script&gt;steal_cookie()&lt;/script&gt;&quot;</span><br><span class="line">    Note over Server: 服务器将恶意内容&lt;br&gt;存储到数据库</span><br><span class="line">    </span><br><span class="line">    Victim-&gt;&gt;Server: 2. 请求浏览这篇文章</span><br><span class="line">    Server--&gt;&gt;Victim: 3. 返回包含恶意脚本的HTML页面</span><br><span class="line">    </span><br><span class="line">    Note over Victim: 浏览器解析HTML...</span><br><span class="line">    Victim-&gt;&gt;Victim: 4. &lt;b&gt;执行了恶意脚本!&lt;/b&gt;&lt;br&gt;steal_cookie()函数被调用</span><br><span class="line">    Victim--&gt;&gt;Attacker: 5. 用户的Cookie被发送到攻击者服务器</span><br></pre></td></tr></table></figure><h4 id="生活案例-14"><a href="#生活案例-14" class="headerlink" title="生活案例"></a>生活案例</h4><p>XSS攻击就像是在一个公共的<strong>留言板</strong>上搞破坏。</p><ul><li>你（<strong>攻击者</strong>）没有直接去砸留言板（服务器），而是用一种<strong>隐形墨水</strong>（恶意脚本）在上面写了一句咒语：“凡看到此留言者，钱包自动交给我。”</li><li>当其他路人（<strong>受害者</strong>）过来看留言时，这条用隐形墨水写的咒语在他们眼里突然显形并生效（<strong>浏览器执行脚本</strong>），结果他们的钱包（<strong>Cookie</strong>）就都飞到了你的口袋里。</li></ul><h4 id="经典问题-15"><a href="#经典问题-15" class="headerlink" title="经典问题"></a>经典问题</h4><blockquote><p> 什么是XSS攻击？如何有效防御？</p></blockquote><p>XSS，即跨站脚本攻击，其核心是攻击者将恶意脚本注入到受信任的网页中，当其他用户浏览该网页时，这些脚本在用户的浏览器端被执行，从而窃取用户信息（如Cookie）、或进行其他恶意操作。</p><p>防御XSS的核心原则是：<strong>永远不要信任用户的任何输入，并对所有输出到前端页面的数据进行适当的转义或过滤。</strong></p><p>具体的防御手段主要有以下几种：</p><ol><li><strong>输入过滤：</strong> 在数据存入数据库之前，对用户的输入进行校验，过滤掉潜在的恶意代码。但这通常不被视为主要防御手段，因为可能会误伤正常输入，且难以覆盖所有攻击模式。</li><li><strong>输出转义（最核心的防御手段）：</strong> 当服务器端将数据显示到HTML页面上时，对所有特殊字符进行HTML实体转义。比如，将&lt;转义为&lt;，&gt;转义为&gt;。这样一来，即使用户输入了<script>标签，它在浏览器中也只会被当作普通文本显示出来，而不会被当作代码执行。现代的模板引擎（如Vue, React）默认都会进行这种输出转义。</li><li><strong>设置HttpOnly Cookie：</strong> 如我们之前所学，这是防止XSS攻击者窃取会话Cookie的釜底抽薪之计。即使脚本被执行，它也无法通过document.cookie读到关键的会话信息。</li><li><strong>内容安全策略（CSP - Content Security Policy）：</strong> 这是更高级的纵深防御手段。通过在HTTP响应头中设置Content-Security-Policy，我们可以精确地告诉浏览器，该页面只允许加载和执行来自特定来源的脚本。这样即使攻击者成功注入了脚本，只要其来源不被信任，浏览器就会拒绝执行它。</li></ol><h3 id="跨站请求伪造攻击-CSRF"><a href="#跨站请求伪造攻击-CSRF" class="headerlink" title="跨站请求伪造攻击(CSRF)"></a>跨站请求伪造攻击(CSRF)</h3><p><strong>核心思想：</strong> CSRF的本质是<strong>利用了浏览器在跨域请求时会自动携带目标站点Cookie的特性</strong>，来冒用用户的身份，在用户不知情的情况下，执行非用户本意的操作。</p><p><strong>攻击对象：</strong> CSRF攻击的目标是<strong>服务器</strong>，它利用的是服务器对用户的<strong>信任</strong>（通过Cookie来认证）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant User as 已登录银行网站的用户</span><br><span class="line">    participant Bank as 银行网站 (bank.com)</span><br><span class="line">    participant Attacker as 恶意网站 (hacker.com)</span><br><span class="line"></span><br><span class="line">    User-&gt;&gt;Bank: 1. 正常登录, 浏览器保存了bank.com的Cookie</span><br><span class="line">    </span><br><span class="line">    Note over User, Attacker: 用户被诱导访问恶意网站</span><br><span class="line">    User-&gt;&gt;Attacker: 2. GET /index.html</span><br><span class="line">    Attacker--&gt;&gt;User: 3. 返回页面,其中包含&lt;img src=&quot;https://bank.com/transfer?to=hacker&amp;amount=10000&quot;&gt;</span><br><span class="line"></span><br><span class="line">    Note over User, Bank: 浏览器自动加载图片, 向银行发起请求</span><br><span class="line">    User-&gt;&gt;Bank: 4. GET /transfer?to=hacker...&lt;br&gt;&lt;b&gt;自动携带了bank.com的Cookie!&lt;/b&gt;</span><br><span class="line">    </span><br><span class="line">    Note over Bank: 服务器验证Cookie, 认为是合法用户的操作</span><br><span class="line">    Bank-&gt;&gt;Bank: 5. &lt;b&gt;执行转账操作!&lt;/b&gt;</span><br></pre></td></tr></table></figure><h4 id="生活案例-15"><a href="#生活案例-15" class="headerlink" title="生活案例"></a>生活案例</h4><p>CSRF攻击就像是，你（<strong>用户</strong>）已经跟银行（<strong>服务器</strong>）出示过身份证（<strong>登录并获得Cookie</strong>），银行认识你了。这时，一个骗子（<strong>攻击者</strong>）递给你一张看起来无害的<strong>传单</strong>（恶意网站），传单背面用极小的字写着一张“授权转账1万元给我”的<strong>委托书</strong>，并伪造了你的签名。你没注意，接过了传单。银行的摄像头（<strong>浏览器</strong>）看到了这张委托书，并且因为认识你（<strong>自动携带了Cookie</strong>），就误以为这是你的真实意愿，于是把钱转走了。</p><h4 id="经典问题-16"><a href="#经典问题-16" class="headerlink" title="经典问题"></a>经典问题</h4><blockquote><p>什么是CSRF攻击？它的攻击原理是什么？有哪些防御方法？</p></blockquote><p>CSRF，即跨站请求伪造，是一种利用用户已登录的身份，在用户不知情的情况下，构造请求来执行非本意操作的攻击。</p><p><strong>攻击原理：</strong> CSRF的核心是利用了浏览器的身份验证机制，特别是Cookie的自动发送机制。攻击流程通常是：</p><ol><li>用户登录了受信任的网站A，浏览器保存了A网站的Cookie。</li><li>用户在没有退出A网站的情况下，被诱导访问了恶意的网站B。</li><li>网站B向网站A发起一个请求（比如通过一个隐藏的<img>标签或表单）。</li><li>浏览器在发送这个请求时，会自动带上网站A的Cookie。</li><li>网站A的服务器收到请求后，验证Cookie是合法的，误以为是用户本人的操作，于是执行了该请求（比如转账、修改密码等）。</li></ol><p><strong>防御方法：</strong> 防御CSRF的关键在于，如何验证一个请求确实是用户本人在网站内部主动发起的，而不是来自第三方网站的“伪造”。主要方法有：</p><ol><li><strong>验证Referer头部：</strong> 检查HTTP请求的Referer头部，确保请求来自合法的源域名。这是一种简单的方法，但Referer可以被客户端伪造，所以并非完全可靠。</li><li><strong>使用Anti-CSRF Token：</strong> 这是最常用和最可靠的方法。服务器在渲染表单时，生成一个随机的、不可预测的Token，并将其同时放在用户的Session和表单的一个隐藏字段中。当用户提交表单时，服务器会验证Session中的Token和表单提交的Token是否一致。由于攻击者无法获取到这个随机Token，因此无法成功伪造请求。</li><li><strong>使用SameSite Cookie属性：</strong> 这是从协议层面提供的更现代、更根本的防御手段。通过将关键Cookie设置为SameSite=Strict或SameSite=Lax，可以指示浏览器在跨站请求中不发送该Cookie，从而直接切断CSRF的攻击链。这是目前推荐的最佳实践。</li></ol>]]></content>
    
    
    <summary type="html">一份人人都能看懂的HTTP学习笔记,从基础概念到实际应用,通俗易懂,适合初学者和有经验的开发者。包含HTTP请求响应流程、无状态协议、Cookie等核心知识点,帮助你快速掌握HTTP的精髓。</summary>
    
    
    
    <category term="网站" scheme="https://www.wangwangit.com/categories/%E7%BD%91%E7%AB%99/"/>
    
    
    <category term="PDF" scheme="https://www.wangwangit.com/tags/PDF/"/>
    
  </entry>
  
  <entry>
    <title>关于个人微信机器人，我把我知道的都写在了这里</title>
    <link href="https://www.wangwangit.com/%E5%85%B3%E4%BA%8E%E4%B8%AA%E4%BA%BA%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%8C%E6%88%91%E6%8A%8A%E6%88%91%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%86%99%E5%9C%A8%E4%BA%86%E8%BF%99%E9%87%8C/"/>
    <id>https://www.wangwangit.com/%E5%85%B3%E4%BA%8E%E4%B8%AA%E4%BA%BA%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%8C%E6%88%91%E6%8A%8A%E6%88%91%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%86%99%E5%9C%A8%E4%BA%86%E8%BF%99%E9%87%8C/</id>
    <published>2025-07-20T22:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.763Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.996007.icu/file/1752494828621_20250714200701238.png" alt="ChatGPT Image 2025年7月14日 20_06_53"></p><p>前几天，我分享了一篇关于实现企业微信机器人的文章，反响很不错。同时我也注意到，在评论和私信中，大家的需求非常明确：相比于企业场景，更多人渴望能直接在个人微信号上实现自动化，打造一个真正属于自己的智能助理。</p><p>理解这份期待，所以今天，我将全面地介绍当前实现<strong>微信个人号机器人</strong>的各类技术方案。</p><p>在开始之前，我要说一个注意事项：与企业微信不同，腾讯官方从未为个人微信号提供过任何公开的API。这意味着，我们接下来要探讨的所有非官方技术路径，都或多或少地游走在平台规则的边缘，并伴随着从功能限制到账号封禁不等的风险。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>先给大家分享一下我正在用方案吧!我目前主要用的是windows hook的方案!<strong>安全问题请自己斟酌,请用小号测试!</strong></p><blockquote><p>文件地址: <a href="https://ali.wangwangit.com/%F0%9F%91%80%E5%88%86%E4%BA%AB%E4%B8%93%E7%94%A8/wx.7z">https://ali.wangwangit.com/%F0%9F%91%80%E5%88%86%E4%BA%AB%E4%B8%93%E7%94%A8/wx.7z</a></p></blockquote><p>1.安装文件中对应版本的微信,并且打开,如下图页面.</p><p>2.在文件目录打开cmd窗口,执行对应的命令,返回Successfully,表明成功</p><p>3.下面地址可查看对应的API,不过我测试有一些API无法使用! 接收消息需要调用接口设置hook地址!</p><blockquote><p><a href="https://github.com/ttttupup/wxhelper/blob/main/doc/3.9.5.81.md">https://github.com/ttttupup/wxhelper/blob/main/doc/3.9.5.81.md</a></p></blockquote><p><img src="https://img.996007.icu/file/1752492431210_20250714192702116.png" alt="image-20250714192702013"></p><p><img src="https://img.996007.icu/file/1752493037448_20250714193704889.png" alt="image-20250714193704797"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="1-官方路径：企业微信机器人"><a href="#1-官方路径：企业微信机器人" class="headerlink" title="1. 官方路径：企业微信机器人"></a>1. 官方路径：企业微信机器人</h3><p>尽管我们的焦点是个人号，但任何全面的讨论都绕不开官方提供的唯一合规方案——企业微信机器人。了解它的能力边界，有助于我们理解为什么开发者们会去探索非官方路径。</p><blockquote><p>教程地址: <a href="https://developer.work.weixin.qq.com/document/path/91770">https://developer.work.weixin.qq.com/document/path/91770</a></p></blockquote><ul><li><p><strong>实现原理：</strong> 基于Webhook机制。管理员在企业微信群内创建机器人后，会得到一个专属的Webhook URL。任何应用只需向此URL发送一个符合规范的HTTP POST请求，就能将消息推送到群里。其实现过程简单直接，你可以在此查阅完整的进行实践。</p></li><li><p><strong>核心限制：</strong> 企业微信机器人的本质是一个<strong>单向的通知工具</strong>。它无法读取群内消息，不能主动私聊或添加好友，其所有行为都局限在指定群聊内，被动地等待指令。</p></li></ul><p><img src="https://img.996007.icu/file/1752491776813_20250714191606758.png" alt="image-20250714191559616"></p><p>在手机企业微信群聊中,添加机器人,即可获得Webhook地址!后续就可以在微信群接收到群消息了!</p><p><img src="https://img.996007.icu/file/1752491863785_20250714191730936.png" alt="image-20250714191730707"></p><p><img src="https://img.996007.icu/file/1752491940961_20250714191855180.png" alt="image-20250714191855123"></p><p><strong>结论：</strong> 如果你的需求是系统告警、应用通知等面向内部的、无交互的场景，企业微信是零风险且功能强大的不二之选。但若想实现更动态、更具交互性的个人助理，我们就必须转向非官方的解决方案。</p><h3 id="2-非官方技术方案：四条不同的探索路径"><a href="#2-非官方技术方案：四条不同的探索路径" class="headerlink" title="2. 非官方技术方案：四条不同的探索路径"></a>2. 非官方技术方案：四条不同的探索路径</h3><p>以下是社区经过多年探索后，沉淀下来的四种主流非官方技术方案。</p><h4 id="2-1-网页版API-Web-API-已失效的历史方案"><a href="#2-1-网页版API-Web-API-已失效的历史方案" class="headerlink" title="2.1 网页版API (Web API) - 已失效的历史方案"></a>2.1 网页版API (Web API) - 已失效的历史方案</h4><p>这是最早、也曾是最流行的实现方式，许多经典项目（如Python的<code>ItChat</code>、<code>wxpy</code>）都基于此构建。</p><blockquote><p>github地址: <a href="https://github.com/littlecodersh/ItChat">https://github.com/littlecodersh/ItChat</a></p></blockquote><ul><li><strong>工作机制：</strong> 通过程序模拟浏览器登录网页版微信（web.wechat.com），然后调用其基于HTTP的API来收发消息和管理联系人。</li><li><strong>当前状态：</strong> <strong>基本失效</strong>。自2017年起，微信官方已不再为新注册的账号提供网页版登录入口。绝大多数存量账号也已无法登录。因此，该方案已不具备可行性，仅作为技术发展的历史背景供了解。任何新项目都不应再考虑此路径。</li></ul><h4 id="2-2-协议模拟-Protocol-Simulation"><a href="#2-2-协议模拟-Protocol-Simulation" class="headerlink" title="2.2 协议模拟 (Protocol Simulation)"></a>2.2 协议模拟 (Protocol Simulation)</h4><p>随着网页版API的落幕，此方案成为当前功能最强大的主流选择。</p><ul><li><strong>工作机制：</strong> 通过逆向工程破解微信某个原生客户端（主要是iPad或PC版）与服务器之间的私有通信协议。程序通过模拟一个合法的客户端，直接与微信服务器进行数据交互。</li><li><strong>优点：</strong> 功能完备，可实现几乎所有原生功能；可后台静默运行；不强依赖于特定客户端版本。</li><li><strong>缺点与风险：</strong> 技术壁垒极高，个人开发者难以维护；稳定服务通常需要付费购买<code>Token</code>；存在中等程度的封号风险，异常行为可能被平台风控系统捕获。</li></ul><h4 id="2-3-客户端Hook-Client-Hooking"><a href="#2-3-客户端Hook-Client-Hooking" class="headerlink" title="2.3 客户端Hook (Client Hooking)"></a>2.3 客户端Hook (Client Hooking)</h4><p>这是一种更为激进的、直接作用于微信客户端的方案。</p><ul><li><strong>工作机制：</strong> 在PC端，通过DLL注入等技术侵入正在运行的微信进程，直接调用其内存中的内部函数来实现消息收发等控制。</li><li><strong>优点：</strong> 功能同样强大，甚至能实现防撤回、多开等突破客户端限制的功能。</li><li><strong>缺点与风险：</strong> <strong>稳定性极差</strong>，强依赖于特定的微信客户端版本，一旦微信更新，立即失效；<strong>封号风险最高</strong>，修改客户端运行时行为是平台严厉打击的对象；存在未知的安全隐患。</li></ul><h4 id="2-4-UI自动化-UI-Automation"><a href="#2-4-UI自动化-UI-Automation" class="headerlink" title="2.4 UI自动化 (UI Automation)"></a>2.4 UI自动化 (UI Automation)</h4><p>这是一种“曲线救国”的方案，它不触及微信的任何代码或协议。</p><ul><li><strong>工作机制：</strong> 利用操作系统层面的辅助功能（如Android的无障碍服务），编写脚本来模拟人的手指在屏幕上进行点击、输入和滑动等操作。</li><li><strong>优点：</strong> <strong>封号风险最低</strong>，因为其行为模式与真人操作无异；对微信版本更新不敏感。</li><li><strong>缺点：</strong> 效率和可靠性较低；必须保持微信在前台运行；功能受限于屏幕上可见的UI元素。</li></ul><h3 id="3-技术方案全景对比"><a href="#3-技术方案全景对比" class="headerlink" title="3. 技术方案全景对比"></a>3. 技术方案全景对比</h3><p>为了帮你更直观地做出判断，我将所有方案的核心特性总结在下表中：</p><table><thead><tr><th align="left">实现方案</th><th align="left">实现原理</th><th align="left">功能完备性</th><th align="left">稳定性&#x2F;维护成本</th><th align="left">风险等级</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong>企业微信</strong></td><td align="left">官方Webhook API</td><td align="left">有限（仅通知）</td><td align="left">极高 &#x2F; 官方维护</td><td align="left"><strong>无</strong></td><td align="left">企业内部通知、系统集成</td></tr><tr><td align="left"><strong>协议模拟</strong></td><td align="left">逆向私有网络协议</td><td align="left">高</td><td align="left">较高 &#x2F; 依赖服务商</td><td align="left"><strong>中</strong></td><td align="left">需要完整功能、可后台运行的机器人</td></tr><tr><td align="left"><strong>客户端Hook</strong></td><td align="left">注入DLL，修改进程内存</td><td align="left">极高</td><td align="left">极低 &#x2F; 强依赖版本</td><td align="left"><strong>高</strong></td><td align="left">短期技术验证、高风险功能实验</td></tr><tr><td align="left"><strong>UI自动化</strong></td><td align="left">模拟屏幕点击与输入</td><td align="left">中等</td><td align="left">中等 &#x2F; 依赖UI布局</td><td align="left"><strong>低</strong></td><td align="left">简单的自动回复、轻量级自动化任务</td></tr><tr><td align="left"><strong>网页版API</strong></td><td align="left">模拟浏览器HTTP API</td><td align="left">有限</td><td align="left"><strong>已失效</strong></td><td align="left"><strong>N&#x2F;A</strong></td><td align="left">历史项目研究</td></tr></tbody></table><h3 id="4-开源社区的框架与工具"><a href="#4-开源社区的框架与工具" class="headerlink" title="4. 开源社区的框架与工具"></a>4. 开源社区的框架与工具</h3><ul><li><strong>Wechaty:</strong> 当前最成熟的机器人框架。其核心的<strong>Puppet（傀儡）架构</strong>是应对微信多变环境的绝佳设计。开发者可以编写一套业务逻辑，通过切换不同的Puppet插件来适配不同的底层实现（无论是付费的协议模拟，还是免费但高风险的Hook方案），极大地提升了项目的适应性和生命周期。</li><li><strong>chatgpt-on-wechat:</strong> 一个现象级的应用项目，它将大型语言模型与微信打通，并灵活支持多种后端渠道，是快速体验AI聊天机器人的优秀选择。</li><li><strong>其他项目:</strong> 社区中还有许多基于特定方案的开源项目（如基于Hook的<code>ComWeChatRobot</code>），它们通常开箱即用，但使用者必须清醒地认识到其背后方案所固有的风险和不稳定性。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在个人微信机器人这个领域，不存在完美的“银弹”，所有的选择都是在功能、成本、稳定性与风险之间的权衡。</p><ul><li><strong>追求安全合规：</strong> <strong>企业微信</strong>是唯一选择。</li><li><strong>追求强大功能与相对稳定：</strong> <strong>协议模拟</strong>是当前最现实的路径。建议使用 <code>Wechaty</code> 框架，并准备为稳定的协议服务支付费用。使用小号进行充分测试是必不可少的步骤。</li><li><strong>追求低风险的简单自动化：</strong> <strong>UI自动化</strong>方案值得尝试，尤其适合个人娱乐或轻量级任务。</li><li><strong>仅为技术探索：</strong> <strong>客户端Hook</strong>方案可用于短期实验，但绝不应投入到任何有价值的账号或严肃应用中。</li></ul>]]></content>
    
    
    <summary type="html">前几天，我分享了一篇关于实现企业微信机器人的文章，反响很不错。同时我也注意到，在评论和私信中，大家的需求非常明确：相比于企业场景，更多人渴望能直接在个人微信号上实现自动化，打造一个真正属于自己的智能助理。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="工具" scheme="https://www.wangwangit.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="导航站" scheme="https://www.wangwangit.com/tags/%E5%AF%BC%E8%88%AA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>为什么你的同事从不迟到？一文看懂虚拟定位的&quot;黑科技&quot;</title>
    <link href="https://www.wangwangit.com/%E8%99%9A%E6%8B%9F%E5%AE%9A%E4%BD%8D%E5%A4%A7%E6%8F%AD%E7%A7%98%EF%BC%9A%E9%82%A3%E4%BA%9B%E7%8E%AF%E7%90%83%E6%97%85%E8%A1%8C%E5%AE%B6%EF%BC%8C%E5%85%B6%E5%AE%9E%E4%B8%80%E6%AD%A5%E9%83%BD%E6%B2%A1%E5%87%BA%E9%97%A8/"/>
    <id>https://www.wangwangit.com/%E8%99%9A%E6%8B%9F%E5%AE%9A%E4%BD%8D%E5%A4%A7%E6%8F%AD%E7%A7%98%EF%BC%9A%E9%82%A3%E4%BA%9B%E7%8E%AF%E7%90%83%E6%97%85%E8%A1%8C%E5%AE%B6%EF%BC%8C%E5%85%B6%E5%AE%9E%E4%B8%80%E6%AD%A5%E9%83%BD%E6%B2%A1%E5%87%BA%E9%97%A8/</id>
    <published>2025-07-20T22:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.767Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.996007.icu/file/1753095125559_20250721185153546.png" alt="ip"></p><p>前几天刷短视频，看到一个很有意思的现象：</p><p>一个博主上午还在冰岛拍极光，下午就”飞”到了非洲看大象，晚上又出现在日本泡温泉。而且都标着”刚刚发布”，时间差不超过10分钟。</p><p>我寻思，这人是开了私人飞机，还是练成了瞬移神功？</p><p>或者你身边是不是也有这样的同事：天天神龙见首不见尾，但考勤打卡从来没迟到过，定位总是准确无误地显示在办公室。</p><p>别纳闷了，他们可能只是掌握了一门”黑科技”——<strong>虚拟定位</strong>。</p><h2 id="虚拟定位到底是啥？"><a href="#虚拟定位到底是啥？" class="headerlink" title="虚拟定位到底是啥？"></a>虚拟定位到底是啥？</h2><p>说白了，就是教你的手机”说谎”。</p><p>你人在家里葛优瘫，但手机却能装作你在巴黎埃菲尔铁塔下发朋友圈。这就像给手机化了个妆，让各种App都认不出你的真实位置。</p><p>要搞明白虚拟定位的原理，得先了解手机平时是怎么知道自己在哪的。</p><p><strong>先打个预防针：</strong></p><p>我分享这个技术，纯粹是为了满足大家的好奇心。但作为一个有良心的科普博主，必须先说清楚：</p><p><strong>千万别拿这玩意儿干违法乱纪的事</strong>，真的得不偿失：</p><ul><li><strong>工作上：</strong> 现在的考勤系统都是老狐狸，为了省几分钟通勤时间丢了饭碗，太不值</li><li><strong>娱乐上：</strong> 游戏公司对作弊零容忍，封号不留情，辛苦练的角色说没就没</li><li><strong>法律上：</strong> 要是用来搞诈骗什么的，那就不是开玩笑了，是要蹲号子的</li></ul><p>咱们就当个科普知识学学，图个乐呵就行。</p><h2 id="虚拟定位的几种”套路”"><a href="#虚拟定位的几种”套路”" class="headerlink" title="虚拟定位的几种”套路”"></a>虚拟定位的几种”套路”</h2><p>想让手机撒谎，得先摸清它平时是怎么说实话的。</p><table><thead><tr><th>定位方式</th><th>工作原理</th><th>准确度</th><th>如何”伪装”</th><th>主要应用场景</th></tr></thead><tbody><tr><td><strong>GPS定位</strong></td><td>接收卫星信号计算位置</td><td>很准（5-10米）</td><td>发射假GPS信号</td><td>导航、运动软件、位置游戏</td></tr><tr><td><strong>IP定位</strong></td><td>根据网络IP判断大概位置</td><td>不太准（城市级）</td><td>用代理</td><td>视频网站、广告推送</td></tr><tr><td><strong>WiFi&#x2F;基站定位</strong></td><td>根据附近WiFi和手机塔定位</td><td>一般准（几十到几百米）</td><td>配合GPS欺骗</td><td>室内导航、辅助定位</td></tr></tbody></table><p>搞清楚了定位原理，”骗术”也就呼之欲出了：</p><p><strong>第一招：GPS信号欺骗</strong><br>这招叫”声东击西”。卫星信号从太空传到地面，到你手机这里已经很微弱了。虚拟定位设备就在你手机旁边发射更强的假GPS信号。你的手机秉承”谁声音大听谁的”原则，自然就被骗了。</p><p><strong>第二招：网络地址伪装</strong><br>这招叫”狸猫换太子”。你连上代理后，所有网络请求都先绕到别的国家的服务器，再转发出去。网站看到的只是那台服务器的地址，自然以为你在那个国家。比如抖音上的IP,就是基于这种方式修改的!</p><p><img src="https://img.996007.icu/file/1753094909013_20250721184816319.png" alt="image-20250721184816230"></p><h2 id="安卓手机的玩法"><a href="#安卓手机的玩法" class="headerlink" title="安卓手机的玩法"></a>安卓手机的玩法</h2><p>安卓系统比较开放，从新手到高手都有对应的方法。</p><h3 id="1-系统自带的模拟定位"><a href="#1-系统自带的模拟定位" class="headerlink" title="1. 系统自带的模拟定位"></a>1. 系统自带的模拟定位</h3><p><strong>操作很简单：</strong></p><ul><li>狂点”版本号”7下，开启开发者模式（感觉像在输入秘籍）</li><li>在开发者选项里找”模拟位置应用”</li><li>选一个虚拟定位App就行</li></ul><p><img src="https://img.996007.icu/file/1753094543850_20250721184218939.png" alt="image-20250721184218871"></p><p><img src="https://img.996007.icu/file/1753094555684_20250721184231591.png" alt="image-20250721184231495"></p><p><strong>好用的工具：</strong></p><ul><li><strong>Fake GPS Location：</strong> 新手友好，地图上想点哪点哪</li><li><strong>GPS JoyStick：</strong> 功能强大，还能设计移动路线</li></ul><p><strong>优点：</strong> 官方认可，操作简单<br><strong>缺点：</strong> 容易被App识破</p><p>我们以<strong>Fake GPS Location</strong>为例来测试一下! 软件请前往下面地址下载</p><blockquote><p>地址: <a href="https://ali.wangwangit.com/%F0%9F%91%80%E5%88%86%E4%BA%AB%E4%B8%93%E7%94%A8/Fake%20GPS.apk">https://ali.wangwangit.com/%F0%9F%91%80%E5%88%86%E4%BA%AB%E4%B8%93%E7%94%A8/Fake%20GPS.apk</a></p></blockquote><p>打开软件,按下图设置Map Type,然后点击<code>Go to</code>设置一个地区的经纬度!或则拖动页面上的箭头也可以!</p><p><img src="https://img.996007.icu/file/1753094356411_20250721183902239.png" alt="image-20250721183855133"></p><p>然后,你打开高德地图,就会发现位置已经跑到别的地方了!</p><p><img src="https://img.996007.icu/file/1753094628124_20250721184335741.png" alt="image-20250721184335489"></p><h3 id="2-虚拟空间大法"><a href="#2-虚拟空间大法" class="headerlink" title="2. 虚拟空间大法"></a>2. 虚拟空间大法</h3><p>简单说就是在手机里再造一个”小手机”，专门用来运行需要虚拟定位的App。就像俄罗斯套娃一样。</p><p><strong>代表工具：</strong> VirtualXposed、Parallel Space、虚拟大师等!</p><p><img src="https://img.996007.icu/file/1753094754410_20250721184550737.png" alt="image-20250721184550678"></p><h3 id="3-Hook技术"><a href="#3-Hook技术" class="headerlink" title="3. Hook技术"></a>3. Hook技术</h3><p>这是最高级的玩法，通过在系统底层”动手脚”，让App压根察觉不到异常。相当于给手机做了个完美整容手术。</p><p><strong>好处：</strong> 几乎检测不出来<br><strong>坏处：</strong> 技术门槛高，一般人玩不转</p><h3 id="4-Root方式"><a href="#4-Root方式" class="headerlink" title="4. Root方式"></a>4. Root方式</h3><p>Root相当于获得了手机的”管理员权限”，理论上可以为所欲为。</p><p><strong>但风险太大了：</strong></p><ul><li>手机安全防护被破坏</li><li>银行App直接罢工不干了</li><li>保修服务说拜拜</li><li>搞砸了手机变砖头</li></ul><p>所以现在基本没人走这条路了。</p><h2 id="iPhone的”曲线救国”"><a href="#iPhone的”曲线救国”" class="headerlink" title="iPhone的”曲线救国”"></a>iPhone的”曲线救国”</h2><p>苹果管得严，iPhone只能借助外力：</p><h3 id="主要方法：电脑软件辅助"><a href="#主要方法：电脑软件辅助" class="headerlink" title="主要方法：电脑软件辅助"></a>主要方法：电脑软件辅助</h3><p>由于iOS把门看得死死的，只能通过数据线连电脑，用专门的软件往iPhone里”灌输”假位置信息。</p><p><strong>常用工具：</strong></p><ul><li>爱思助手</li><li>iTools</li><li>AnyGo</li></ul><p><strong>使用流程：</strong></p><ol><li>电脑装好软件</li><li>数据线连iPhone</li><li>软件里选位置</li><li>同步到手机</li></ol><h3 id="⚠️-风险提醒"><a href="#⚠️-风险提醒" class="headerlink" title="⚠️ 风险提醒"></a>⚠️ 风险提醒</h3><p>用这些第三方工具有安全隐患：</p><ul><li>Apple ID可能被盗</li><li>个人信息泄露</li><li>设备被植入病毒</li></ul><p>所以要三思而后行。</p><h2 id="魔高一尺，道高一丈"><a href="#魔高一尺，道高一丈" class="headerlink" title="魔高一尺，道高一丈"></a>魔高一尺，道高一丈</h2><p>虚拟定位在进步，各大平台的反制技术也没闲着。这就是一场没完没了的”猫鼠游戏”。</p><h3 id="App的检测手段"><a href="#App的检测手段" class="headerlink" title="App的检测手段"></a>App的检测手段</h3><ol><li><strong>直接检查：</strong> 看系统有没有开启模拟位置</li><li><strong>环境检测：</strong> 检查是否启用了开发者模式</li><li><strong>权限分析：</strong> 判断设备是否被破解</li></ol><h3 id="服务器的”火眼金睛”"><a href="#服务器的”火眼金睛”" class="headerlink" title="服务器的”火眼金睛”"></a>服务器的”火眼金睛”</h3><p>现在的检测系统越来越聪明，不光看数据，还要分析行为：</p><ol><li><strong>瞬移识别：</strong> 1分钟从上海到北京？当我是傻子吗？</li><li><strong>数据异常分析：</strong> 真实GPS会有小幅波动，太完美的数据反而可疑</li><li><strong>轨迹合理性：</strong> 你的移动路径和速度符合物理规律吗？</li></ol><p>举个例子，我有个朋友想用虚拟定位”环游世界”，结果被系统识破了。因为他设置的路线是从北京直接”飞”到纽约，中间没有任何过渡，系统一看就知道有问题。</p><h2 id="结语：技术向善，用之有度"><a href="#结语：技术向善，用之有度" class="headerlink" title="结语：技术向善，用之有度"></a>结语：技术向善，用之有度</h2><p>虚拟定位技术本身没有对错，关键在于怎么用。</p><p>了解这些知识，不是为了去钻空子，而是为了在这个数字化时代更好地保护自己，看透那些看似高大上的”数字假象”。</p><p>我始终相信一句话：<strong>技术可以复制，但人生体验无法伪造</strong>。</p><p>与其费尽心思制造虚假的”环球旅行”，不如踏踏实实规划一次真正的说走就走。毕竟，真实体验带来的快乐和成长，是任何技术都无法替代的。</p><p>做个有趣的人，也要做个诚实的人。这样的人生，才真正值得”定位”。</p>]]></content>
    
    
    <summary type="html">或者你身边是不是也有这样的同事：天天神龙见首不见尾，但考勤打卡从来没迟到过，定位总是准确无误地显示在办公室。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="虚拟定位" scheme="https://www.wangwangit.com/tags/%E8%99%9A%E6%8B%9F%E5%AE%9A%E4%BD%8D/"/>
    
  </entry>
  
  <entry>
    <title>这是一份让你彻底告别密码混乱的自救指南</title>
    <link href="https://www.wangwangit.com/%E4%B8%80%E4%BB%BD%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E5%91%8A%E5%88%AB%E5%AF%86%E7%A0%81%E6%B7%B7%E4%B9%B1%E7%9A%84%E8%87%AA%E6%95%91%E6%8C%87%E5%8D%97/"/>
    <id>https://www.wangwangit.com/%E4%B8%80%E4%BB%BD%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E5%91%8A%E5%88%AB%E5%AF%86%E7%A0%81%E6%B7%B7%E4%B9%B1%E7%9A%84%E8%87%AA%E6%95%91%E6%8C%87%E5%8D%97/</id>
    <published>2025-07-17T22:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.761Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.wangwangit.com/file/1751890725660_ChatGPT_Image_2025%E5%B9%B47%E6%9C%887%E6%97%A5_20_18_18.png" alt="ChatGPT Image 2025年7月7日 20_18_18.png"></p><p>在日常生活中，越来越多的网站和应用要求我们创建账号和密码。多数普通用户选择使用<strong>浏览器内置的密码</strong>管理功能,或者<strong>全平台用同一个密码</strong>，这种方式虽然便捷，却会存在明显的安全隐患和同步不便的问题。</p><p>实际上我以前也是采用的上面的方案,但是,在看到过各种密码泄露,账号被盗的案例,我开始研究更好的密码管理方案!</p><p>我的需求也很简单!</p><ol><li>能够帮我生成密码,毕竟每次想密码都让人头疼!</li><li>能够多平台同步密码,并且保证同步过程中的安全问题!</li><li>能够免费使用或者自建更佳!</li><li>支持APP密码填充,支持一些重要信息的保存!</li></ol><p>经过很长一段时间的研究,我现在选择了<strong>Bitwarden 官方+Google Authenticator</strong>的密码管理方案!这篇文章并非泛泛而谈，而是我个人完整的决策路径和实践总结。我将带你审视我放弃了什么、选择了什么、以及为什么这么选。当然，技术方案没有绝对的“最好”，只有“最适合”。我非常期待在评论区看到你的见解与不同的方案。</p><blockquote><p>你可能对自托管充满兴趣，但由于我个人并未将其作为日常方案深入实践，本文便不展开具体的部署教程，以免班门弄斧。我的初衷是分享一个经过自己长期检验、稳定可靠的方案。如果你确实具备技术实力并希望尝试，社区中广受好评的 <strong>Vaultwarden</strong> 是一个绝佳的出发点，它的资源消耗远低于官方版本。<br>Bitwadren官网地址: <a href="https://bitwarden.com/">https://bitwarden.com/</a><br>Bitwadren github地址: <a href="https://github.com/bitwarden/server">https://github.com/bitwarden/server</a><br>Vaultwarden github地址: <a href="https://github.com/dani-garcia/vaultwarden">https://github.com/dani-garcia/vaultwarden</a></p></blockquote><h3 id="1-为什么必须放弃浏览器的密码管理器"><a href="#1-为什么必须放弃浏览器的密码管理器" class="headerlink" title="1. 为什么必须放弃浏览器的密码管理器"></a>1. 为什么必须放弃浏览器的密码管理器</h3><p>几乎所有的现代网络浏览器，如Chrome、Safari、Firefox和Edge，都内置了密码保存功能。它足够便捷，以至于许多人默认将其作为主要的密码管理工具。然而，这种便利性是以牺牲关键的安全性和功能性为代价的。将您的数字钥匙托付给浏览器，无异于将保险箱的钥匙挂在门把手上。</p><ul><li><p><strong>致命缺陷：缺少“零知识”架构</strong><br>“零知识”意味着服务商（如Google、Apple）对你存储的内容一无所知，也无法访问。专业的密码管理器就像一个只负责保管保险箱，但绝不持有钥匙副本的公司。而浏览器服务商并不遵循此原则，技术上，它们<strong>有能力</strong>查看你保存的密码。</p></li><li><p><strong>功能与平台的双重局限</strong><br>如果你在Windows上用Chrome，在iPhone上用Safari，密码同步就是一场灾难。它无法帮你登录电脑软件或手机App，更没有安全的方式与家人共享账号。这些功能上的残缺，在日常使用中会制造无数个不大不小的麻烦。</p></li><li><p><strong>物理访问的巨大风险</strong><br>任何能接触到你未锁屏电脑的人，都能轻易进入浏览器设置，将你保存的所有密码一键导出，全程无需再次验证。这与专业管理器每次访问都需要独立主密码的设防级别，有天壤之别。</p></li></ul><p>为了更直观地展示差距，这张表格一目了然：</p><table><thead><tr><th align="left">特性</th><th align="left">浏览器管理器 (如 Chrome, Safari)</th><th align="left">专业密码管理器 (如 Bitwarden)</th></tr></thead><tbody><tr><td align="left"><strong>零知识架构</strong></td><td align="left">❌ 否 (服务商可访问数据)</td><td align="left">✅ 是 (只有用户能访问数据)</td></tr><tr><td align="left"><strong>端到端加密</strong></td><td align="left">⚠️ 有限 (传输中加密，服务器上可能解密)</td><td align="left">✅ 是 (数据离开设备前就已加密)</td></tr><tr><td align="left"><strong>跨平台&#x2F;浏览器同步</strong></td><td align="left">❌ 差 (通常锁定在单一浏览器生态)</td><td align="left">✅ 优秀 (支持所有主流平台和浏览器)</td></tr><tr><td align="left"><strong>桌面&#x2F;手机App密码支持</strong></td><td align="left">❌ 否</td><td align="left">✅ 是</td></tr><tr><td align="left"><strong>安全共享</strong></td><td align="left">❌ 否</td><td align="left">✅ 是</td></tr><tr><td align="left"><strong>紧急访问</strong></td><td align="left">❌ 否</td><td align="left">✅ 是 (高级功能)</td></tr><tr><td align="left"><strong>第三方安全审计</strong></td><td align="left">❌ 否 (不公开)</td><td align="left">✅ 是 (定期进行并公开报告)</td></tr></tbody></table><hr><h3 id="2-Bitwarden-如何在竞争中胜出"><a href="#2-Bitwarden-如何在竞争中胜出" class="headerlink" title="2. Bitwarden 如何在竞争中胜出"></a>2. Bitwarden 如何在竞争中胜出</h3><p>决定使用专业工具后，下一个问题是：选哪一个？我将Bitwarden置于竞争格局中，尤其是通过一次真实的安全灾难，看清了它的价值。</p><h4 id="Bitwarden-vs-竞品"><a href="#Bitwarden-vs-竞品" class="headerlink" title="Bitwarden vs. 竞品"></a><strong>Bitwarden vs. 竞品</strong></h4><table><thead><tr><th align="left">特性</th><th align="left">Bitwarden</th><th align="left">1Password</th><th align="left">LastPass</th></tr></thead><tbody><tr><td align="left"><strong>安全模型</strong></td><td align="left">✅ <strong>开源</strong></td><td align="left">❌ 闭源</td><td align="left">❌ 闭源</td></tr><tr><td align="left"><strong>免费版</strong></td><td align="left">✅ <strong>极佳 (无限密码&#x2F;设备)</strong></td><td align="left">❌ 无</td><td align="left">⚠️ 严重受限</td></tr><tr><td align="left"><strong>个人高级版年费</strong></td><td align="left"><strong>~$10</strong></td><td align="left">~$36</td><td align="left">~$36</td></tr><tr><td align="left"><strong>KDF 强度</strong></td><td align="left">✅ <strong>优秀 (高迭代 &#x2F; 支持Argon2id)</strong></td><td align="left">✅ 良好</td><td align="left">❌ 历史记录不佳</td></tr><tr><td align="left"><strong>关键差异点</strong></td><td align="left">开源透明，性价比之王</td><td align="left">精致的用户体验</td><td align="left">有严重安全污点</td></tr><tr><td align="left"><strong>我的结论</strong></td><td align="left"><strong>强烈推荐</strong></td><td align="left">优秀但昂贵的选择</td><td align="left"><strong>不推荐</strong></td></tr></tbody></table><p>1Password无疑是优秀的产品，以其精美的用户体验著称，但它是闭源的，且价格更高。而Bitwarden的开源模式提供了无可比拟的透明度，其慷慨的免费版和极具性价比的付费版，使其成为兼顾安全与成本的最佳选择。</p><h3 id="3-三步完成你的-Bitwarden-初始设置"><a href="#3-三步完成你的-Bitwarden-初始设置" class="headerlink" title="3. 三步完成你的 Bitwarden 初始设置"></a>3. 三步完成你的 Bitwarden 初始设置</h3><p>从零开始配置Bitwarden非常简单，我们跳过繁琐的原理，直接看操作。</p><p><strong>第一步：创建账户，设定你的主密码</strong></p><ol><li>访问 Bitwarden 官网 <code>bitwarden.com</code> 并创建账户。</li><li><strong>设置主密码。</strong> 这是你唯一需要记住的密码，是打开整个数字王国的钥匙。<ul><li><strong>终极警告：</strong> 由于“零知识”架构，<strong>一旦忘记主密码，Bitwarden也无法帮你找回，数据将永久锁定。</strong></li><li><strong>最佳实践：</strong> 放弃“强密码”的老思路，拥抱“密码短语” (passphrase)。使用4个或更多无关联的单词组合，例如 <code>电缆-绿色-犀牛-88-航行</code>。这种方式比 <code>R#t5&amp;bV9*p</code> 更容易记忆，搭配上各种符号,使破解难度极高。<strong>别用自己的生日,123456的方式啦!不然再好的密码管理器也保证不了你的密码安全!</strong></li><li><strong>物理备份：</strong> 将主密码工整地写在纸上，与护照等重要文件一起存放在安全的地方。</li></ul></li></ol><p><img src="https://img.996007.icu/file/1751889180848_20250707195257646.png" alt="image-20250707195250490"></p><p><strong>第二步：为账户启用双因素认证 (2FA)</strong></p><ol><li>登录网页保险库 <code>vault.bitwarden.com</code>。</li><li>导航至【设置】-&gt;【安全】-&gt;【两步登录】。</li><li>选择“身份验证器应用”，用手机上的认证App扫描屏幕上的二维码。这里可以直接用我推荐的<strong>Google Authenticator</strong></li><li>系统会提供一个<strong>恢复代码</strong>。务必将其抄写下来，与你的主密码存放在同一个安全的地方。这是在你丢失手机后访问账户的唯一方法。<br><img src="https://img.996007.icu/file/1751889403364_20250707195634843.png" alt="image-20250707195634740"></li></ol><p><strong>第三步：部署工具</strong></p><ol><li><p><strong>浏览器扩展：</strong> 在你常用的浏览器（Chrome, Firefox, Edge等）应用商店中搜索并安装“Bitwarden”扩展。</p><p><img src="https://img.996007.icu/file/1751889506392_20250707195815630.png" alt="image-20250707195815527"></p></li><li><p><strong>手机 App：</strong> 在你的手机（iOS 或 Android）应用商店下载 Bitwarden App。</p></li><li><p><strong>关键一步：</strong> 安装完成后，立即进入你<strong>所有浏览器</strong>的设置，<strong>关闭并禁用其自带的密码保存和自动填充功能</strong>。这能避免冲突，确保Bitwarden是你唯一的密码来源。这里每个浏览器不一样,可以自己查一下!</p><p><img src="https://img.996007.icu/file/1751889667265_20250707200058589.png" alt="image-20250707200058492"></p></li></ol><p>至此，你的数字保险库已构建完成。接下来，在浏览网站时，Bitwarden会自动提示你保存新登录信息，并能一键生成独一无二的强密码。</p><p><img src="https://img.996007.icu/file/1751889711354_20250707200148327.png" alt="image-20250707200148242"></p><h3 id="4-为什么我选择-Google-而非-Microsoft"><a href="#4-为什么我选择-Google-而非-Microsoft" class="headerlink" title="4. 为什么我选择 Google 而非 Microsoft"></a><strong>4. 为什么我选择 Google 而非 Microsoft</strong></h3><p>启用2FA时，你需要一个认证器App。最主流的选择是 Google Authenticator 和 Microsoft Authenticator。</p><table><thead><tr><th align="left">特性</th><th align="left">Google Authenticator</th><th align="left">Microsoft Authenticator</th></tr></thead><tbody><tr><td align="left"><strong>核心功能 (TOTP)</strong></td><td align="left">✅ 可靠</td><td align="left">✅ 可靠</td></tr><tr><td align="left"><strong>云备份与同步</strong></td><td align="left">✅ (通过 Google 账户)</td><td align="left">⚠️ (功能存在，但有大量用户报告恢复失败)</td></tr><tr><td align="left"><strong>用户报告的可靠性</strong></td><td align="left">良好</td><td align="left">❌ <strong>差</strong> (存在严重备份恢复风险)</td></tr><tr><td align="left"><strong>我的选择</strong></td><td align="left"><strong>推荐</strong></td><td align="left"><strong>不推荐</strong></td></tr></tbody></table><p>Microsoft Authenticator 提供了云备份、推送通知等更丰富的功能。然而，在便利性的背后，隐藏着一个<strong>致命缺陷</strong>。大量真实用户报告指出，其云备份功能在更换手机（尤其是Android与iOS互换）时存在<strong>灾难性的恢复失败风险</strong>。</p><p>说实话,我刚开始也使用的是<strong>Microsoft Authenticator</strong>,但是在多个论坛看到用户因为换手机或云同步导致账号丢失的问题,果断切换到**Google Authenticator **了!</p><p><img src="https://img.996007.icu/file/1751891345361_20250707202900577.png" alt="image-20250707202900511"></p><p><img src="https://img.996007.icu/file/1751891394250_20250707202948335.png" alt="image-20250707202948257"></p><p>在一个“输不起”的安全环节，功能的稳定可靠压倒一切。Google Authenticator 功能纯粹，核心的验证码生成功能稳定如一。虽然过去因备份不便受诟病，但现在已支持通过Google账户云同步，解决了最大的痛点。因此，我选择更简单、更可靠的Google Authenticator。</p><h3 id="5-自托管-Bitwarden-的诱惑与陷阱"><a href="#5-自托管-Bitwarden-的诱惑与陷阱" class="headerlink" title="5. 自托管 Bitwarden 的诱惑与陷阱"></a><strong>5. 自托管 Bitwarden 的诱惑与陷阱</strong></h3><p>对于追求极致数据主权的硬核用户，Bitwarden 提供了自托管选项。你可以将整套服务运行在自己的服务器上，实现数据的完全物理掌控。社区开发的轻量级替代品 <strong>Vaultwarden</strong> 更是诱人，它极其轻量，还能<strong>免费解锁所有官方的付费功能</strong>。</p><p>听起来很完美？<strong>但我强烈建议绝大多数用户远离自托管。</strong></p><table><thead><tr><th align="left">方面</th><th align="left">Bitwarden 官方云服务</th><th align="left">自托管 (以 Vaultwarden 为例)</th></tr></thead><tbody><tr><td align="left"><strong>数据控制</strong></td><td align="left">逻辑控制 (通过加密)</td><td align="left">✅ 物理和逻辑双重控制</td></tr><tr><td align="left"><strong>高级功能成本</strong></td><td align="left">需付费订阅</td><td align="left">✅ 免费</td></tr><tr><td align="left"><strong>设置与维护</strong></td><td align="left">✅ <strong>零维护</strong></td><td align="left">❌ 复杂，需要持续投入</td></tr><tr><td align="left"><strong>可用性风险</strong></td><td align="left">✅ 极低</td><td align="left">⚠️ <strong>中高 (可能因客户端更新而中断服务)</strong></td></tr><tr><td align="left"><strong>最适合</strong></td><td align="left"><strong>绝大多数用户</strong></td><td align="left"><strong>技术专家和隐私极致追求者</strong></td></tr></tbody></table><p>自托管最大的风险，并非安全配置（如果你是专家），而是<strong>服务可用性</strong>。当Bitwarden官方更新客户端App时，可能会与非官方的Vaultwarden服务器产生不兼容，导致你<strong>突然无法登录或同步</strong>，直到社区发布补丁。这种被锁在自己保险库外的风险，对普通用户是不可接受的。</p><h3 id="6-我的选择与背后的思考"><a href="#6-我的选择与背后的思考" class="headerlink" title="6. 我的选择与背后的思考"></a><strong>6. 我的选择与背后的思考</strong></h3><p>经过以上层层分析与实践，我的最终推荐方案依然坚定不移：<strong>使用 Bitwarden 官方云服务 + Google Authenticator。</strong></p><p>这就是我为自己的数字生活建立的秩序。它足够安全，足够方便，且成本极低。当然，技术的世界永远有更优解。我很期待在评论区看到你的想法和方案，让我们共同探讨，找到属于自己的最佳实践。</p>]]></content>
    
    
    <summary type="html">在日常生活中，越来越多的网站和应用要求我们创建账号和密码。多数普通用户选择使用**浏览器内置的密码**管理功能,或者**全平台用同一个密码**，这种方式虽然便捷，却会存在明显的安全隐患和同步不便的问题。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="工具" scheme="https://www.wangwangit.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="密码管理" scheme="https://www.wangwangit.com/tags/%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>抖音视频下到手软？这个“搬家”神器，一键备份你所有的点赞和收藏！</title>
    <link href="https://www.wangwangit.com/%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD%E6%8A%96%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%AA%E7%B4%AF%E4%BA%86%EF%BC%8C%E6%9C%80%E8%BF%91%E5%9C%A8%E7%94%A8%E8%BF%99%E4%B8%AA%E6%8F%92%E4%BB%B6/"/>
    <id>https://www.wangwangit.com/%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD%E6%8A%96%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%AA%E7%B4%AF%E4%BA%86%EF%BC%8C%E6%9C%80%E8%BF%91%E5%9C%A8%E7%94%A8%E8%BF%99%E4%B8%AA%E6%8F%92%E4%BB%B6/</id>
    <published>2025-07-15T04:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.765Z</updated>
    
    <content type="html"><![CDATA[<p>抖音,现在是很多人的电子零食,可能用来学习,也可能用来看美女,或者用来消磨时光,那么,你们肯定也点赞收藏了很多视频,有时候,你会遇到下面的问题.</p><ul><li>在抖音刷到一个超棒的系列教程，想全部下载下来慢慢学，但一个个手动保存，点到手酸。</li><li>看到某个旅行博主的作品，构图和配乐都堪称艺术品，想作为素材库收藏，却无从下手。</li><li>或者，就是想把自己几年来点赞过的几千个视频做个备份，留个纪念，结果发现这是个不可能完成的任务。</li></ul><p>手动操作不仅麻烦，而且效率极低。我之前也一直被这个问题困扰，最近我找到一款批量下载的工具——一个名为 <strong>“抖珍藏”</strong> 的浏览器插件。</p><p>它不做别的事，只专注一件事：<strong>批量下载抖音视频</strong>。</p><p><strong>下载地址</strong>:</p><blockquote><p><a href="https://microsoftedge.microsoft.com/addons/detail/%E6%8A%96%E7%8F%8D%E8%97%8F-%E4%B8%8B%E8%BD%BD%E5%A4%87%E4%BB%BD%E4%BD%A0%E7%88%B1%E8%BF%87%E7%9A%84%E6%89%80%E6%9C%89%E6%8A%96%E9%9F%B3/kaepaapgaokpobjhamjjekinijbcoihe?hl=zh-CN">https://microsoftedge.microsoft.com/addons/detail/%E6%8A%96%E7%8F%8D%E8%97%8F-%E4%B8%8B%E8%BD%BD%E5%A4%87%E4%BB%BD%E4%BD%A0%E7%88%B1%E8%BF%87%E7%9A%84%E6%89%80%E6%9C%89%E6%8A%96%E9%9F%B3/kaepaapgaokpobjhamjjekinijbcoihe?hl=zh-CN</a></p></blockquote><h3 id="它能做什么？直接看图"><a href="#它能做什么？直接看图" class="headerlink" title="它能做什么？直接看图"></a><strong>它能做什么？直接看图</strong></h3><p>安装插件后，登录抖音网页版，点击浏览器右上角的插件图标，你会看到一个不能再简单的界面：</p><p><img src="https://img.996007.icu/file/1751767556032_20250706100552314.png" alt="image-20250706100552163"></p><p>就三个选项，清清楚楚：</p><ol><li><strong>下载我点赞的所有视频 ❤️</strong></li><li><strong>下载我收藏的所有视频 ⭐️</strong></li><li><strong>下载该作者所有作品</strong></li></ol><p>没有花里胡哨的功能，正合我意。我最主要的需求就是备份点赞，所以直接点了第一个。浏览器弹窗让我选个文件夹存放，选好后，一个下载进度条就出现了，告诉我总共有多少视频，正在下载第几个。</p><p><img src="https://img.996007.icu/file/1751767641014_20250706100717585.png" alt="image-20250706100717476"></p><p>然后就没我什么事了，它在后台自己跑，我该干嘛干嘛。过了一会去看那个文件夹，视频文件已经整整齐齐地躺在里面了，文件名就是视频本身的文案，找起来很方便。</p><p>这个体验很顺滑，因为它把所有麻烦事都自己搞定了。</p><p>用起来也很直接：</p><ol><li>先去抖音网页版 <code>douyin.com</code> <strong>登录你的账号</strong>。这是关键，不登录它就不知道你是谁，也没法读取你的点赞和收藏。</li><li>想下<strong>点赞&#x2F;收藏</strong>的话，登录后在任意页面点浏览器右上角的【抖珍藏】图标，选对应的按钮就行。</li><li>想下<strong>某个作者</strong>的全部作品，需要先进到这个作者的主页，然后再点插件图标，选【下载该作者所有作品】。</li></ol><p>后来我又用了几次，发现它还有个设置选项，可以筛选视频时长。比如我只想下那些超过1分钟的干货教程，不想下载十几秒的短视频，这个功能就挺有用的。<br><img src="https://img.996007.icu/file/1751767662191_20250706100740766.png" alt="image-20250706100740687"></p><p>当然，它也不是完美的。如果你的点赞列表有几千上万个视频，下载过程会比较漫长，毕竟它是一个个视频去处理的。但好处是，这是一个可以“扔在一边不用管”的任务，让电脑开着，它总会默默下完。</p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a><strong>总结一下</strong></h3><p>“抖珍藏”不是什么功能复杂的神器，它就是一个“小而美”的工具。它只解决“批量下载抖音视频”这一个痛点，但解决得非常彻底。</p><p>如果你有内容备份、素材整理的需求，或者单纯是个数字收藏爱好者，这个小插件应该能帮你节省大量的时间和精力。</p>]]></content>
    
    
    <summary type="html">如果你跟我一样，手里有几台散落在不同地方的设备——比如家里的NAS、公司的开发机、自己随身的笔记本——那你肯定也折腾过怎么让它们方便地互相访问。</summary>
    
    
    
    <category term="软件" scheme="https://www.wangwangit.com/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="下载" scheme="https://www.wangwangit.com/tags/%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>保姆级教程：从零开始，搭建一个属于你自己的微信消息推送服务</title>
    <link href="https://www.wangwangit.com/%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1/"/>
    <id>https://www.wangwangit.com/%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1/</id>
    <published>2025-07-05T04:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.762Z</updated>
    
    <content type="html"><![CDATA[<p>最近，我被一个推送消息的需求给难住了。</p><p>过去，我们习惯让服务器生成每日报告，然后一股脑儿地用邮件发给自己。结果就是，邮箱里塞满了各种报告文件，翻找起来特别麻烦。我一直在想，有没有什么更清爽的替代方案？</p><p>企业微信自带的消息API进入了我的视线。</p><p>我相信很多人都用过像 <strong>Server酱</strong> 或者 <strong>PushPlus</strong> 这类的第三方推送服务。它们确实方便，往往一行代码就能把通知发到微信上，简单快捷。</p><p>但用久了，你可能会遇到一些小问题：服务依赖第三方，偶尔会不太稳定；想自定义一些功能时，又感觉束手束脚。于是我琢磨着：为什么不干脆自己动手，搞一个专属的、完全可控的推送机器人呢？</p><p>企业微信的API，可以说是一个现成的完美方案——稳定、免费，而且配置起来比想象中要简单得多。</p><p>整个过程中，最大的“拦路虎”，其实是那个“可信IP”的验证。特别是对于没有固定公网IP，或者不想折腾服务器的同学来说，很容易在第一步就卡住。</p><p>今天，我就给大家分享一个思路：<strong>借助我用ClawCloud免费容器搭建的一个中转服务，巧妙绕过“可信IP”的验证</strong>。后续，你甚至可以直接通过这个中转服务来发消息。当然，如果你有带固定公网IP的服务器，直接研究官方API也是一个非常不错的选择。</p><blockquote><p>关于ClawCloud免费容器我这不过多介绍了,可以参考我公众号的另一篇文章: <code>https://mp.weixin.qq.com/s/8XfRSP250YV4QaNswI3pzw</code>, 今天这个项目的镜像名是: wangwangit&#x2F;wangwangit:qywx ,参考下图配置即可!</p></blockquote><p><img src="https://img.996007.icu/file/1751776650801_20250706123721056.png" alt="image-20250706123720924"></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h3><p>你不需要准备太多东西，只需要一个企业微信账号。个人也能免费注册，去官网 (<code>https://work.weixin.qq.com/wework_admin/register_wx</code>) 填些基本信息就好。</p><p><img src="https://img.996007.icu/file/1751765736953_20250706093530014.png" alt="image-20250706093529921"></p><hr><h3 id="第一步：创建你的企业微信应用"><a href="#第一步：创建你的企业微信应用" class="headerlink" title="第一步：创建你的企业微信应用"></a><strong>第一步：创建你的企业微信应用</strong></h3><p>首先，登录企业微信后台，找到 <strong>「应用管理」-&gt;「自建」-&gt;「创建应用」</strong>。</p><p>这里需要你上传一个应用Logo（随便找张图就行），再给应用起个名字，比如我就叫它“测试”。</p><p><img src="https://img.996007.icu/file/1751765488291_20250706093121701.png" alt="image-20250706093033046"></p><p>应用创建成功后，点进去。有三个关键信息将作为后续所有操作的“身份凭证”，<strong>请务必找个地方把它们记下来</strong>：</p><ol><li><code>AgentId</code> (应用ID)</li><li><code>Secret</code> (应用密钥，需要用企业微信App扫码查看，切勿泄露)</li><li><code>企业ID</code> (在后台 <strong>「我的企业」</strong> 页面，拉到最下方就能看到)</li></ol><p><img src="https://img.996007.icu/file/1751766674113_20250706095107315.png" alt="image-20250706095107225"></p><p><strong>提醒一下</strong>：别忘了在应用的“可见范围”里，把你希望接收消息的同事（或者就你自己）加进去，否则机器人会不知道该把消息发给谁。</p><h3 id="第二步：搞定最关键的“可信IP”"><a href="#第二步：搞定最关键的“可信IP”" class="headerlink" title="第二步：搞定最关键的“可信IP”"></a><strong>第二步：搞定最关键的“可信IP”</strong></h3><p>这是整个流程中最容易让人放弃的地方。</p><p>正常情况下，企业微信要求你提供一个公网服务器地址（URL）。它会向这个地址发送一个验证请求，你的服务器需要给出正确的回应，才算通过。验证通过后，才能继续添加“可信IP”。</p><p>但我们大多数人哪有现成的公网服务器来做这个事呢？别慌，我们可以“借”一个。</p><ol><li><p>在你的应用配置页面，找到“接收消息”功能区，点击“设置API接收”。</p><p><img src="https://img.996007.icu/file/1751770412325_20250706105330649.png" alt="image-20250706105330585"></p></li><li><p>进去之后，<code>Token</code> 和 <code>EncodingAESKey</code> 这两项，直接点右侧的“随机获取”。<strong>然后，立刻把这两个值复制下来备用。</strong></p><p><img src="https://img.996007.icu/file/1751770403958_20250706105321732.png" alt="image-20250706105321656"></p></li><li><p><strong>接下来是重点</strong>：打开下面这个我搭建的中转服务网站，它专门用来完成这次验证“握手”。<br><strong>地址：<code>https://push.wangwangit.com</code></strong></p></li><li><p>把上一步你复制的 <code>Token</code> 和 <code>EncodingAESKey</code> 粘贴到网站对应的输入框里，它会立刻为你生成一个临时的回调URL。</p><p><img src="https://img.996007.icu/file/1751771049603_20250706110404541.png" alt="image-20250706110404368"></p></li><li><p><strong>将这个刚刚生成的URL，完整地复制粘贴回企业微信的“URL”配置框中</strong>，然后点“保存”。</p><p>Duang！你会惊喜地发现，验证竟然直接通过了！</p></li></ol><p>这一步的原理，就是我们借用了这个中转服务作为“跳板”，它帮我们接收并正确地响应了企业微信的验证请求。验证完成后，这个跳板的使命就结束了。</p><p>URL验证通过后，企业微信的“企业可信IP”功能也就随之解锁了。现在，你就可以把你<strong>真正用来发消息的服务器IP</strong>填进去了。</p><ul><li>如果你有服务器，就填服务器的公网IP。</li><li>如果你在家里，没有固定公网IP，可以配置一个DDNS动态域名，然后把域名填进去。</li><li>最直接的，你甚至可以把你家当前的公网IP填进去（缺点是IP地址改变后，需要回来重新修改）。</li></ul><p><img src="https://img.996007.icu/file/1751771359577_20250706110908590.png" alt="image-20250706110908500"></p><p>添加完这个IP后，今后只有来自该IP的请求才能调用API发消息，非常安全。</p><h3 id="第三步：生成你的专属推送URL"><a href="#第三步：生成你的专属推送URL" class="headerlink" title="第三步：生成你的专属推送URL"></a><strong>第三步：生成你的专属推送URL</strong></h3><p>到这里，企业微信后台的配置基本完成了。理论上，你已经可以对照着官方API文档，自己写代码来调用接口、推送消息了。</p><p>但为了“懒”得更彻底一点，我们可以继续使用那个中转服务，它能把复杂的API调用过程，封装成一个极其简单的URL。你只需要请求这个URL，就能轻松发消息。</p><blockquote><p><strong>动手能力强的同学，可以去GitHub上自己部署这个服务，实现完全私有化：<code>https://github.com/wangwangit/qywx-push</code></strong></p></blockquote><p>这里我继续用公共服务来演示：</p><ol><li>再次回到中转服务网站：<code>https://push.wangwangit.com</code></li><li>这次，我们把<strong>第一步</strong>记录的 <code>企业ID</code>、<code>Secret</code>、<code>AgentId</code> 填到下方的“生成推送URL”配置区。</li><li>点击“获取成员列表”，选中你希望接收消息的用户（注意：用户需要先在企业微信中关注你的企业和这个自建应用）。</li><li>点击“完成配置”。</li></ol><p><img src="https://img.996007.icu/file/1751771960032_20250706111912174.png" alt="image-20250706111912028"><img src="https://img.996007.icu/file/1751771414104_20250706111011665.png" alt="image-20250706111011596"></p><p>网站会立刻为你生成一个专属的调用地址。<strong>这个地址非常重要，请务必保存好！</strong> 你可以点击右上角的“API文档”查看详细的调用方法。</p><p><img src="https://img.996007.icu/file/1751771468855_20250706111102397.png" alt="image-20250706111102333"></p><p>今后，如果你想让AI帮你写一段带通知功能的代码，你只需要把这个URL和对应的API文档一起告诉它，就能快速搞定。</p><h3 id="最后：享受你的成果！"><a href="#最后：享受你的成果！" class="headerlink" title="最后：享受你的成果！"></a><strong>最后：享受你的成果！</strong></h3><p>现在，大功告成！</p><p>无论你想在Shell脚本、Python程序，还是任何支持HTTP请求的地方实现通知功能，只需要调用一下上面生成的那个专属URL，消息就能瞬间推送到你的企业微信里。</p><p>我个人还有一个很喜欢的小技巧：在手机上把这个企业微信应用“发送到桌面”，让它看起来就像一个独立的App，接收消息和查看都非常方便。</p><p><img src="https://img.996007.icu/file/1751771823233_20250706111654376.png" alt="image-20250706111654165"><img src="https://img.996007.icu/file/1751771802308_20250706111636321.png" alt="image-20250706111635713"></p><p>从今以后，再也不用被塞满报告的邮箱困扰了！</p>]]></content>
    
    
    <summary type="html">过去，我们习惯让服务器生成每日报告，然后一股脑儿地用邮件发给自己。结果就是，邮箱里塞满了各种报告文件，翻找起来特别麻烦。我一直在想，有没有什么更清爽的替代方案？</summary>
    
    
    
    <category term="AI" scheme="https://www.wangwangit.com/categories/AI/"/>
    
    
    <category term="AI" scheme="https://www.wangwangit.com/tags/AI/"/>
    
    <category term="ChatGPT" scheme="https://www.wangwangit.com/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>不用愁没国外卡了！教你用PayPal丝滑订阅一美元的ChatGPT Team（内附防封教程）</title>
    <link href="https://www.wangwangit.com/%E5%88%AB%E5%86%8D%E6%84%81%E6%B2%A1%E5%9B%BD%E5%A4%96%E5%8D%A1%E4%BA%86%EF%BC%81%E6%95%99%E4%BD%A0%E7%94%A8PayPal%E4%B8%9D%E6%BB%91%E8%AE%A2%E9%98%85%E4%B8%80%E7%BE%8E%E5%85%83%E7%9A%84ChatGPT%20Team%EF%BC%88%E5%86%85%E9%99%84%E9%98%B2%E5%B0%81%E6%95%99%E7%A8%8B%EF%BC%89/"/>
    <id>https://www.wangwangit.com/%E5%88%AB%E5%86%8D%E6%84%81%E6%B2%A1%E5%9B%BD%E5%A4%96%E5%8D%A1%E4%BA%86%EF%BC%81%E6%95%99%E4%BD%A0%E7%94%A8PayPal%E4%B8%9D%E6%BB%91%E8%AE%A2%E9%98%85%E4%B8%80%E7%BE%8E%E5%85%83%E7%9A%84ChatGPT%20Team%EF%BC%88%E5%86%85%E9%99%84%E9%98%B2%E5%B0%81%E6%95%99%E7%A8%8B%EF%BC%89/</id>
    <published>2025-07-05T04:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.764Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间分享了那个“1美元体验ChatGPT Team”的活动，后台好多朋友激动地跑去试了，但更多的人卡在了同一个地方——<strong>没有国外信用卡，付不了款！</strong></p><p>看着优惠却吃不到，这感觉我懂。</p><p>不过别急，最近在网上看到一份教程,我自己也试验了一下,确实能开通成功，今天就给大家分享这个<strong>终极解决方案</strong>！不仅能让你用<strong>国内Visa&#x2F;Mastercard信用卡 + PayPal</strong>成功上车，还研究出了一套“骚操作”，可以<strong>极大程度地避免你的主力ChatGPT账号被封</strong>的风险。</p><h4 id="一、准备工作：这次我们换个思路"><a href="#一、准备工作：这次我们换个思路" class="headerlink" title="一、准备工作：这次我们换个思路"></a>一、准备工作：这次我们换个思路</h4><p>想成功支付并保证安全，你需要这三样东西：</p><ol><li><p><strong>一个科学的网络环境</strong><br>这步是老规矩。</p></li><li><p><strong>一个绑定了国内卡的PayPal账户</strong><br>没错，你完全<strong>不需要美区PayPal</strong>！直接注册或登录你的<strong>中国区PayPal账户</strong>，在后台绑定一张你自己的<strong>国内Visa或Mastercard信用卡</strong>就行。我没试过普通银联储蓄卡，有条件的朋友可以自己试试看。</p></li><li><p><strong>一个不常用的“小号”</strong> (⚠️<strong>防封关键</strong>）<br>这是本次教程的精髓！<strong>不要用你的主力ChatGPT账号直接去开通Team</strong>。建议新注册一个，或者用一个你不那么心疼的账号来操作。为什么？后面我会详细解释。</p></li></ol><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250701093037793.png" alt="image-20250701093037793"></p><p>准备就绪？Let’s Go!</p><h4 id="二、支付流程：四步搞定，丝般顺滑"><a href="#二、支付流程：四步搞定，丝般顺滑" class="headerlink" title="二、支付流程：四步搞定，丝般顺滑"></a>二、支付流程：四步搞定，丝般顺滑</h4><p><strong>第1步：访问优惠链接</strong></p><p>确保你的网络环境科学，然后用浏览器打开这个链接：</p><blockquote><p><code>https://chatgpt.com/?promo_campaign=team1dollar#team-pricing</code></p></blockquote><p>如果页面顶部出现了“<strong>首月1美元&#x2F;席位</strong>”的优惠横幅，就说明你成功了！如果没出现，或者还是原价，<strong>检查一下你的IP</strong>，<strong>注意,将右下角切换到法国.或者其他欧洲国家试试!</strong></p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250701093742744.png" alt="image-20250701093742744"></p><p><strong>第2步：PayPal！</strong></p><p>接下来，在支付页面，你会看到一个久违的亲切图标——<strong>PayPal</strong>！果断选中它。</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250701093903212.png" alt="image-20250701093903212"></p><p>页面会跳转到PayPal，登录并选择你绑定的国内信用卡完成支付。整个过程非常流畅!</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250701093116649.png" alt="image-20250701093116649"></p><p><strong>第3步：【保命操作】立刻取消订阅！</strong></p><p>老规矩，也是最重要的纪律：<strong>付完款，立刻去取消自动续费！</strong></p><p>这个优惠只有首月，下个月会自动按**$30&#x2F;席位&#x2F;月的原价**扣款。别让煮熟的鸭子飞了，还顺便啄你一口。</p><p>路径在这里：<br><strong>右上角头像 →【Manage workspace】→【Billing】→【Manage subscription】→【Cancel plan】</strong></p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250701094055217.png" alt="image-20250701094055217"></p><p>放心，取消后，你这一个月的使用权不会受任何影响。</p><h4 id="三、独家防封神操作：把风险转移出去"><a href="#三、独家防封神操作：把风险转移出去" class="headerlink" title="三、独家防封神操作：把风险转移出去"></a>三、独家防封神操作：把风险转移出去</h4><p>好了，接下来是压轴戏，解释一下为什么要用“小号”。</p><p>我们这种方式毕竟属于“曲线救国”，有一定的账号风险。我测试了几个号发现，如果开通Team的那个账号被封，整个Team就跟着翻车了。但如果你把这个号从Team里移出去，风险就小很多。</p><p>所以，咱们的神操作是：<strong>用小号“献祭”，保大号平安！</strong></p><p>操作步骤如下：</p><ol><li>用你的“小号”完成上面的所有开通和付款步骤。</li><li>进入工作区管理后台，点击【Members】（成员），邀请你的<strong>主力大号</strong>加入这个Team。</li><li>大号接受邀请加入后，回到小号的管理界面，在成员列表里，找到你的大号，点击它的角色，选择【Make owner】（<strong>设为所有者</strong>）。</li><li>将所有权成功转移给大号后，再用大号登录，把那个用来付款的“小号”从Team里【Remove】（<strong>移除</strong>）出去。</li></ol><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250701094424058.png" alt="image-20250701094424058"></p><p>这样一来，<strong>风险就完全隔离在了那个被移除的小号上</strong>。你的主力大号作为新的所有者，可以安全地享受这一个月的Team服务，邀请你的朋友，完全不用担心因为支付问题被牵连。</p><p>这一招，是不是很妙？</p><h4 id="最后聊几句"><a href="#最后聊几句" class="headerlink" title="最后聊几句"></a>最后聊几句</h4><p>总花费也就十几块钱，就能解锁一个功能更强、额度更高的GPT-4o，还能拉上最多4个小伙伴一起“学习”，这性价比简直拉满了。</p><p>这个方法随时可能失效，如果你有需要，建议看到文章后就马上去试试。</p><p>希望这篇“终极版”教程能帮到每一个被支付问题困扰的朋友。享受AI，更要玩得聪明，玩得安心！</p>]]></content>
    
    
    <summary type="html">如果你跟我一样，手里有几台散落在不同地方的设备——比如家里的NAS、公司的开发机、自己随身的笔记本——那你肯定也折腾过怎么让它们方便地互相访问。</summary>
    
    
    
    <category term="AI" scheme="https://www.wangwangit.com/categories/AI/"/>
    
    
    <category term="AI" scheme="https://www.wangwangit.com/tags/AI/"/>
    
    <category term="ChatGPT" scheme="https://www.wangwangit.com/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>腾讯“良心发现”？免费CDN+AI一键部署，我把Cloudflare上的博客连夜搬了过来</title>
    <link href="https://www.wangwangit.com/%E8%85%BE%E8%AE%AF%E2%80%9C%E8%89%AF%E5%BF%83%E5%8F%91%E7%8E%B0%E2%80%9D%EF%BC%9F%E5%85%8D%E8%B4%B9CDN+AI%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%EF%BC%8C%E6%88%91%E6%8A%8ACloudflare%E4%B8%8A%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%BF%9E%E5%A4%9C%E6%90%AC%E4%BA%86%E8%BF%87%E6%9D%A5/"/>
    <id>https://www.wangwangit.com/%E8%85%BE%E8%AE%AF%E2%80%9C%E8%89%AF%E5%BF%83%E5%8F%91%E7%8E%B0%E2%80%9D%EF%BC%9F%E5%85%8D%E8%B4%B9CDN+AI%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%EF%BC%8C%E6%88%91%E6%8A%8ACloudflare%E4%B8%8A%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%BF%9E%E5%A4%9C%E6%90%AC%E4%BA%86%E8%BF%87%E6%9D%A5/</id>
    <published>2025-07-04T03:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.767Z</updated>
    
    <content type="html"><![CDATA[<p>聊到免费的 CDN 和网站托管，Cloudflare 绝对是绕不开的名字。这家公司凭借着超大方的免费套餐，几乎成了全球个人开发者和小型项目的“基础设施”，说是<strong>行业大善人</strong>一点也不夸张。我也一直是它的忠实用户。</p><p>但是，它并非没有软肋。最大的痛点就是，如果你身处国内，会发现 Cloudflare 的免费节点访问速度可能不尽人意。但是，最近一个让我有点意外的消息出现了——腾讯云，这个在大家印象里轻易不拔毛的“铁公鸡”，居然也推出了对标 Cloudflare 的产品 EdgeOne，而且还搞起了免费计划。</p><p>我一开始也抱着怀疑的态度，但花时间把它的核心功能跑了一遍后，发现这根“鸡毛”还挺香的。关键是，它在咱们国内和亚洲地区的访问速度上，有着“主场作战”的天然优势。</p><p>在带你上手之前，我得先用大白话解释下，我们要薅的这“免费羊毛”——CDN、Pages、AI 网关——究竟是啥好东西，不然你可能都不知道自己占了多大便宜。</p><ul><li><p><strong>想让你的网站快如闪电？你需要 CDN。</strong><br>打个比方，你的网站服务器在美国，国内朋友访问就像国际长途，很慢。CDN 做的，就是在全球各地，包括中国大陆建一堆“快递站”。用户访问时，会自动从最近的快递站发货（加载网站内容），速度自然就起飞了。</p></li><li><p><strong>想零成本、免维护地部署一个个人网站？你需要 Pages。</strong><br>传统方式是买服务器、配环境，又贵又折腾。而 Pages 服务就像一个“网站托管保姆”，你只需要把写好的网页代码（比如个人简历、项目展示页）往上一扔，它就自动帮你发布上线，变成一个任何人都能访问的网址。服务器？维护？统统不用你操心。比如我前几天发布的导航站,订阅站就是基于Cloudflare Pages部署的!</p></li><li><p><strong>想在国内顺畅调用 OpenAI&#x2F;Google 的 AI 能力？你需要 AI 网关。</strong><br>我们都知道，直接连接这些海外的 AI 服务网络不稳定，还很麻烦。AI 网关就像一个官方搭建的、稳定高速的“专属中转站”。你把请求发给这个在国内的中转站，它负责帮你搞定和海外的通信，再把结果稳稳地传回来。对于想开发 AI 小工具的人来说，这简直是救星。</p></li></ul><p>所以，这篇不是官方文档复读机。作为一个踩过 Cloudflare 的坑，又把 EdgeOne 这顿“免费午餐”从申请到配置、再到玩出花样都尝了一遍的老用户，我来带你看看，怎么把这套难得的便宜占到手，用得舒心。</p><h3 id="一、免费个人套餐申请"><a href="#一、免费个人套餐申请" class="headerlink" title="一、免费个人套餐申请"></a>一、免费个人套餐申请</h3><p>这可能是大家最关心的部分。EdgeOne 默认控制台里是没有免费套餐的，需要我们主动去申请。别担心，流程不复杂，主要是通过一个“GitHub 开发者协作计划”。</p><p><strong>关键地址先放出来：</strong></p><ul><li><p><strong>账号注册地址：</strong> </p><blockquote><p><code>https://www.tencentcloud.com/account/register</code> (国际站)<br><code>https://cloud.tencent.com/register</code> (国内站)<br>这里需要注意,国际站无法用国内身份证实名认证,由于我编写文章时,国内站还没推出,所以下方配图可能不一致!</p></blockquote></li><li><p><strong>免费计划申请地址：</strong> <code>https://edgeone.ai/blog/details/github-developer</code></p></li></ul><p>注册账号很简单，建议用谷歌邮箱，一路“跳过”，暂时不需要实名认证。</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630142034307.png" alt="image-20250630142034307"></p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630142053301.png" alt="image-20250630142053301"></p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630142143399.png" alt="image-20250630142143399"></p><p>搞定账号后，我们来申请免费套餐。官方提供了好几种方式，我最推荐的是<strong>技术赞助展示</strong>，性价比最高。</p><p><strong>核心申请方式：GitHub 开发者协作计划</strong></p><p>简单来说，就是用你的 GitHub 项目来换取免费套餐。</p><ol><li><p><strong>技术赞助展示（最推荐）</strong></p><ul><li><strong>门槛：</strong> 你的 GitHub 项目有 100+ Star。</li><li><strong>要做什么：</strong> 在项目 <code>README.md</code> 里加上一句 “CDN acceleration and security protection for this project are sponsored by Tencent EdgeOne.”，再附上官方的 Logo。</li><li><strong>能换到什么：</strong> 1-10 个免费套餐兑换码（每 100 个 Star 换 1 个，最多 10 个）。对于开源作者来说，这几乎是白给。</li></ul></li><li><p><strong>一键部署集成</strong></p><ul><li><strong>门槛：</strong> 项目有 100+ Star，且和 Web 部署相关。</li><li><strong>要做什么：</strong> 在 <code>README.md</code> 里添加一个 “Deploy to EdgeOne” 按钮。</li><li><strong>能换到什么：</strong> 10-50 个兑换码，力度更大。</li></ul></li><li><p><strong>其他方式</strong></p><ul><li><strong>GitHub Pages 加速：</strong> 如果你的项目托管在 GitHub Pages，可以直接申请。</li><li><strong>写技术文章：</strong> 把你使用 EdgeOne 的经验写成教程。</li><li><strong>蹲点 Discord&#x2F;社媒：</strong> 官方社群会不定期发码，适合没有项目的同学。</li></ul></li></ol><p><strong>怎么申请？</strong></p><p>准备一个邮件，发给 <code>edgeonedeveloper@tencent.com</code>。官方给出了模板，照着填就行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主题：[技术赞助展示] 申请EdgeOne x GitHub协作计划</span><br><span class="line"></span><br><span class="line">收件人：edgeonedeveloper@tencent.com</span><br><span class="line"></span><br><span class="line">必填内容：</span><br><span class="line">您的GitHub账号ID：[你的GitHub用户名]</span><br><span class="line">您选择的参与方式：技术赞助展示</span><br><span class="line">参与的GitHub项目链接：[你的项目URL]</span><br><span class="line">您在GitHub项目中的角色：项目负责人</span><br><span class="line">参与证明（README截图）：[附上截图]</span><br></pre></td></tr></table></figure><p>提交后，官方会在 7 个工作日内通过邮件把兑换码发给你。</p><p><strong>拿到兑换码后：</strong></p><ol><li>访问兑换页面：<code>https://edgeone.ai/redemption?from=github</code></li><li>输入兑换码，激活套餐。</li></ol><p><strong>注意：</strong> 兑换码有效期只有 7 天，拿到手尽快用掉！</p><h3 id="二、加速你的第一个网站（CDN-配置）"><a href="#二、加速你的第一个网站（CDN-配置）" class="headerlink" title="二、加速你的第一个网站（CDN 配置）"></a>二、加速你的第一个网站（CDN 配置）</h3><p>有了套餐，我们来干正事。第一步，先试试最核心的 CDN 加速功能。若没有域名,可以跳过这一章节,试试其他功能,我后续会出一份免费域名申请的教程!</p><h4 id="2-1-添加站点"><a href="#2-1-添加站点" class="headerlink" title="2.1 添加站点"></a>2.1 添加站点</h4><p>登录 EdgeOne 控制台，找到【添加站点】按钮。</p><ul><li><strong>站点域名：</strong> 填你的主域名，比如 <code>wangwangit.com</code>。</li><li><strong>加速区域：</strong> 这里是关键。<ul><li>如果你的域名<strong>备过案</strong>，大胆选择【中国大陆可用区】。</li><li>如果<strong>没备案</strong>，或者用户主要在海外，选择【全球可用区（不含中国大陆）】。</li></ul></li></ul><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630152738639.png" alt="image-20250630152738639"></p><h4 id="2-2-选择接入模式"><a href="#2-2-选择接入模式" class="headerlink" title="2.2 选择接入模式"></a>2.2 选择接入模式</h4><p>EdgeOne 提供了两种主流的接入方式：NS 接入和 CNAME 接入。</p><ul><li><p><strong>NS 接入（官方推荐）：</strong></p><ul><li><strong>工作方式：</strong> 你把整个域名的 DNS 解析权都交给 EdgeOne。</li><li><strong>优点：</strong> 配置最简单，在 EdgeOne 后台就能管理所有解析记录，域名下的所有服务（比如邮件、其他子域名）都能一站式配置，而且安全防护、加速效果最全面。</li><li><strong>适合谁：</strong> 新域名，或者不介意把 DNS 迁过来的用户。</li></ul></li><li><p><strong>CNAME 接入（更灵活）：</strong></p><ul><li><strong>工作方式：</strong> 你原有的 DNS 服务商不变，只是把需要加速的子域名（比如 <code>www</code> 或 <code>blog</code>）指向 EdgeOne 的一个地址。</li><li><strong>优点：</strong> 不影响主域名和其他解析记录，只想加速某个特定站点时非常方便。</li><li><strong>适合谁：</strong> 已经有复杂的 DNS 配置，或者只想“试用”一下的用户。</li></ul></li></ul><p>我个人更倾向于CNAME接入，目前腾讯的免费策略还不明朗,避免反复折腾。</p><h4 id="2-3-配置加速域名"><a href="#2-3-配置加速域名" class="headerlink" title="2.3 配置加速域名"></a>2.3 配置加速域名</h4><p>添加站点后，进入【域名管理】页面，点击【添加加速域名】。</p><p>这里以最常见的 <code>www</code> 子域名为例：</p><ol><li>在【加速域名】里填入 <code>www</code>。</li><li>在【源站配置】里填入你服务器的 IP 地址。其他选项（回源协议、端口等）通常保持默认即可。</li></ol><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630145928819.png" alt="image-20250630145928819"></p><p>配置完成后，EdgeOne 会给你一个 CNAME 地址，形如 <code>www.example.com.edgeone.xxx</code>。</p><p>最后一步，去你的域名注册商（比如 GoDaddy、NameSilo）后台，添加一条 CNAME 解析记录：</p><ul><li><strong>记录类型：</strong> <code>CNAME</code></li><li><strong>主机记录：</strong> <code>www</code></li><li><strong>记录值：</strong> 粘贴上一步 EdgeOne 给你的那个地址。</li><li><strong>TTL：</strong> 建议 <code>600</code> 或更低，方便调试。</li></ul><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630150020811.png" alt="image-20250630150020811"></p><p>等待几分钟，DNS 生效后，你的网站就成功套上 EdgeOne 的 CDN 了。可以去 <code>itdog.cn</code> 这类网站测试一下，看看国内外的 Ping 值和访问速度是不是有了质的飞跃。这里由于我的域名没备案,效果不太好,可以进行优选IP,会有一些实质性的改善,如下图!</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630150143225.png" alt="image-20250630150143225"></p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630150345536.png" alt="image-20250630150345536"></p><h3 id="三、-用-Cherry-Studio-和-EdgeOne-Pages-一句话部署网站"><a href="#三、-用-Cherry-Studio-和-EdgeOne-Pages-一句话部署网站" class="headerlink" title="三、 用 Cherry Studio 和 EdgeOne Pages 一句话部署网站"></a>三、 用 Cherry Studio 和 EdgeOne Pages 一句话部署网站</h3><p>手动配置 CDN 只是开胃菜。EdgeOne Pages 结合 AI 工具，能玩出更现代化的花样。</p><p>简单来说，EdgeOne Pages 是一个类似 Cloudflare Pages 或 Vercel 的静态网站托管平台。而 Cherry Studio 是一个 AI 客户端，通过一个叫 MCP 的协议，能让 AI 直接调用各种工具，比如……直接把一个网站部署到 EdgeOne Pages。</p><p>听起来有点绕？别怕，我们一步步来。</p><h4 id="3-1-获取-API-令牌"><a href="#3-1-获取-API-令牌" class="headerlink" title="3.1 获取 API 令牌"></a>3.1 获取 API 令牌</h4><p>要让外部工具操作你的 EdgeOne 账号，得先生成一个“钥匙”。</p><ol><li>登录 EdgeOne 控制台，找到【API 密钥管理】。</li><li>创建一个新的 API 令牌，权限范围勾选 Pages 相关的就行。</li><li><strong>把生成的令牌复制下来，这是关键，只会显示一次。</strong></li></ol><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630150842333.png" alt="image-20250630150842333"></p><h4 id="3-2-配置-Cherry-Studio"><a href="#3-2-配置-Cherry-Studio" class="headerlink" title="3.2 配置 Cherry Studio"></a>3.2 配置 Cherry Studio</h4><ol><li>下载并安装 Cherry Studio 客户端。官方教程: <a href="https://docs.cherry-ai.com/">https://docs.cherry-ai.com</a></li><li>打开【设置】-&gt;【MCP服务器】，我们需要在这里添加一个自定义服务。</li></ol><p>把下面的 JSON 代码粘贴进去，然后做两处修改：</p><ul><li><code>EDGEONE_PAGES_API_TOKEN</code>: 换成你上一步生成的 API 令牌。</li><li><code>EDGEONE_PAGES_PROJECT_NAME</code>: 给你的项目起个名字，比如 <code>my-awesome-blog</code>。</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;edgeone-pages-mcp-server&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;edgeone-pages-mcp&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;EDGEONE_PAGES_API_TOKEN&quot;</span><span class="punctuation">:</span> <span class="string">&quot;粘贴你的API令牌&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;EDGEONE_PAGES_PROJECT_NAME&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-awesome-blog&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-见证奇迹"><a href="#3-3-见证奇迹" class="headerlink" title="3.3 见证奇迹"></a>3.3 见证奇迹</h4><p>配置好之后，你就可以在 Cherry Studio 里和 AI 对话来部署网站了。</p><p><strong>比如，让 AI 创建并部署一个页面：</strong></p><blockquote><p>“帮我创建一个简单的 HTML 个人介绍页面，包含我的名字‘王小明’和简介‘一个热爱技术的开发者’，然后部署到 EdgeOne Pages。”</p></blockquote><p>AI 会生成代码，并通过我们配置好的 MCP 服务，自动完成部署，最后甩给你一个公开的访问链接。全程无需你手动上传任何文件。</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630150802602.png" alt="image-20250630150802602"></p><p><strong>部署本地文件夹或 ZIP 包：</strong></p><p>如果你已经有了一个本地的静态网站项目（比如一个打包好的 Vue&#x2F;React 应用，或者 Hexo 博客），部署起来更简单。你需要额外配置一个文件系统（<strong>filesystem</strong>）的 MCP，让 AI 能读取你的本地文件。</p><p>配置好后，直接告诉 AI：</p><blockquote><p>“请把我本地 <code>D:/Projects/my-site</code> 文件夹里的所有内容，部署到 EdgeOne Pages。”</p></blockquote><p>整个过程相当流畅，有点科幻照进现实的感觉。</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630185121683.png" alt="image-20250630185121683"></p><h3 id="四、免费的-AI-API-网关"><a href="#四、免费的-AI-API-网关" class="headerlink" title="四、免费的 AI API 网关"></a>四、免费的 AI API 网关</h3><p>EdgeOne 还有一个特别实用的功能，经常被忽略：API 网关。</p><p>如果你在开发一些调用 OpenAI 或 Gemini 的小工具，肯定会遇到国内网络访问不畅或者需要代理的问题。EdgeOne 的 API 网关可以完美解决这个问题。</p><p>你可以在 EdgeOne 控制台创建一个 API 服务，然后按照下方提供的接口进行调用就行。EdgeOne 会给你一个国内可访问的边缘节点 URL。你的应用直接请求这个 EdgeOne 的 URL 就行了，它会自动帮你把请求转发到目标 API，相当于有了一个稳定、高速的官方中转。</p><p>对于没有服务器、又想稳定调用 AI API 的开发者来说，这简直是神器。</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630151409753.png" alt="image-20250630151409753"></p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630151509956.png" alt="image-20250630151509956"></p><h3 id="我踩过的一些坑（FAQ）"><a href="#我踩过的一些坑（FAQ）" class="headerlink" title="我踩过的一些坑（FAQ）"></a>我踩过的一些坑（FAQ）</h3><ol><li><p><strong>问题</strong>：使用中国大陆节点时域名未备案<br><strong>解决</strong>：</p><ul><li>完成域名ICP备案</li><li>或选择全球节点（不含中国大陆）</li></ul></li><li><p><strong>问题</strong>：配置CNAME后加速未生效<br><strong>解决</strong>：</p><ul><li>检查DNS解析是否正确</li><li>等待DNS解析生效（最长24小时）</li><li>清除本地DNS缓存</li></ul></li><li><p><strong>问题</strong>：无法连接EdgeOne Pages MCP<br><strong>解决</strong>：</p><ul><li>检查API令牌是否正确</li><li>确认网络连接正常</li><li>重启Cherry Studio应用</li></ul></li></ol><h3 id="最后聊几句"><a href="#最后聊几句" class="headerlink" title="最后聊几句"></a>最后聊几句</h3><p>说实话，国内云厂商这么大方地给个人开发者提供免费套餐，还做得这么现代化的，确实不多见。Cloudflare 在全球的成功，很大程度上就是抓住了开发者这个群体。</p><p>这次腾讯云 EdgeOne 明显也是冲着这个方向来的。它的产品力不错，尤其是国内和亚洲的访问速度，确实比 Cloudflare 的免费版强一个档次。再加上 Pages、API 网关这些贴近现代开发工作流的功能，组合起来的体验相当能打。</p><p>当然，这个 GitHub 协作计划能持续多久，我们谁也说不准。但至少在目前，对于追求国内访问速度、又不想备案（或正在备案路上）、或者想找个 Cloudflare 备胎的开发者来说，EdgeOne 绝对是一个值得花时间尝试的选择。</p><p>趁着“羊毛”还在，赶紧去试试吧。</p>]]></content>
    
    
    <summary type="html">聊到免费的 CDN 和网站托管，Cloudflare 绝对是绕不开的名字。这家公司凭借着超大方的免费套餐，几乎成了全球个人开发者和小型项目的“基础设施”，说是**行业大善人**一点也不夸张。我也一直是它的忠实用户。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="CDN" scheme="https://www.wangwangit.com/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>域名这玩意儿，真能不花钱或只花几块钱搞定？能</title>
    <link href="https://www.wangwangit.com/%E5%9F%9F%E5%90%8D%E8%BF%99%E7%8E%A9%E6%84%8F%E5%84%BF%EF%BC%8C%E7%9C%9F%E8%83%BD%E4%B8%8D%E8%8A%B1%E9%92%B1%E6%88%96%E5%8F%AA%E8%8A%B1%E5%87%A0%E5%9D%97%E9%92%B1%E6%90%9E%E5%AE%9A%EF%BC%9F%E8%83%BD/"/>
    <id>https://www.wangwangit.com/%E5%9F%9F%E5%90%8D%E8%BF%99%E7%8E%A9%E6%84%8F%E5%84%BF%EF%BC%8C%E7%9C%9F%E8%83%BD%E4%B8%8D%E8%8A%B1%E9%92%B1%E6%88%96%E5%8F%AA%E8%8A%B1%E5%87%A0%E5%9D%97%E9%92%B1%E6%90%9E%E5%AE%9A%EF%BC%9F%E8%83%BD/</id>
    <published>2025-07-03T04:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.764Z</updated>
    
    <content type="html"><![CDATA[<p>夜深人静，万籁俱寂，灵感“Duang”地一下砸你脸上，你一拍大腿：“天才啊！这个名字绝了！” 紧接着，你激动地打开浏览器，敲下那个你觉得能值一百万的域名。</p><p>屏幕上弹出两个冰冷的字：<strong>“已被注册。”</strong></p><p>“没事，我换个思路。”</p><p>……十分钟后。</p><p>“<strong>已被注册。</strong>”<br>“<strong>已被注册。</strong>”<br>“<strong>已被注册。</strong>”</p><p>好吧，热情的小火苗彻底被浇灭，关灯，睡觉，明天又是搬砖的一天。</p><p>这几乎是每个爱折腾、有想法的人都经历过的“域名劝退”三部曲。域名，说白了就是网站的“门牌号”。没有它，你那个安放在互联网角落的“家”（一串没人记得住的IP地址，比如 <code>123.56.78.90</code>），朋友、客户、甚至你自己都找不着北。</p><p>好记的太贵，便宜的又显得不“正经”。这事儿，烦！</p><p>别急，经过无数次踩坑，我总结出了一套专门为我们这种“想法多、口袋空”的折腾党准备的域名攻略。</p><h4 id="动手之前，先扫个盲：域名后缀那点事儿"><a href="#动手之前，先扫个盲：域名后缀那点事儿" class="headerlink" title="动手之前，先扫个盲：域名后缀那点事儿"></a>动手之前，先扫个盲：域名后缀那点事儿</h4><p>在开干之前，你得知道 <code>.com</code>、<code>.xyz</code> 这些后缀（行话叫“顶级域名”）有啥不一样。</p><ul><li><p><strong>江湖老大哥：.com &#x2F; .org &#x2F; .net</strong><br>这几位是元老，尤其是 <code>.com</code>。本来是给公司（Company）用的，现在成了通用标配。结果就是，但凡你能想到的、稍微好记点的名字，甭管中英文，早就被人抢注一空了。想捡漏？比中彩票还难。</p></li><li><p><strong>圈内新贵：.cn &#x2F; .io &#x2F; .dev</strong><br>这些是自带光环的“特色户”。<code>.cn</code> 代表中国，身份的象征。<code>.io</code> 本是英属印度洋领地的缩写，但因为长得像程序员口中的 <code>Input/Output</code>，意外成了技术圈的宠儿。<code>.dev</code>（Developer）就更直接了，开发者专属，逼格拉满。</p></li><li><p><strong>性价比之王：.xyz &#x2F; .app &#x2F; .club</strong><br>近几年涌现出的一大批新后缀，主打一个便宜、管够、还好记。其中 <code>.xyz</code> 简直是一股清流，价格低到离谱，是我们这种“idea先行”的梦想家们最温馨的“快乐老家”。</p></li></ul><p>好了，黑话不多讲，咱们直接开整！</p><h3 id="方案一：技术流的快乐，白嫖一个二级域名"><a href="#方案一：技术流的快乐，白嫖一个二级域名" class="headerlink" title="方案一：技术流的快乐，白嫖一个二级域名"></a>方案一：技术流的快乐，白嫖一个二级域名</h3><p>🚀 <strong>适合人群：</strong> 有折腾精神，不怕点几下鼠标，想零成本验证想法的朋友。</p><p>这条路有点小门槛，如果你一听 GitHub 就头大，别犹豫，直接滑到方案二。</p><p><strong>总共四步，保姆级带路：</strong></p><p><strong>第一步：打开注册页，直达不迷路</strong></p><p>别自己搜了，直接点这个链接：<code>https://dash.domain.digitalplat.org/auth/register</code></p><p><strong>第二步：填写你的“身份卡”</strong></p><p>这里有三样东西要填对：</p><ul><li><strong>用户名：</strong> 英文数字组合，别搞花里胡哨的符号，免得以后出怪问题。</li><li><strong>密码：</strong> 老规矩，大小写+数字+符号，对自己好一点。</li><li><strong>邮箱地址：</strong> <strong>⚠️ 重中之重！</strong> 一定要用你最常用的邮箱。这可是你的救命稻草，找回密码、接收通知全靠它。邮箱要是废了，账号约等于白送。</li></ul><p>其他的随便填就行。</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630170951445.png" alt="image-20250630170951445"></p><p>下一步，系统会让你用 GitHub 账号授权验证一下，点一下，授权，搞定。</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630171602026.png" alt="image-20250630171602026"></p><p>验证成功后，回到控制台页面（<code>https://dash.domain.digitalplat.org</code>），你会惊喜地发现，账户里已经有一个免费域名的“额度”了！</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630171649599.png" alt="image-20250630171649599"></p><p><strong>第三步：注册你的专属域名</strong></p><p>点击左侧的 <strong>Domain Registration</strong>，就可以开始选号了。注意，目前免费的后缀只有 <code>.dpdns.org</code>，其他的因为被滥用，已经开始收费了。不过对于试错来说，完全够用！</p><p><strong>第四步：把它交给 CloudFlare 托管</strong></p><p>注册成功后，系统会让你填写 NS（域名服务器）记录。这时候，打开你的 CloudFlare 账号（没有就免费注册一个），添加你刚刚注册的域名（比如 <code>my-idea.dpdns.org</code>），选择免费套餐。CloudFlare 会给你两个 NS 地址。</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630172007076.png" alt="image-20250630172007076"></p><p>把这两个地址复制粘贴回刚才的 NS 设置页面，保存。大功告成！以后你就可以在 CloudFlare 的后台，像管理顶级域名一样，自由地进行解析等各种操作了。</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630171900223.png" alt="image-20250630171900223"></p><p><strong>🔔 温馨提示：</strong> 这个免费域名需要每 180 天续期一次。别忘了设个提醒，不然过期了就没了哦！可以考虑看看我前几天发的无门槛搭建<strong>订阅到期通知服务</strong>的文章!</p><h3 id="方案二：一顿饭钱，买十年清净"><a href="#方案二：一顿饭钱，买十年清净" class="headerlink" title="方案二：一顿饭钱，买十年清净"></a>方案二：一顿饭钱，买十年清净</h3><p>☕ <strong>适合人群：</strong> 嫌免费麻烦，想让项目看起来更“正经”，追求一劳永逸的朋友。</p><p>好了，如果你跟我一样，觉得免费的终究有点“寄人篱下”的感觉，想给自己的项目一个体面的、真正属于自己的门牌号，那这个方案绝对是你的菜。</p><p><strong>我们的目标是：搞一个属于自己的 <code>.xyz</code> 顶级域名，并且用一顿快餐的钱，让它陪你十年。</strong></p><p>商家的套路通常是“首年白菜价，续费吓死人”。但我发现国外注册商 <strong>Spaceship</strong> 有个神奇的“Bug”（或者说福利）：</p><p><strong>你先按首年骨折价买 1 年。付完款，域名到手后，立刻回到后台，再给它续上 9 年。神奇的是，续费那 9 年的价格，居然和首年一样便宜！</strong></p><p><strong>具体操作，跟我来：</strong></p><ol><li>打开 <strong>Spaceship</strong> 官网 (<code>https://www.spaceship.com/zh</code>)，搜索你想注册的 <code>.xyz</code> 域名。<strong>小技巧：纯数字的域名通常最便宜。</strong></li></ol><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630192100245.png" alt="image-20250630192100245"></p><ol start="2"><li>下单，只买 <strong>1 年</strong>！可以用支付宝。结账时，把那些花里胡哨的附加服务（什么隐私保护、企业邮箱）的勾全部去掉，咱们不花一分冤枉钱。</li></ol><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630192041515.png" alt="image-20250630192041515"></p><ol start="3"><li><p>付完款，域名到手。别急着庆祝，立刻回到你的域名管理列表，找到它，点击【Renew】（续费）。</p></li><li><p>在续费页面，把年限拉满，选 <strong>9 年</strong>。你会看到，总价依然美丽到让你想笑出声。</p></li></ol><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630192233805.png" alt="image-20250630192233805"></p><p>搞定！<strong>总共也就四五十块钱，买断一个域名十年的使用权。</strong> 每年成本才几块钱，比一杯奶茶还便宜。从此，十年之内，续费这码事儿跟你再无关系。</p><p>后续同样可以把这个域名的 NS 修改到 CloudFlare，享受飞一般的解析和安全防护。</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250630192343313.png" alt="image-20250630192343313"></p><p>当然，如果你觉得 <code>.xyz</code> 不够高大上，等你的项目真的做起来了，再花钱去注册一个心仪的 <code>.com</code> 也不迟。但对于启动阶段来说，这个方案堪称完美。</p><hr><p>好了，两种方法都交给你了。一个是有点技术门槛的白嫖，一个是低到尘埃里的长期持有。</p><p>现在，“域名太贵”这个最烂的借口，可以从你的字典里永久删除了吧？</p><p>别再让灵感在硬盘里吃灰了。去，给你那个闪闪发光的点子，安个家吧！例如我前几天发的EdgeOne的教程,是不是可以用上这个域名了呢?</p>]]></content>
    
    
    <summary type="html">夜深人静，万籁俱寂，灵感“Duang”地一下砸你脸上，你一拍大腿：“天才啊！这个名字绝了！” 紧接着，你激动地打开浏览器，敲下那个你觉得能值一百万的域名。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="域名注册" scheme="https://www.wangwangit.com/tags/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>别再折腾FRP了！我用这个开源神器，让你无需公网IP，也能随时随地访问家里的任何设备</title>
    <link href="https://www.wangwangit.com/%E5%88%AB%E5%86%8D%E6%8A%98%E8%85%BEFRP%E4%BA%86%EF%BC%81%E6%88%91%E7%94%A8%E8%BF%99%E4%B8%AA%E5%BC%80%E6%BA%90%E7%A5%9E%E5%99%A8%EF%BC%8C%E8%AE%A9%E4%BD%A0%E6%97%A0%E9%9C%80%E5%85%AC%E7%BD%91IP%EF%BC%8C%E4%B9%9F%E8%83%BD%E9%9A%8F%E6%97%B6%E9%9A%8F%E5%9C%B0%E8%AE%BF%E9%97%AE%E5%AE%B6%E9%87%8C%E7%9A%84%E4%BB%BB%E4%BD%95%E8%AE%BE%E5%A4%87/"/>
    <id>https://www.wangwangit.com/%E5%88%AB%E5%86%8D%E6%8A%98%E8%85%BEFRP%E4%BA%86%EF%BC%81%E6%88%91%E7%94%A8%E8%BF%99%E4%B8%AA%E5%BC%80%E6%BA%90%E7%A5%9E%E5%99%A8%EF%BC%8C%E8%AE%A9%E4%BD%A0%E6%97%A0%E9%9C%80%E5%85%AC%E7%BD%91IP%EF%BC%8C%E4%B9%9F%E8%83%BD%E9%9A%8F%E6%97%B6%E9%9A%8F%E5%9C%B0%E8%AE%BF%E9%97%AE%E5%AE%B6%E9%87%8C%E7%9A%84%E4%BB%BB%E4%BD%95%E8%AE%BE%E5%A4%87/</id>
    <published>2025-07-02T04:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.764Z</updated>
    
    <content type="html"><![CDATA[<p>如果你跟我一样，手里有几台散落在不同地方的设备——比如家里的NAS、公司的开发机、自己随身的笔记本——那你肯定也折腾过怎么让它们方便地互相访问。</p><p>这事儿我折腾了好几年。</p><p>最开始，我用 frp 这类内网穿透工具。这东西很强，但有个绕不开的前提：你得有台公网服务器。为了这个“中转站”，我得花钱买服务器、操心续费、还得花时间配置和维护它。后来我又试了 ZeroTier 和 Tailscale，它们确实方便了很多，不用自己买服务器了，在官网点点鼠标就能组网。</p><p>但用久了还是觉得“差点意思”。ZeroTier 的免费节点在国外，有时候连接慢得像上世纪的拨号上网。想快？可以自建 Moon 中继，但这不又回到了“我得有台公网服务器”的原点吗？Tailscale 也是同理，官方的控制台虽好用，但想完全掌控，就得去折腾 Headscale 自建。</p><p>我就是想简单地把<strong>我自己的几台设备</strong>连起来，仅此而已，为什么总要依赖一个“中心”？</p><p>直到我扒拉 GitHub 的时候，翻到了 <strong>EasyTier</strong>。它的简介就一句话：一个用 Rust 写的 P2P 组网工具。我试了一下，好家伙，这正是我要找的“简单粗暴”的解决方案。</p><h3 id="一、动手前，先想明白一件事：你是要“开店”还是“回家”？"><a href="#一、动手前，先想明白一件事：你是要“开店”还是“回家”？" class="headerlink" title="一、动手前，先想明白一件事：你是要“开店”还是“回家”？"></a><strong>一、动手前，先想明白一件事：你是要“开店”还是“回家”？</strong></h3><p>在折腾这些工具之前，我踩过最大的坑就是没分清需求。其实就两类：</p><ol><li><p><strong>开店迎客 (服务发布):</strong> 你想把内网的某个网站或服务，让<strong>任何人</strong>都能通过一个域名访问到。这时候你用 <strong>frp、natapp、Cloudflare Tunnel</strong> 这类工具最合适。它们就像是给你在内网的小店，在互联网这条商业街上租了个临街门面。</p></li><li><p><strong>配一把家门钥匙 (设备组网):</strong> 你只想让你<strong>自己的设备</strong>（或者和你信得过的朋友）能互相访问，形成一个私密的圈子。这时候 <strong>ZeroTier、Tailscale、EasyTier</strong> 才是正解。它们等于给了你一套加密的对讲机，只有在同一个频道的人才能通话。</p></li></ol><p>对于大多数“个人使用”场景，我们真正需要的是<strong>设备组网</strong>，而不是把家里的服务暴露给全世界。明确了这一点，我们再来看看今天的主角 EasyTier。</p><h3 id="主流工具横向对比：Easytier到底牛在哪？"><a href="#主流工具横向对比：Easytier到底牛在哪？" class="headerlink" title="主流工具横向对比：Easytier到底牛在哪？"></a><strong>主流工具横向对比：Easytier到底牛在哪？</strong></h3><p>废话不多说，直接上表格，让你一目了然。</p><table><thead><tr><th align="left">特性</th><th align="left">Easytier</th><th align="left">ZeroTier &#x2F; Tailscale</th><th align="left">FRP &#x2F; Natapp</th><th align="left">Cloudflare Tunnel</th></tr></thead><tbody><tr><td align="left"><strong>核心原理</strong></td><td align="left">P2P虚拟局域网</td><td align="left">P2P虚拟局域网</td><td align="left">端口转发</td><td align="left">端口转发&#x2F;虚拟网络</td></tr><tr><td align="left"><strong>配置复杂度</strong></td><td align="left"><strong>极低</strong></td><td align="left">低</td><td align="left"><strong>高</strong></td><td align="left">中等</td></tr><tr><td align="left"><strong>依赖公网IP</strong></td><td align="left"><strong>需要（但可共用）</strong></td><td align="left">不需要</td><td align="left"><strong>需要</strong></td><td align="left">不需要</td></tr><tr><td align="left"><strong>中心化依赖</strong></td><td align="left"><strong>完全去中心化</strong></td><td align="left"><strong>依赖官方控制器</strong></td><td align="left">自建服务端，半中心化</td><td align="left">依赖Cloudflare</td></tr><tr><td align="left"><strong>安全性&#x2F;隐私</strong></td><td align="left"><strong>极高（流量端到端加密）</strong></td><td align="left">高（依赖官方）</td><td align="left">中等（取决于自己配置）</td><td align="left">高（依赖Cloudflare）</td></tr><tr><td align="left"><strong>使用场景</strong></td><td align="left">个人&#x2F;小团队私有网络</td><td align="left">个人&#x2F;企业级便捷组网</td><td align="left">将内网服务暴露到公网</td><td align="left">将服务接入CF生态</td></tr><tr><td align="left"><strong>我的评价</strong></td><td align="left">简单、私密、自由</td><td align="left"><strong>最方便</strong>，但有束缚</td><td align="left">功能强大，但<strong>太折腾</strong></td><td align="left">免费用户的福音，但有绑定</td></tr></tbody></table><p><strong>一句话总结：</strong></p><ul><li><strong>FRP</strong>：适合需要将服务（如网站）明确暴露到公网的场景。</li><li><strong>ZeroTier&#x2F;Tailscale</strong>：追求极致方便，不介意依赖第三方服务的个人和团队首选。</li><li><strong>Cloudflare Tunnel</strong>：如果你已经是Cloudflare用户，用它整合服务体验极佳。</li><li><strong>Easytier</strong>：<strong>想要ZeroTier的方便，又想要FRP的自主可控，那么Easytier就是为你量身定做的。</strong></li></ul><h3 id="二、Easytier-实战：三步搭建你的专属私有网络"><a href="#二、Easytier-实战：三步搭建你的专属私有网络" class="headerlink" title="二、Easytier 实战：三步搭建你的专属私有网络"></a><strong>二、Easytier 实战：三步搭建你的专属私有网络</strong></h3><p><strong>项目地址</strong>: <a href="https://easytier.cn/">https://easytier.cn</a></p><ul><li><a href="https://easytier.cn/guide/installation.html">🛠️安装 CLI 页面</a> 可查看安装命令行工具的方法。</li><li><a href="https://easytier.cn/guide/installation_gui.html">🖥️安装 GUI 页面</a> 可查看安装图形界面工具的方法。</li><li><a href="https://easytier.cn/guide/download.html">⬇️下载页面</a> 可获取最新版本 EasyTier 的下载链接。</li></ul><p>以GUI为例,我们下载之后安装即可</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250629122714749.png" alt="image-20250629122714749"></p><p>我们只需要配置一个网络名称和密码,保持默认的公共服务器配置,点击运行网络,就完成操作了!</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250629122832070.png" alt="image-20250629122832070"></p><p>然后,我们在另外一个设备上执行同样的操作,如手机上!APP也在刚刚的地址进行下载!</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250629123220272.png" alt="image-20250629123220272"></p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250629123229453.png" alt="image-20250629123229453"></p><p>这样组网就成功了,我们就可以用这个虚拟的ipv4地址互相连接了! 比如我用手机通过虚拟IP远程电脑!</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250629123616788.png" alt="image-20250629123616788"></p><h3 id="三、搭建共享节点"><a href="#三、搭建共享节点" class="headerlink" title="三、搭建共享节点"></a>三、搭建共享节点</h3><p>你已经学会了最基础的“一个介绍人（Server） + N个客户端（Client）”模式，这对于大多数场景已经够用。但如果你是下面这几种人：</p><ul><li><strong>极致的掌控者：</strong> 不希望自己的网络依赖于任何单一的服务器。</li><li><strong>高可用追求者：</strong> 万一那台唯一的公网VPS挂了怎么办？整个网络就瘫痪了！</li><li><strong>乐于分享者：</strong> 想和几个朋友共建一个稳定、互备的网络基础设施。</li></ul><p>那么，欢迎来到Easytier的精髓所在：<strong>自建高可用、去中心化的“根”节点网络</strong>。</p><p>官方提供了一些共享节点,<strong>地址</strong> : <a href="https://easytier.gd.nkbpal.cn/status/easytier">https://easytier.gd.nkbpal.cn/status/easytier</a></p><p>同样的,如果你有云服务器,也可以选择自建节点,执行下面两个命令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget -O /tmp/easytier.sh <span class="string">&quot;https://raw.githubusercontent.com/EasyTier/EasyTier/main/script/install.sh&quot;</span> &amp;&amp; bash /tmp/easytier.sh install</span><br><span class="line">easytier-core --ipv4 10.144.144.1</span><br></pre></td></tr></table></figure><p>然后一个自用的服务器,就搭建好了,只需要在GUI界面调整为自己服务器的IP,端口默认是11010,如下图.</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250629124834143.png" alt="image-20250629124834143"></p><p>就可以正常使用了!针对这款软件的更多高级配置,可以前往官方查看教程!</p><h3 id="四、常见问题-FAQ"><a href="#四、常见问题-FAQ" class="headerlink" title="四、常见问题 FAQ"></a><strong>四、常见问题 FAQ</strong></h3><p><strong>Q1: 我没有公网服务器怎么办？</strong><br><strong>A:</strong> Easytier的精髓就在于P2P直连，服务器只做“牵线”。你可以和三五好友合租一台最便宜的境外VPS，成本极低。或者，直接使用官方提供的公共服务器!</p><p><strong>Q2: 连接上了，但是ping不通，速度很慢？</strong><br><strong>A:</strong> 99%的可能性是P2P打洞失败，流量正在通过你的低配服务器进行转发。检查：</p><ol><li>客户端所在的网络防火墙是否限制了UDP通信（比如某些严格的公司网络）。</li><li>NAT类型是否过于严格（比如多层NAT）。<br>不过，即使转发，基本的功能访问也是没问题的，只是速度慢一些。</li></ol><p><strong>Q3: Easytier安全吗？</strong><br><strong>A:</strong> 非常安全。首先，你的网络是完全私有的，由你自己的密码保护。其次，所有节点之间的通信都经过了端到端加密。只要你的服务器和密码不泄露，这就是你的专属加密通道。</p><p><strong>Q4: 和ZeroTier相比，它到底有什么杀手级优势？</strong><br><strong>A:</strong> <strong>自主可控！</strong> 你的网络拓扑、成员、IP分配，所有的一切都由那个小小的 <code>easytier</code> 程序在你自己的服务器上处理，不经过任何第三方。对于有数据洁癖和想深入理解网络原理的人来说，这种掌控感是无价的。</p><h3 id="总结：哪一个才是你的菜？"><a href="#总结：哪一个才是你的菜？" class="headerlink" title="总结：哪一个才是你的菜？"></a><strong>总结：哪一个才是你的菜？</strong></h3><p>工具没有最好的，只有最合适的。</p><ul><li>如果你需要<strong>对外发布服务</strong>，让公网用户访问，请选择 <strong>frp</strong> 或 <strong>Cloudflare Tunnel</strong>。</li><li>如果你是<strong>个人开发者或数码爱好者</strong>，只想简单、快速地将自己的几台电脑、服务器、NAS组成一个“私有互联网”，并且<strong>极其看重简单性</strong>，讨厌复杂的配置，那么 <strong>EasyTier</strong> 绝对值得一试。它的去中心化理念和极简的上手体验，能为你节省大量时间。</li><li>如果你在寻找一个<strong>功能全面、生态成熟、有商业支持</strong>的团队或企业级组网方案，或者你需要频繁在手机端使用，那么 <strong>Tailscale</strong> 和 <strong>ZeroTier</strong> 依然是当前最稳妥、最强大的选择。</li></ul><p>对我个人而言，EasyTier 已经成为我个人设备组网的首选工具。它完美地满足了我对“简单、可靠、自己掌控”的需求。希望这篇文章能帮你理清思路，找到最适合你的那个“它”。</p>]]></content>
    
    
    <summary type="html">如果你跟我一样，手里有几台散落在不同地方的设备——比如家里的NAS、公司的开发机、自己随身的笔记本——那你肯定也折腾过怎么让它们方便地互相访问。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="内网穿透" scheme="https://www.wangwangit.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>告别“降智编程”：Claude Code 终极指南与平替方案</title>
    <link href="https://www.wangwangit.com/%E5%91%8A%E5%88%AB%E2%80%9C%E9%99%8D%E6%99%BA%E7%BC%96%E7%A8%8B%E2%80%9D%EF%BC%9AClaude%20Code%20%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97%E4%B8%8E%E5%B9%B3%E6%9B%BF%E6%96%B9%E6%A1%88/"/>
    <id>https://www.wangwangit.com/%E5%91%8A%E5%88%AB%E2%80%9C%E9%99%8D%E6%99%BA%E7%BC%96%E7%A8%8B%E2%80%9D%EF%BC%9AClaude%20Code%20%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97%E4%B8%8E%E5%B9%B3%E6%9B%BF%E6%96%B9%E6%A1%88/</id>
    <published>2025-07-01T04:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.764Z</updated>
    
    <content type="html"><![CDATA[<p>如果你是那种喜欢刨根问底、不满足于现成工具，并热衷于打造属于自己工作流的开发者，那么这篇文章就是为你准备的。</p><p>AI 编码工具的浪潮，从 Cursor 到 Augment，让不少人陷入了选择的狂热。但当大家还未从眼花缭乱的第三方 GUI 工具中回过神，Google 和 Anthropic 已经带着官方的 CLI 工具入场，试图将 AI 能力更原生、更深刻地植入开发者的核心地带——终端。</p><p>之前我们聊过了 Google 的 Gemini CLI，今天的主角是 <strong>Claude Code</strong>——一个在许多人看来更为强劲的对手。得益于背后 Claude 模型的强大编码和推理能力，它在真实开发场景中的表现常常令人惊艳。</p><p>这份教程将直奔主题，不仅包含标准安装流程，更会把重点放在“终极玩法”上：如何通过搭建中转代理，用成本更低的 Gemini 或 Copilot API 来驱动 Claude Code，实现高性价比的体验。</p><p><strong>在开始前，请确认以下几点：</strong></p><ol><li><strong>Windows 用户注意：</strong> 本工具需要在 WSL (Windows Subsystem for Linux) 环境下运行。如果你的 Windows 系统尚未配置 WSL，可以参考这份完整指南：<a href="https://www.wangwangit.com/WSL%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97-%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8,%E8%AE%A9%E4%BD%A0%E7%9A%84Windows%E5%A6%82%E8%99%8E%E6%B7%BB%E7%BF%BC/">《WSL完全指南：从安装到进阶使用，让你的Windows如虎添翼》</a>。后续步骤默认以 Linux 环境演示。</li><li><strong>关于成本：</strong> 官方订阅不便宜，但我们有解决方案。</li><li><strong>官方文档：</strong> 本文不赘述所有命令，需要全面参考可前往官方文档：<a href="https://docs.anthropic.com/zh-CN/docs/claude-code/overview">Claude Code Overview</a>。</li><li><strong>网络与系统要求：</strong> 运行本工具需要<strong>科学的网络环境</strong>。系统需为 macOS 10.15+，或主流 Linux 发行版（如 Ubuntu 20.04+&#x2F;Debian 10+），并拥有至少 4GB 内存。</li></ol><h3 id="一、基础入门：标准安装与配置"><a href="#一、基础入门：标准安装与配置" class="headerlink" title="一、基础入门：标准安装与配置"></a>一、基础入门：标准安装与配置</h3><p>首先，我们走一遍官方流程。以下步骤以 Ubuntu&#x2F;Debian 环境为例，其他系统请相应调整包管理命令。</p><p><strong>1. 准备 Node.js 环境</strong><br>确保系统中已安装 Node.js v18 或更高版本。通过 <code>node --version</code> 检查。若未安装，可从 <a href="https://nodejs.org/zh-cn/download">Node.js 官网</a> 获取并按说明安装。</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250629083243414.png"></p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250629083350930.png"></p><p><strong>2. 全局安装 Claude Code</strong><br>在终端中执行以下命令。官方不建议使用 <code>sudo</code>，以避免潜在的权限冲突。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @anthropic-ai/claude-code</span><br></pre></td></tr></table></figure><p><strong>3. 账户认证</strong><br>首次运行 <code>claude</code> 命令时，系统会引导你通过浏览器登录 Anthropic 账户进行授权。你需要具备以下任一条件才能通过认证：</p><ul><li><strong>Claude Pro&#x2F;Max 订阅：</strong> 已订阅 Claude.ai 付费套餐的用户可直接使用。</li><li><strong>Anthropic API Key：</strong> 在 Anthropic 官网控制台创建 API 密钥，并绑定支付方式（按量计费）。</li></ul><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250629083547716.png" alt="image-20250629083547716"></p><p>如果你的账号满足条件，可直接继续。若不满足，或者你更喜欢“折腾”，请直接跳到下一章节。</p><h3 id="二、高级玩法：搭建-API-中转，实现自由驱动"><a href="#二、高级玩法：搭建-API-中转，实现自由驱动" class="headerlink" title="二、高级玩法：搭建 API 中转，实现自由驱动"></a>二、高级玩法：搭建 API 中转，实现自由驱动</h3><p>这是本篇的精华，也是最能体现极客精神的部分。我们将通过搭建一个本地“中转代理”服务，拦截 Claude Code 发出的请求，将其转换为其他 API（如 Gemini）的格式，从而绕过官方订阅。</p><p><strong>核心原理：</strong><br>Claude Code CLI 允许通过设置环境变量 <code>ANTHROPIC_BASE_URL</code> 来指定 API 请求的地址。我们将利用此特性，将其指向我们自己搭建的本地代理服务器。</p><p><strong>推荐方案：使用 <code>claude-code-proxy</code> 项目</strong></p><p>这个项目非常强大，不仅支持 Gemini，还能代理任何兼容 OpenAI 格式的 API（例如 NewAPI 等转发服务）。下面是详细的实操步骤。</p><p><strong>地址</strong>：<a href="https://github.com/1rgs/claude-code-proxy">1rgs&#x2F;claude-code-proxy on GitHub</a></p><p><strong>1. 克隆项目仓库</strong><br>首先，确保你的 Linux 系统已安装 <code>git</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># (Debian/Ubuntu 系统)</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250629084501380.png" alt="image-20250629084501380"></p><p>然后，克隆代理项目仓库。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/1rgs/claude-code-openai.git</span><br><span class="line"><span class="built_in">cd</span> claude-code-openai</span><br></pre></td></tr></table></figure><p><strong>2. 安装 <code>uv</code> 包管理器</strong><br>该项目推荐使用 <code>uv</code>，一个极速的 Python 包管理器。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -LsSf https://astral.sh/uv/install.sh | sh</span><br></pre></td></tr></table></figure><p><strong>3. 配置环境变量</strong><br>复制示例环境文件，然后编辑它。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> .env.example .<span class="built_in">env</span></span><br></pre></td></tr></table></figure><p>你需要一个命令行文本编辑器，如 <code>vim</code>。若不熟悉，可以使用 <code>nano</code>，或者通过 MobaXterm 等 SSH 工具直接在图形界面中编辑文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 vim 编辑 .env 文件</span></span><br><span class="line">vim .<span class="built_in">env</span></span><br></pre></td></tr></table></figure><p>在 <code>.env</code> 文件中，根据你的需求填写以下关键信息：</p><ul><li><code>GEMINI_API_KEY</code>：<strong>（必需）</strong> 你的 Google AI Studio (Gemini) API 密钥。</li><li><code>OPENAI_API_KEY</code>：如果你的首选是 OpenAI 或想将其作为备用，则填写。</li><li><code>PREFERRED_PROVIDER</code>：（可选）首选后端，<code>google</code> (默认) 或 <code>openai</code>。</li><li><code>BIG_MODEL</code> &#x2F; <code>SMALL_MODEL</code>：（可选）模型映射，可指定将 Claude 的 <code>sonnet</code> 和 <code>haiku</code> 请求分别映射到哪个具体模型。</li><li><code>OPENAI_API_BASE</code>：（可选，<strong>高能</strong>）用于配置第三方 OpenAI 兼容的 API 地址，比如硅基流动或其他中转服务。</li></ul><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250629090146358.png" alt="image-20250629090146358"></p><p><strong>4. 启动代理服务</strong><br>确保当前位于项目目录下，执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uvicorn server:app --host 0.0.0.0 --port 8082 --reload</span><br></pre></td></tr></table></figure><p>为了让服务在后台持续运行，可以使用 <code>nohup</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> uvicorn server:app --host 0.0.0.0 --port 8082 &gt; gemini.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250629090423823.png" alt="image-20250629090423823"></p><p><strong>5. 连接 Claude Code 至代理</strong><br>现在，打开一个新的终端窗口，使用以下命令启动 Claude Code：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ANTHROPIC_BASE_URL=http://localhost:8082 claude</span><br></pre></td></tr></table></figure><p>首次连接时，可能会提示你选择授权方式，选择 <code>2. Use an existing API key</code> 即可。</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250629093100100.png" alt="image-20250629093100100"></p><p><strong>深度定制：</strong><br>这个代理项目默认只映射了几个模型。若想支持更多模型，可以直接修改 <code>server.py</code> 文件中的模型映射逻辑，添加你自己的规则。这正是折腾的乐趣所在。</p><p><img src="https://img1.wangwangit.com/wangwangit/image/refs/heads/master/img1/image-20250629100041990.png" alt="image-20250629100041990"></p><h3 id="三-其他项目推荐"><a href="#三-其他项目推荐" class="headerlink" title="三.其他项目推荐"></a>三.其他项目推荐</h3><p><strong>copilot-api</strong>: 将github copilot转为支持claude code的api</p><blockquote><p><a href="https://github.com/ericc-ch/copilot-api">https://github.com/ericc-ch/copilot-api</a></p></blockquote><p><strong>claudia</strong>: claude code图形化界面</p><blockquote><p><a href="https://github.com/getAsterisk/claudia">https://github.com/getAsterisk/claudia</a></p></blockquote><h3 id="总结与忠告"><a href="#总结与忠告" class="headerlink" title="总结与忠告"></a>总结与忠告</h3><p>Claude Code 无疑是一款设计精良、交互出色的终端 AI 工具。其对项目上下文的深度理解能力和对隐私的承诺，使其成为专业开发者的利器。</p><p>现在，摆在你面前有两条路：</p><ol><li><strong>官方渠道：</strong> 如果你追求极致的稳定、安全和性能，或者在商业项目中使用，开通官方订阅是最佳选择。这是最可靠、最省心的方式。</li><li><strong>社区玩法：</strong> 对于热爱探索、预算有限的极客用户，通过 API 中转的“黑魔法”确实解决了最大的成本障碍。但请务必意识到，<strong>这类第三方方案存在不稳定的风险</strong>，上游 API 的策略调整或代理项目的停更都可能导致其失效。</li></ol><p>最后，我想说，工具的选择服务于目的。如果你的需求不那么复杂，市面上优秀的 GUI 工具如 <strong>Cursor</strong>、<strong>Augment</strong> 也是不错的选择，它们提供了更低的上手门槛。</p><p>而对于那些和我们一样，热衷于在命令行中追求极致效率的开发者，GitHub 是一个巨大的宝库。主动去搜索、发现和尝试更多类似 <code>claude-code-proxy</code> 的项目，你将解锁更多意想不到的玩法。</p><p>无论如何，花点时间掌握一款强大的 AI 终端工具，都是对未来开发效率的一次明智投资。</p>]]></content>
    
    
    <summary type="html">之前我们聊过了 Google 的 Gemini CLI，今天的主角是 **Claude Code**——一个在许多人看来更为强劲的对手。得益于背后 Claude 模型的强大编码和推理能力，它在真实开发场景中的表现常常令人惊艳。</summary>
    
    
    
    <category term="AI" scheme="https://www.wangwangit.com/categories/AI/"/>
    
    
    <category term="开发工具" scheme="https://www.wangwangit.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>别再到处找工具了！这个导航站，承包你的所有需求</title>
    <link href="https://www.wangwangit.com/%E5%88%AB%E5%86%8D%E5%88%B0%E5%A4%84%E6%89%BE%E5%B7%A5%E5%85%B7-%E8%BF%99%E4%B8%AA%E5%AF%BC%E8%88%AA%E7%AB%99-%E6%89%BF%E5%8C%85%E4%BD%A0%E7%9A%84%E6%89%80%E6%9C%89%E9%9C%80%E6%B1%82/"/>
    <id>https://www.wangwangit.com/%E5%88%AB%E5%86%8D%E5%88%B0%E5%A4%84%E6%89%BE%E5%B7%A5%E5%85%B7-%E8%BF%99%E4%B8%AA%E5%AF%BC%E8%88%AA%E7%AB%99-%E6%89%BF%E5%8C%85%E4%BD%A0%E7%9A%84%E6%89%80%E6%9C%89%E9%9C%80%E6%B1%82/</id>
    <published>2025-06-25T22:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.763Z</updated>
    
    <content type="html"><![CDATA[<p>我相信你肯定遇到过这种情况!</p><p>朋友火急火燎地跑来问你：“快！有没有好用的在线PDF合并工具？急用！”<br>你从收藏夹深处扒拉出一个链接，发过去。<br>过了一会儿，他又问：“上次你说的那个能下载高清壁纸的网站是啥来着？”<br>你叹了口气，又是一通好找。</p><p>我们这些喜欢在网上“寻宝”的人，手里总攥着一把“神兵利器”。但这些宝贝零散地躺在收藏夹里，不仅自己找着费劲，分享给别人时也显得特别零碎。</p><p>我就是那个老被朋友追着要网址的人。为了“一劳永逸”，也为了满足我那点小小的、藏不住的分享欲，我干脆给自己做了一个专属的导航站。</p><p>今天，我决定不藏私了，把它整个分享出来。</p><p><img src="https://img.996007.icu/file/img1/image-20250626193007877.png" alt="image-20250626193007877"></p><p>这里面，是我多年冲浪生涯里，精挑细选出的网站。从<strong>系统下载、PDF处理、书籍查询、临时邮箱、短信接码、影视动漫</strong>，到各种有趣的在线工具，我都分门别类地放好了。你可以把它当成一个开箱即用的“资源仓库”。</p><p>当然，我的收藏肯定不是最全的。如果你有更棒的、更野的网站推荐，欢迎来我的**公众号「一只会飞的旺旺」**后台告诉我，让我们一起共建，造福所有需要的人！</p><h2 id="🚀-快速部署"><a href="#🚀-快速部署" class="headerlink" title="🚀 快速部署"></a>🚀 快速部署</h2><blockquote><p><strong>准备工作</strong>: 你需要一个 Cloudflare 账号。<a href="https://dash.cloudflare.com/">https://dash.cloudflare.com</a></p></blockquote><h3 id="🖼️-效果预览"><a href="#🖼️-效果预览" class="headerlink" title="🖼️ 效果预览"></a>🖼️ 效果预览</h3><table><thead><tr><th align="center">首页</th><th align="center">后台管理</th></tr></thead><tbody><tr><td align="center"><img src="https://github.com/user-attachments/assets/b12755c5-7669-408f-be05-2db6ba1b02cc" alt="首页预览"></td><td align="center"><img src="https://github.com/user-attachments/assets/d387794d-95f8-42e9-879d-41fc6c5f5fa8" alt="后台预览"></td></tr></tbody></table><h3 id="步骤-1-创建-D1-数据库"><a href="#步骤-1-创建-D1-数据库" class="headerlink" title="步骤 1: 创建 D1 数据库"></a>步骤 1: 创建 D1 数据库</h3><ol><li><p>在 Cloudflare 控制台，进入 <code>Workers &amp; Pages</code> -&gt; <code>D1</code>。</p></li><li><p>点击 <code>创建数据库</code>，数据库名称输入 <code>book</code>，然后创建。</p><p><img src="https://github.com/user-attachments/assets/f49d61ea-a87b-42ed-a460-98e53fb340e0" alt="创建D1数据库"></p></li><li><p>进入数据库的<code>控制台</code>，执行下方的 SQL 语句来快速创建所需的表结构。(注意移除中文注释)</p><p><img src="https://github.com/user-attachments/assets/be10c3a0-a862-467a-8114-d5c5c8e48d2a" alt="执行SQL"></p></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建已发布网站表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> sites (</span><br><span class="line">id <span class="type">INTEGER</span> <span class="keyword">PRIMARY KEY</span> AUTOINCREMENT,</span><br><span class="line">name TEXT <span class="keyword">NOT NULL</span>,</span><br><span class="line">url TEXT <span class="keyword">NOT NULL</span>,</span><br><span class="line">logo TEXT,</span><br><span class="line">&quot;desc&quot; TEXT,</span><br><span class="line">catelog TEXT <span class="keyword">NOT NULL</span>,</span><br><span class="line">status TEXT,</span><br><span class="line">sort_order <span class="type">INTEGER</span> <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">9999</span>,</span><br><span class="line">create_time DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">update_time DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建待审核网站表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> pending_sites (</span><br><span class="line">id <span class="type">INTEGER</span> <span class="keyword">PRIMARY KEY</span> AUTOINCREMENT,</span><br><span class="line">name TEXT <span class="keyword">NOT NULL</span>,</span><br><span class="line">url TEXT <span class="keyword">NOT NULL</span>,</span><br><span class="line">logo TEXT,</span><br><span class="line">&quot;desc&quot; TEXT,</span><br><span class="line">catelog TEXT <span class="keyword">NOT NULL</span>,</span><br><span class="line">status TEXT,</span><br><span class="line">create_time DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>: 使用 SQL 是最快捷的方式。如果你想手动建表，请确保字段名、类型与上述 SQL 一致。</p></blockquote><h3 id="步骤-2-创建-KV-存储"><a href="#步骤-2-创建-KV-存储" class="headerlink" title="步骤 2: 创建 KV 存储"></a>步骤 2: 创建 KV 存储</h3><ol><li><p>在 Cloudflare 控制台，进入 <code>Workers &amp; Pages</code> -&gt; <code>KV</code>。</p></li><li><p>点击 <code>创建命名空间</code>，名称输入 <code>NAV_AUTH</code>。</p><p><img src="https://github.com/user-attachments/assets/ed274f2d-2bf0-4f26-aa86-90e22286e94b" alt="创建KV"></p></li><li><p>创建后，为此 KV 添加两个条目，用于设置后台登录的 <strong>用户名</strong> 和 <strong>密码</strong>。</p><ul><li><strong>admin_username</strong>: 你的管理员用户名（例如 <code>admin</code>）</li><li><strong>admin_password</strong>: 你的管理员密码</li></ul><p><img src="https://github.com/user-attachments/assets/2fd5742f-5709-4ad9-b4fa-865cbca0bb8e" alt="设置KV键值对"></p></li></ol><h3 id="步骤-3-创建并部署-Worker"><a href="#步骤-3-创建并部署-Worker" class="headerlink" title="步骤 3: 创建并部署 Worker"></a>步骤 3: 创建并部署 Worker</h3><ol><li><p>回到 <code>Workers &amp; Pages</code>，点击 <code>创建应用程序</code> -&gt; <code>创建 Worker</code>。</p></li><li><p>为你的 Worker 指定一个名称（例如 <code>my-nav</code>），然后点击 <code>部署</code>。</p><p><img src="https://github.com/user-attachments/assets/02c3d4c4-6746-45fe-a428-516023fed880" alt="创建Worker"></p></li><li><p>部署后，点击 <code>编辑代码</code>。将本项目 <code>worker1.js</code> 文件中的所有代码复制并粘贴到编辑器中，替换掉原有内容。</p></li><li><p>点击 <code>部署</code> 保存代码。</p><p><img src="https://github.com/user-attachments/assets/f2f4fe86-aab1-4805-9ba3-bac8b889875d" alt="编辑并部署代码"></p></li></ol><h3 id="步骤-4-绑定服务"><a href="#步骤-4-绑定服务" class="headerlink" title="步骤 4: 绑定服务"></a>步骤 4: 绑定服务</h3><ol><li><p>进入你刚刚创建的 Worker 的 <code>设置</code> -&gt; <code>变量</code>。</p></li><li><p>在 <strong>D1 数据库绑定</strong> 中，点击 <code>添加绑定</code>：</p><ul><li>变量名称: <code>NAV_DB</code></li><li>D1 数据库: 选择你创建的 <code>book</code></li></ul></li><li><p>在 <strong>KV 命名空间绑定</strong> 中，点击 <code>添加绑定</code>：</p><ul><li>变量名称: <code>NAV_AUTH</code></li><li>KV 命名空间: 选择你创建的 <code>NAV_AUTH</code></li></ul><p><img src="https://github.com/user-attachments/assets/269f4678-4e8a-4dbd-a8d7-f186466f4380" alt="绑定服务"></p></li></ol><h3 id="步骤-5-开始使用"><a href="#步骤-5-开始使用" class="headerlink" title="步骤 5: 开始使用"></a>步骤 5: 开始使用</h3><ol><li><p>访问你的 Worker 域名（例如 <code>my-nav.your-subdomain.workers.dev</code>）。首次访问会提示没有数据。</p></li><li><p>访问 <code>你的域名/admin</code> 进入后台，使用你在 <strong>步骤 2</strong> 中设置的用户名和密码登录。</p></li><li><p>在后台添加第一个书签后，首页即可正常显示。</p><p><img src="https://github.com/user-attachments/assets/284e3560-284f-4313-a7c6-d651d2e25c00" alt="后台登录"></p></li></ol>]]></content>
    
    
    <summary type="html">我就是那个老被朋友追着要网址的人。为了“一劳永逸”，也为了满足我那点小小的、藏不住的分享欲，我干脆给自己做了一个专属的导航站。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="工具" scheme="https://www.wangwangit.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="导航站" scheme="https://www.wangwangit.com/tags/%E5%AF%BC%E8%88%AA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>和 AI 搭档的每一天，我都离不开这些 MCP 工具</title>
    <link href="https://www.wangwangit.com/%E5%92%8C%20AI%20%E6%90%AD%E6%A1%A3%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9%EF%BC%8C%E6%88%91%E9%83%BD%E7%A6%BB%E4%B8%8D%E5%BC%80%E8%BF%99%E4%BA%9B%20MCP%20%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.wangwangit.com/%E5%92%8C%20AI%20%E6%90%AD%E6%A1%A3%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9%EF%BC%8C%E6%88%91%E9%83%BD%E7%A6%BB%E4%B8%8D%E5%BC%80%E8%BF%99%E4%BA%9B%20MCP%20%E5%B7%A5%E5%85%B7/</id>
    <published>2025-06-25T22:25:00.000Z</published>
    <updated>2025-09-01T06:44:09.764Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.996007.icu/file/1752150015950_20250710202003992.png" alt="ChatGPT Image 2025年7月10日 20_19_52"></p><p>AI 工具的发展可谓日新月异，相信很多人都已经尝试过各类 AI 编程工具了。这些工具的出现，让即便从未接触过编程的用户，也能快速创建出属于自己的网站和应用程序。</p><p>如果你像我一样，每天都与 Cursor、Claude 或 GitHub Copilot 这样的 AI 编程助手并肩作战，那么接下来的场景对你来说一定再熟悉不过了：</p><p>AI 时而像个天才，轻松帮你写出复杂而精妙的算法；时而却又像个健忘的实习生，满怀自信地提供过时的库函数用法，甚至凭空“幻觉”出一个根本不存在的 API。</p><p>于是，我经常发现自己陷入了一个令人哭笑不得的循环：不断地将最新的官方文档、API 规范、详细的文件结构反复复制粘贴到聊天窗口里，只为给这个强大的“大脑”补充它急需的“短期记忆”和“项目感官”。</p><p>相信这也是很多人使用 AI 编程工具时经常面临的痛点。那么，今天我们就来探讨一下，如何通过 MCP 技术来提升 AI 编程工具的能力。如今，主流的 AI 编程助手纷纷开始支持 MCP 集成，配置简单，开箱即用，比如下图所示的 Cursor 配置界面。</p><p><img src="https://img.996007.icu/file/1752147449776_20250710193719476.png" alt="image-20250710193719419"></p><p>在此之前,若是你还不太了解MCP,可以看一下我以前写的一篇自学教程</p><blockquote><p><a href="https://mp.weixin.qq.com/s/IHufQZA48rB_cevl0bdWcw">https://mp.weixin.qq.com/s/IHufQZA48rB_cevl0bdWcw</a></p></blockquote><p>今天，我想聊点更实在的：在日常开发中，我们到底该用哪些 MCP 服务？它们又是如何实实在在改变我的工作流的？</p><p>下面这张表，是我正在使用的一些MCP服务,推荐给大家!</p><table><thead><tr><th>MCP服务器名称</th><th>核心功能</th><th>我的使用场景</th></tr></thead><tbody><tr><td><code>apifox-mcp-server</code></td><td>让AI直接读取Apifox中的API文档，杜绝猜测</td><td>帮助我们对接任何内外部 API，特别是企业微信、飞书这类。</td></tr><tr><td><code>context7</code></td><td>为AI提供最新的库和框架文档，避免过时代码</td><td>写 Next.js、React 或其他快速迭代的前端项目。</td></tr><tr><td><code>sequential-thinking</code></td><td>引导AI进行结构化的、分步骤的复杂问题思考</td><td>规划复杂算法、重构老代码或设计新模块。</td></tr><tr><td><code>playwright</code></td><td>賦予AI自动化操作和测试网页的能力</td><td>编写端到端测试、网页内容抓取、自动化UI操作</td></tr><tr><td><code>shrimp-task-manager</code></td><td>AI的项目管理系统，进行任务规划、分析和反思</td><td>管理复杂的开发任务，实现从需求到代码的全流程</td></tr><tr><td><code>mcp-deepwiki</code></td><td>帮助AI快速理解任何GitHub仓库的结构和文档</td><td>新人上手项目、理解陌生代码库或进行代码审计</td></tr><tr><td><code>edgeone-pages-mcp</code></td><td>让AI一键将静态内容部署到腾讯云EdgeOne</td><td>快速发布和迭代静态网站、Demo页面或文档</td></tr></tbody></table><hr><h3 id="apifox-mcp-server"><a href="#apifox-mcp-server" class="headerlink" title="apifox-mcp-server"></a>apifox-mcp-server</h3><p>最近我在写一个订阅管理平台，需要接入企业微信做消息通知。按照老办法，我得一边开着企业微信的开发者文档，一边开着代码编辑器，手动查找、核对、编写 API 调用代码，极其繁琐。</p><p>apifox-mcp-server 完美解决了这个问题。它能让我的 AI 助手直接访问并“读懂”我存放在 Apifox 项目里的 OpenAPI 规范。这意味着 AI 获取的不再是我投喂的、模糊的文本描述，而是完全结构化、机器可读的 API“蓝图”。</p><p>我是这么做的：</p><p><strong>第一步：在 Apifox 中准备 API 文档</strong></p><p>我先把企业微信的应用消息 API 在 Apifox 里整理好（如果你用的 API 在 Apifox 广场有，直接克隆就行）。</p><p><img src="https://img.996007.icu/file/1752145449265_20250710190403458.png" alt="image-20250710190356322"></p><p><img src="https://img.996007.icu/file/1752145520850_20250710190509050.png" alt="image-20250710190508955"></p><p><strong>第二步：开启 MCP 服务并获取配置</strong></p><blockquote><p><strong>注意：</strong> 确保你的 Apifox 版本不低于 2.7.2。</p></blockquote><p>在 Apifox 项目里，依次点击【分享文档】-&gt;【发布文档站】-&gt;【AI 功能】，然后打开“开启 MCP 服务”的开关。</p><p><img src="https://img.996007.icu/file/1752145895698_20250710191128839.png" alt="image-20250710191128740"></p><p>访问在线文档的接口时，页面将显示 「AI 编程（使用 MCP）」按钮。</p><p><img src="https://img.996007.icu/file/1752145963372_20250710191230816.png" alt="image-20250710191230718"></p><p>点击后，Apifox 会生成一段 JSON 配置。这份配置里包含了 MCP 服务的地址和你的项目 ID。</p><p><img src="https://img.996007.icu/file/1752146028234_20250710191336022.png" alt="image-20250710191335915"></p><p><strong>第三步：配置到 Cursor（或其他开发工具）</strong></p><p>我把这段 JSON 复制到我的 Cursor 编辑器的MCP配置文件里。关键的一步是，要把配置里的 ACCESS_TOKEN 替换成我自己的 Apifox 个人访问令牌。这个令牌可以在 Apifox 的【个人设置】-&gt;【访问令牌】里生成。</p><p><img src="https://img.996007.icu/file/1752146067906_20250710191422555.png" alt="image-20250710191422430"></p><blockquote><p>注意: 每个需要 AI 感知的 Apifox 项目，都需要这样单独配置一份 MCP。</p></blockquote><p><strong>实战：让 AI 实现企业微信消息发送</strong></p><p>配置完成后，我们测试一下让AI去获取企业微信API,如下图</p><p><img src="https://img.996007.icu/file/1752146318311_20250710191828773.png" alt="image-20250710191828687"></p><ol><li><strong>提问：</strong> “请帮我实现一个功能，调用企业微信的‘发送应用消息’接口，发送一个文本卡片消息。”</li><li><strong>AI 的行动：</strong> 我能清楚地看到，AI 并没有开始“瞎猜”，而是立刻调用了 apifox-mcp-server，去查询我配置好的企业微信项目里，关于 message&#x2F;send 这个端点的 OpenAPI 规范。</li><li><strong>AI 的“知识”：</strong> AI 瞬间就掌握了所有关键信息：请求方法是 POST，请求头里必须带 Authorization，还有发送文本卡片消息所需要的、精确到每一个层级的 JSON 结构，比如 touser, msgtype, agentid 和那个复杂的 textcard 对象。</li><li><strong>AI 的产出：</strong> 它直接给我生成了一段完美可用的代码。URL、请求头、数据结构都准确无误，甚至还带了错误处理。整个过程，我再也不用去查文档了，因为 AI 已经替我“看”过了。</li></ol><h3 id="前端开发与部署的效率神器"><a href="#前端开发与部署的效率神器" class="headerlink" title="前端开发与部署的效率神器"></a>前端开发与部署的效率神器</h3><h4 id="context7"><a href="#context7" class="headerlink" title="context7"></a><code>context7</code></h4><p>在开发过程中,框架和库迭代太快,加上AI的知识库并不是实时更新的,就会导致在编写代码时,出现很多问题,。只要我在提问时加上 use context7，它就会自动识别我问的是哪个库，然后把<strong>最新版本</strong>的官方文档片段喂给 AI。这感觉就像是给了 AI 一份实时更新的技术文档订阅，而不是一本落满灰尘的旧书。</p><h4 id="playwright"><a href="#playwright" class="headerlink" title="playwright"></a><code>playwright</code></h4><p>这个 MCP 简直是前端测试的福音。它能赋予 AI 直接控制真实浏览器的能力。它的工作方式很聪明，是通过分析页面的<strong>可访问性树</strong>（一种结构化表示）来操作页面，而不是靠识别截图，所以速度更快、更可靠。我最常用的功能就是用自然语言描述一个测试场景，比如：“用 Playwright 给我的登录流程写一个端到端测试”，AI 就会调用 <code>browser_generate_playwright_test</code> 工具，自动生成测试脚本。</p><h4 id="edgeone-pages-mcp-server"><a href="#edgeone-pages-mcp-server" class="headerlink" title="edgeone-pages-mcp-server"></a><code>edgeone-pages-mcp-server</code></h4><p>有时候我写了个静态小工具或是一个 Demo 页面，想快速分享给别人看。这个 MCP 工具就派上用场了。我只需要让 AI 把生成的 HTML、CSS、JS 文件打包，然后用这个 MCP 一键部署到腾讯云的 EdgeOne Pages 服务上。几秒钟后，我就能拿到一个公开的 URL。我个人的备案信息主页就是这么部署的，非常方便。</p><blockquote><p>历史文章: <a href="https://mp.weixin.qq.com/s/c9omQ-2-MLLt70HCb8RA0A">https://mp.weixin.qq.com/s/c9omQ-2-MLLt70HCb8RA0A</a></p></blockquote><p><img src="https://img.996007.icu/file/1752149815391_20250710201648173.png" alt="image-20250710201648060"></p><p><img src="https://img.996007.icu/file/1752149348245_20250710200901676.png" alt="image-20250710200901159"></p><h3 id="更聪明的思考与认知"><a href="#更聪明的思考与认知" class="headerlink" title="更聪明的思考与认知"></a>更聪明的思考与认知</h3><h4 id="sequential-thinking"><a href="#sequential-thinking" class="headerlink" title="sequential-thinking"></a><code>sequential-thinking</code></h4><p>当我需要 AI 解决一个复杂问题时，直接让它“解决”往往会得到一个逻辑跳跃的答案。<code>sequential-thinking</code> 就像是强迫 AI 在解题前，必须先写出详细的“解题步骤”。我能看到它一步步地分解问题、思考逻辑，甚至自我修正。这个过程让最终产出的代码质量和可靠性大大提升。</p><p><img src="https://img.996007.icu/file/1752148488423_20250710195439101.png" alt="image-20250710195439028"></p><h4 id="mcp-deepwiki"><a href="#mcp-deepwiki" class="headerlink" title="mcp-deepwiki"></a><code>mcp-deepwiki</code></h4><blockquote><p> DeepWiki网址: <a href="https://deepwiki.com/">https://deepwiki.com</a></p></blockquote><p>这是一个<strong>非官方的 Deepwiki MCP 服务器</strong></p><p>它通过 MCP 获取 Deepwiki URL，抓取所有相关页面，将它们转换为 Markdown，并逐页返回一个文档我只需要让 AI 调用这个mcp，就能快速了解整个项目的架构和核心模块。我甚至可以直接问：“这个项目是用什么状态管理库的？”，AI 就能快速给出答案。</p><p><img src="https://img.996007.icu/file/1752148769971_20250710195923838.png" alt="image-20250710195923665"></p><h4 id="shrimp-task-manager"><a href="#shrimp-task-manager" class="headerlink" title="shrimp-task-manager"></a><code>shrimp-task-manager</code></h4><p>如果说 <code>sequential-thinking</code> 是解决单个问题的思考工具，那 <code>shrimp-task-manager</code> 就是一个更高维度的项目管理框架。它提供了一整套工具，如 <code>plan_task</code>（规划任务）、<code>analyze_task</code>（分析需求）、<code>split_tasks</code>（拆分任务）。这让 AI 能像一个真正的项目经理一样，从一个模糊的需求开始，进行技术分析，制定开发计划，再把计划分解成可执行的子任务。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>单个 MCP 工具已经很强大了，但把它们串起来，才能真正发挥出“自动化”的威力。你可以在一个项目中这样提问!</p><blockquote><p>第 1 步：用 <code>shrimp-task-manager</code> 规划</p><p>第 2 步：用 <code>apifox-mcp-server</code> 完成 API 对接</p><p>第 3 步：前后端代码实现（<code>context7</code> 辅助）</p><p>第 4 步：用 <code>playwright</code> 自动化测试</p><p>第 5 步:  使用<code>edgeone-pages-mcp-server</code>进行部署</p></blockquote><p>总之,就是要善于利用工具来更好的完成我们的需求!它让我们能真正专注于架构设计、复杂逻辑和用户体验这些更具创造性的工作。</p><h3 id="去哪里寻找更多宝藏-MCP？"><a href="#去哪里寻找更多宝藏-MCP？" class="headerlink" title="去哪里寻找更多宝藏 MCP？"></a>去哪里寻找更多宝藏 MCP？</h3><p>我介绍的这些只是冰山一角。想发现更多好用的 MCP，可以去下面这些地方逛逛：</p><ul><li><strong>官方与精选：</strong> 官方的 <code>modelcontextprotocol/servers</code> GitHub 仓库和社区维护的 <code>wong2/awesome-mcp-servers</code> 列表是我的首选。</li><li><strong>社区中心：</strong> OpenTools、MCP.so 这类平台提供了可搜索的目录。</li><li><strong>交流社区：</strong> Reddit 的 <code>/r/mcp</code> 板块和官方 Discord 服务器总能发现一些前沿的项目。</li></ul><p>另外，<code>GitHub MCP</code> 和 <code>Filesystem MCP</code> 这两个服务器，我建议是必备安装的，它们是 AI 操作代码和本地文件的基础。</p><h3 id="安全性，老生常谈但很重要"><a href="#安全性，老生常谈但很重要" class="headerlink" title="安全性，老生常谈但很重要"></a>安全性，老生常谈但很重要</h3><p>在享受便利的同时，安全永远是第一位。我的建议是：只从可信的来源安装 MCP，密切关注它申请的权限（特别是文件写入），并且，<strong>永远使用环境变量来管理 API 密钥</strong>，绝不硬编码！</p><h3 id="遇到问题怎么办？"><a href="#遇到问题怎么办？" class="headerlink" title="遇到问题怎么办？"></a>遇到问题怎么办？</h3><p>如果你在配置时遇到问题，可以试试这几步，通常能解决 90% 的问题：</p><ol><li><strong>检查 <code>mcp.json</code> 文件：</strong> 格式对不对？用在线工具校验一下。文件路径对不对？我强烈建议用绝对路径。</li><li><strong>重启客户端：</strong> 很多工具（特别是 Claude 桌面版）改完配置后，需要彻底退出再重启。</li><li><strong>检查环境变量：</strong> 确保你的 API 令牌在配置的 <code>env</code> 部分正确设置了。</li><li><strong>手动运行服务器：</strong> 在终端里直接运行服务器的启动命令，这样能看到最直接的错误日志。</li><li><strong>检查权限：</strong> 确认 AI 进程有权限访问你指定的目录。</li></ol>]]></content>
    
    
    <summary type="html">AI 时而像个天才，轻松帮你写出复杂而精妙的算法；时而却又像个健忘的实习生，满怀自信地提供过时的库函数用法，甚至凭空“幻觉”出一个根本不存在的 API。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="AI" scheme="https://www.wangwangit.com/tags/AI/"/>
    
    <category term="工具" scheme="https://www.wangwangit.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
