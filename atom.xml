<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只会飞的旺旺</title>
  
  <subtitle>一只会飞的旺旺,Java,Python,羊毛,hexo,博客</subtitle>
  <link href="https://www.wangwangit.com/atom.xml" rel="self"/>
  
  <link href="https://www.wangwangit.com/"/>
  <updated>2025-11-12T02:28:07.941Z</updated>
  <id>https://www.wangwangit.com/</id>
  
  <author>
    <name>一只会飞的旺旺</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CloudFlare系列教程二：零成本搭建个人图床</title>
    <link href="https://www.wangwangit.com/CloudFlare%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%8C%EF%BC%9A%E9%9B%B6%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/"/>
    <id>https://www.wangwangit.com/CloudFlare%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%8C%EF%BC%9A%E9%9B%B6%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</id>
    <published>2025-11-03T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.941Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.996007.icu/file/1762223631117_20251104103344206.png" alt="个人图床"></p><p>写博客或者记笔记时，图片放哪一直是个头疼的问题。</p><ul><li><strong>直接上传到平台（如语雀、CSDN）</strong>：图片有水印，而且迁移文章时图片链接会失效，很麻烦。</li><li><strong>用公共图床（如 sm.ms）</strong>：免费版有各种限制，而且你无法保证它哪天会不会关停或者访问变慢。</li><li><strong>自己买服务器&#x2F;对象存储（如阿里云 OSS）</strong>：有一定成本，而且通常需要支付流量费，配置也相对复杂。</li></ul><p>我的需求很简单：一个<strong>稳定、高速、低成本且数据能自己掌控</strong>的图床。</p><p>研究了一圈，发现用 CloudFlare 全家桶里的 <strong>R2 存储</strong> + <strong>Pages</strong> 来实现，几乎是完美的解决方案。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><strong>CloudFlare R2</strong>：这是 CloudFlare 推出的对象存储服务，你可以把它直接对标亚马逊的 S3。它最吸引人的一点是 <strong>“零出口流量费用”</strong>，意味着别人访问你的图片，无论多少次，你都不需要支付流量费。此外，它每月还有 10GB 的免费存储空间和大量的免费读写额度，对个人图床来说完全够用。</li></ul><p>整个工作流程是：我们通过一个上传工具（比如 PicGo）将图片发送给CF Pages，验证权限后，再将图片存入 R2。</p><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>这次我们使用的开源项目是 <code>CloudFlare-ImgBed</code>，它的部署文档写的很详细，我们只需要按照步骤操作就可以了。我就不再做过多介绍了!</p><blockquote><p>地址: <a href="https://cfbed.sanyue.de/">https://cfbed.sanyue.de</a></p></blockquote><p>这里补充说明一下,就是部署完成之后,虽然CF会提供一个默认的访问域名,但是为了方便记忆,可以在这里绑定我们自己的域名!</p><p><img src="https://img.996007.icu/file/1760597578822_20251016145247716.png" alt="image-20251016145247625"></p><p><img src="https://img.996007.icu/file/1760598011469_20251016150000510.png" alt="image-20251016150000259"></p><p><img src="https://img.996007.icu/file/1760598035886_20251016150028543.png" alt="image-20251016150028368"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>图床建好了，我们可以在直接访问网站进行上传,但是在使用markdown编写文章时,可能还需要一个方便的客户端来上传。这里推荐跨平台的 PicGo !</p><blockquote><p>地址: <a href="https://molunerfinn.com/PicGo/">https://molunerfinn.com/PicGo/</a></p></blockquote><ol><li><p>下载并安装 PicGo。</p></li><li><p>在“插件设置”里，搜索”web-uploader-custom-url-prefix” 这个插件<br><img src="https://img.996007.icu/file/1760597832160_20251016145701629.png" alt="image-20251016145701576"></p></li><li><p>安装之后,按照下图配置即可!</p></li></ol><p><img src="https://img.996007.icu/file/1760597959070_20251016145908350.png" alt="图床设置"></p><p>配置好后，设为默认图床，就可以通过拖拽或快捷键愉快地上传图片了。</p><p>我平时都是使用Typora编写文章的,也可以集成PicGo作为图床,可以参考下面配置!</p><p><img src="https://img.996007.icu/file/1760598093837_20251016150131389.png" alt="image-20251016150131324"></p><p>好了，这套基于 CloudFlare 的个人图床方案就搭建完成了。如果觉得还不错,可以分享给朋友一起搭建属于自己的图床!</p>]]></content>
    
    
    <summary type="html">写博客或者记笔记时，图片放哪一直是个头疼的问题。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="CloudFlare" scheme="https://www.wangwangit.com/tags/CloudFlare/"/>
    
    <category term="图床" scheme="https://www.wangwangit.com/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>CloudFlare系列教程五：零成本搭建一个“万物皆可播”的网站</title>
    <link href="https://www.wangwangit.com/CloudFlare%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%94%EF%BC%9A%E9%9B%B6%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E2%80%9C%E4%B8%87%E7%89%A9%E7%9A%86%E5%8F%AF%E6%92%AD%E2%80%9D%E7%9A%84%E7%BD%91%E7%AB%99/"/>
    <id>https://www.wangwangit.com/CloudFlare%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%BA%94%EF%BC%9A%E9%9B%B6%E6%88%90%E6%9C%AC%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E2%80%9C%E4%B8%87%E7%89%A9%E7%9A%86%E5%8F%AF%E6%92%AD%E2%80%9D%E7%9A%84%E7%BD%91%E7%AB%99/</id>
    <published>2025-11-03T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.941Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.996007.icu/file/1762223792489_20251104103625566.png" alt="自由观影"></p><p>你大概率在网上刷到过一些界面精美、资源看起来很全的影视网站。点开即播，没有广告，体验甚至比一些正规 App 还要好。一个普遍的疑问是：维护这样的网站，服务器和带宽成本应该是个天文数字，站长们是怎么做到的？</p><p>答案可能让你意外：<strong>他们根本没有服务器，甚至连视频资源在哪都未必知道。</strong></p><p>借助 Cloudflare 提供的免费全家桶，任何人都可以搭建一个类似的“空壳”网站。今天，我们不谈代码部署（因为像 MoonTV、LibreTV 这样的开源项目已经把步骤写得非常简单了），我们来深入聊聊它背后的魔法：这个“空壳”是如何撬动全网资源的？以及，你该如何像一个专业站长那样，让你的“片库”实现自动化、无限地扩充？</p><blockquote><p>MoonTV: <a href="https://github.com/samqin123/MoonTV">https://github.com/samqin123/MoonTV</a></p><p>LibreTV: <a href="https://github.com/LibreSpark/LibreTV">https://github.com/LibreSpark/LibreTV</a></p></blockquote><p><img src="https://img.996007.icu/file/1761008784238_20251021090614251.png" alt="image-20251021090614075"></p><h3 id="核心模式：采播分离，网站只做“搬运工”"><a href="#核心模式：采播分离，网站只做“搬运工”" class="headerlink" title="核心模式：采播分离，网站只做“搬运工”"></a><strong>核心模式：采播分离，网站只做“搬运工”</strong></h3><p>理解这类网站的关键，在于四个字：<strong>采播分离</strong>。</p><ul><li><strong>采集（采）</strong>：指的是内容的收集、整理和更新。这是最脏最累的活。</li><li><strong>播放（播）</strong>：指的是内容的展示和播放。这是我们看到的网站。</li></ul><p>传统模式下，一个站长需要自己做所有事。但在今天的生态里，这两件事已经由完全不同的人分工完成了。有一批专业的**“资源站”<strong>，他们负责搞定所有采集工作，然后通过</strong>标准化的API接口**，把整理好的数据提供出来。</p><p><img src="https://img.996007.icu/file/1761008980222_20251021090928086.png" alt="image-20251021090928028"></p><p>而我们用 Cloudflare 搭建的网站，其本质就是这个生态里的“播放”端。它本身<strong>不生产内容，只是API数据的“搬运工”和“展示柜”</strong>。</p><p>它的工作流程是这样的：</p><ol><li><strong>搭建前端“展示柜”</strong>：我们看到的网站界面，用 Vue 或 React 构建，部署在 <strong>Cloudflare Pages</strong> 上，保证全球秒开。</li><li><strong>设置API“中间人”</strong>：使用 <strong>Cloudflare Workers</strong> 作为一个轻量级的后端。它的唯一任务，就是去调用上游“资源站”的API。</li><li><strong>对接数据“总仓库”</strong>：网站启动时，Workers 向指定的资源站API发送请求（比如“请给我最新的20部电影”）。</li><li><strong>渲染内容</strong>：Workers 拿到API返回的JSON数据（包含了片名、海报、播放地址等），稍作处理，再喂给前端“展示柜”，用户就能看到琳琅满目的内容了。</li></ol><p>整个过程，视频流量完全不经过你的网站，API请求的消耗也极低。Cloudflare 的免费额度，绰绰有余。</p><h3 id="如何找到“资源站”API？"><a href="#如何找到“资源站”API？" class="headerlink" title="如何找到“资源站”API？"></a><strong>如何找到“资源站”API？</strong></h3><p>这才是这篇文章的精髓。让你的网站从一个玩具变成一个真正可用的工具，关键在于你能否找到稳定、高质量的“资源站”API，并把它对接到你的“管道”里。</p><p>普通人找资源是找片子，而一个站长的思路是<strong>找“提供片子列表”的人</strong>。以下是几个寻找API的有效思路：</p><ul><li><p><strong>思路一：关键词搜索，进入专业圈子</strong><br>搜索引擎是你最好的朋友，但关键在于用对词。不要搜“XX电影在线看”，而要用站长和开发者的黑话去搜，例如：</p><ul><li>“苹果CMS 资源站”</li><li>“免费影视API接口”</li><li>“JSON影视数据源”</li><li>“视频采集API”<br>通过这些关键词，你找到的不再是消费内容的网站，而是提供数据接口的“上游供应商”。这些网站通常会直接提供API的接入文档。</li></ul><p><img src="https://img.996007.icu/file/1761008758947_20251021090551621.png" alt="image-20251021090551495"></p></li><li><p><strong>思路二：逆向工程，分析现有网站</strong><br>这是最直接有效的方法。随便找一个你觉得不错的同类网站，打开浏览器的“开发者工具”（F12），切换到“网络(Network)”面板，然后进行一些操作（比如翻页、搜索）。<br>在网络请求列表里，重点关注 XHR&#x2F;Fetch 类型的请求。你会发现一些规律性的API调用，比如 …&#x2F;api.php?ac&#x3D;videolist&amp;t&#x3D;… 或 …&#x2F;api&#x2F;v1&#x2F;videos?page&#x3D;…。<br>这个请求的URL，就是这个网站正在使用的API接口。你可以尝试直接在浏览器里打开这个URL，如果能看到返回一大堆JSON格式的数据，恭喜你，你找到了它的“数据动脉”。</p></li></ul><p><img src="https://img.996007.icu/file/1761008877119_20251021090752892.png" alt="image-20251021090752814"></p><ul><li><strong>思路三：混迹于站长社区和交流群</strong><br>很多API资源并不是完全公开的，而是在一些小圈子里流传。你可以去一些技术论坛、站长社区（比如搜索与“建站”、“源码”相关的论坛），或者Telegram上的相关技术群组。在这些地方，信息交换更为频繁，你可能会发现一些不对外宣传的优质资源站。</li></ul><p>一旦你找到了API接口，接下来要做的就很简单了：根据 MoonTV 或 LibreTV 这类项目的配置说明，把你找到的API地址填进去，重新部署即可。</p><p>通过这种“采播分离”的模式，你的网站内容就实现了自动化更新。上游资源站更新了什么，你的网站就自动显示什么。这才是零成本、高效率运营这类网站的真正秘诀。</p>]]></content>
    
    
    <summary type="html">你大概率在网上刷到过一些界面精美、资源看起来很全的影视网站。点开即播，没有广告，体验甚至比一些正规 App 还要好。一个普遍的疑问是：维护这样的网站，服务器和带宽成本应该是个天文数字，站长们是怎么做到的？</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="CloudFlare" scheme="https://www.wangwangit.com/tags/CloudFlare/"/>
    
    <category term="影视站" scheme="https://www.wangwangit.com/tags/%E5%BD%B1%E8%A7%86%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>保姆级教程：从零开始，搭建一个属于你自己的AI中转站</title>
    <link href="https://www.wangwangit.com/%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84AI%E4%B8%AD%E8%BD%AC%E7%AB%99/"/>
    <id>https://www.wangwangit.com/%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84AI%E4%B8%AD%E8%BD%AC%E7%AB%99/</id>
    <published>2025-11-03T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.946Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.996007.icu/file/1762223404333_20251104102957089.png" alt="ChatGPT Image 2025年11月4日 10_29_29"></p><p>现在Claude Code, Codex等AI CLI工具大火,很多人在使用时都会遇到下面几个问题：</p><ol><li><strong>IP 限制：</strong> 你懂的，稳定的接入是个大前提。</li><li><strong>共享难题：</strong> 想和几个朋友合用一个账号分摊成本，但直接共享主账号密码既不安全，用量和账单也算不清。</li><li><strong>用量瓶颈：</strong> 官方对单一账号有速率限制，请求一多就容易触发 rate_limit_error，影响连续使用。</li></ol><p>为了解决这些，我需要一个能自建、稳定、可控的解决方案。最后找到了 claude-relay-service 这个开源项目，折腾了一下，发现发现它基本解决了我上面提到的所有痛点，在这里整理分享一下。</p><p>下面是我这两天的一个用量图,看起来也十分清晰!</p><p><img src="https://img.996007.icu/file/1762222325038_20251104101152871.png" alt="image-20251104101152733"></p><hr><h2 id="搭建一个属于自己的中转站"><a href="#搭建一个属于自己的中转站" class="headerlink" title="搭建一个属于自己的中转站"></a>搭建一个属于自己的中转站</h2><blockquote><p>地址: <a href="https://github.com/Wei-Shaw/claude-relay-service">https://github.com/Wei-Shaw/claude-relay-service</a></p></blockquote><p>这个项目能让你把多个 Claude、OpenAI、Gemini 等账号统一管理起来，生成独立的 API Key 分给不同的人用，还能统计用量，方便算账。核心的好处是，所有数据都只经过你自己的服务器，私密性有保障。</p><p>部署方式有很多种，我这里只记录最简单的一种：脚本部署。</p><p><strong>准备工作：一台海外服务器</strong></p><p>你需要一台能正常访问到 Anthropic API 的服务器。配置不用很高，1核1G基本就够用了。</p><p>（注意：根据项目文档的提示，阿里云、腾讯云等部分国内厂商的海外主机可能会被 Cloudflare 拦截，导致无法访问 Claude API，在选择服务器时需要留意一下。）</p><p><strong>第一步：安装服务</strong></p><p>用 SSH 登录你的服务器，然后运行下面这行命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://pincc.ai/manage.sh -o manage.sh &amp;&amp; <span class="built_in">chmod</span> +x manage.sh &amp;&amp; ./manage.sh install</span><br></pre></td></tr></table></figure><p>这个脚本会自动安装 Node.js、Redis 等所有需要的环境，并用交互式的方式让你设置服务端口、Redis 地址等。大部分情况下，直接一路回车用默认设置就行。</p><p>安装完成后，脚本会显示服务的访问地址和管理员账号信息。</p><p>（我第一次用的时候没记下来管理员账号，后来在 <code>data/init.json</code> 文件里才找到。建议大家安装成功后第一时间就把账号密码记下来。）</p><p><strong>第二步：登录并添加 Claude 账户</strong></p><p>通过提示的公网 Web 地址（http:&#x2F;&#x2F;你的IP:端口&#x2F;web）访问管理后台。输入上一步生成的管理员账号密码登录。</p><p>添加账户是关键步骤：</p><ol><li>点击左侧的「Claude 账户」标签页。当然,也支持API等方式的接入,这个可以自行研究一下!</li><li>点击「添加账户」，然后点击「生成授权链接」。</li><li>在新打开的页面里登录你的 Claude 账号并授权。</li><li>授权成功后，会返回一串 <code>Authorization Code</code>，把它复制粘贴回管理页面的输入框，完成添加。</li></ol><p>（这一步如果你的本地网络无法访问 Claude，可能需要自行解决网络环境问题。）</p><p><img src="https://img.996007.icu/file/1762222049688_20251104100720822.png" alt="image-20251104100713655"></p><p><strong>第三步：创建 API Key</strong></p><p>现在，你可以给你的朋友们（或者给自己）创建独立的 API Key 了。</p><ol><li>点击「API Keys」标签页。</li><li>点击「创建新Key」，设置一个好记的名字，比如 “我的开发Key” 或 “朋友小张的Key”。</li><li>这里可以设置限速、并发数、可用模型等，对于共享使用非常有用。如果只是自己用，保持默认即可。</li><li>保存后，会生成一个 <code>cr-</code> 开头的 Key，这就是之后要用到的凭证。</li></ol><p><img src="https://img.996007.icu/file/1762222131928_20251104100844085.png" alt="image-20251104100843950"></p><p><strong>第四步：开始使用</strong></p><p>搭建好的网站里面有详细的使用教程,按照教程配置,就可以使用你自己的中转服务了。</p><p>之后在这个终端里使用 <code>claude</code> 命令，所有的请求就会通过你自己的服务器转发了。其他第三方工具的接入方法，项目的 GitHub 主页有非常详细的说明。</p><p><img src="https://img.996007.icu/file/1762222175245_20251104100932293.png" alt="image-20251104100932144"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><strong>关于账号获取</strong></p><p>这个服务解决了 Claude 账号的统一管理和接入问题。但有时候，我们的痛点可能更靠前：如何方便地获取账号本身？这里顺便提一下我看到的另一个项目，一个关于如何注册 GPT  Team 账号的教程，有兴趣的可以看看这篇文章：<a href="https://mp.weixin.qq.com/s/UBpHmWt2HDNLlDDcoSFodA">https://mp.weixin.qq.com/s/UBpHmWt2HDNLlDDcoSFodA</a> ;</p><p>另外注意项目文档里有提示，使用这类第三方工具可能违反 Anthropic 的服务条款，存在账户风险。我个人的理解是，自建服务相比于多人共享的公共服务，IP固定，行为模式单一，风险相对较低，但并不能完全排除。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>好了，到这里，最关键的部分就完成了。整个过程其实就是把操作笔记整理了一遍，希望能帮到有同样需求的人。</p>]]></content>
    
    
    <summary type="html">现在Claude Code, Codex等AI CLI工具大火,很多人在使用时都会遇到下面几个问题</summary>
    
    
    
    <category term="AI" scheme="https://www.wangwangit.com/categories/AI/"/>
    
    
    <category term="AI" scheme="https://www.wangwangit.com/tags/AI/"/>
    
    <category term="中转站" scheme="https://www.wangwangit.com/tags/%E4%B8%AD%E8%BD%AC%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>CloudFlare系列教程三：一劳永逸的邮箱方案，零成本拥有无限邮箱地址</title>
    <link href="https://www.wangwangit.com/CloudFlare%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%89%EF%BC%9A%E4%B8%80%E5%8A%B3%E6%B0%B8%E9%80%B8%E7%9A%84%E9%82%AE%E7%AE%B1%E6%96%B9%E6%A1%88%EF%BC%8C%E9%9B%B6%E6%88%90%E6%9C%AC%E6%8B%A5%E6%9C%89%E6%97%A0%E9%99%90%E9%82%AE%E7%AE%B1%E5%9C%B0%E5%9D%80/"/>
    <id>https://www.wangwangit.com/CloudFlare%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%89%EF%BC%9A%E4%B8%80%E5%8A%B3%E6%B0%B8%E9%80%B8%E7%9A%84%E9%82%AE%E7%AE%B1%E6%96%B9%E6%A1%88%EF%BC%8C%E9%9B%B6%E6%88%90%E6%9C%AC%E6%8B%A5%E6%9C%89%E6%97%A0%E9%99%90%E9%82%AE%E7%AE%B1%E5%9C%B0%E5%9D%80/</id>
    <published>2025-11-01T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.941Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.996007.icu/file/1762223686134_20251104103443881.png" alt="临时邮箱"></p><p>每当注册一个新网站或服务时，你是不是也曾犹豫过：到底要不要用自己的主邮箱？用吧，怕后面无穷无尽的广告和垃圾邮件；不用吧，还得专门去注册个“垃圾桶”邮箱，管理起来也麻烦。尤其是遇到一些只需要临时用一下的服务，这个纠结感就更强了。</p><p>其实，如果你手头有一个通过 Cloudflare 解析的域名，这个问题就有了一个几乎零成本的完美解决方案。我整理了两种实用方法，一种可以帮你搭建功能齐全的临时邮箱网站，另一种能让你无限创建邮箱别名，并统一转发到主邮箱处理。</p><p>我把整个过程和一些关键点整理成了笔记，希望能帮到有同样需求的人。</p><hr><h3 id="方案一：搭建功能齐全的临时邮箱服务"><a href="#方案一：搭建功能齐全的临时邮箱服务" class="headerlink" title="方案一：搭建功能齐全的临时邮箱服务"></a><strong>方案一：搭建功能齐全的临时邮箱服务</strong></h3><p>这个方案适合想拥有一个独立临时邮箱网站的朋友。我们可以利用 GitHub 上的一个开源项目 <code>cloudflare_temp_email</code> 来快速部署。部署完成后，任何人都可以通过你的网站生成临时邮箱地址来<strong>收发邮件</strong>。</p><blockquote><p>项目地址: <a href="https://github.com/dreamhunter2333/cloudflare_temp_email">https://github.com/dreamhunter2333/cloudflare_temp_email</a></p></blockquote><p>大家直接看官方的教程即可,非常详细了!</p><p><strong>注意</strong>:</p><p>这里我搭建过程中遇到一个问题,就是如果你用的是二级域名,在配置resend时,可能会导致校验一直不通过,可以参考下面这个方案!</p><blockquote><p><a href="https://github.com/dreamhunter2333/cloudflare_temp_email/issues/515">https://github.com/dreamhunter2333/cloudflare_temp_email/issues/515</a></p></blockquote><hr><h3 id="方案二：设置域名邮箱转发"><a href="#方案二：设置域名邮箱转发" class="headerlink" title="方案二：设置域名邮箱转发"></a><strong>方案二：设置域名邮箱转发</strong></h3><p>如果你觉得搭建一个网站太复杂，只是想简单地用自己的域名接收邮件，那这个方案更适合你。它的逻辑很简单：把所有发送到 <code>*@yourdomain.com</code> 的邮件，全部转发到你指定的个人邮箱（比如 Gmail 或 Outlook）。</p><p><strong>第一步：进入 Cloudflare 电子邮件路由</strong></p><ol><li>登录 Cloudflare 仪表板，选择你的域名。</li><li>在左侧菜单中找到“电子邮件” -&gt; “电子邮件路由”。</li></ol><p><img src="https://img.996007.icu/file/1760669803518_20251017105638363.png" alt="image-20251017105631093"></p><p><strong>第二步：添加 DNS 记录</strong></p><p>如果是第一次使用这个功能，Cloudflare 会引导你自动添加必要的 MX 和 TXT 记录。</p><ul><li><strong>MX 记录</strong>：告诉外界的邮件服务器，发送到你这个域名的邮件应该由 Cloudflare 来处理。</li><li><strong>TXT 记录</strong>：主要用于 SPF (发件人策略框架)，验证邮件不是伪造的，可以提高邮件送达率。</li></ul><p>你只需要跟着引导点击“添加记录并启用”按钮，Cloudflare 会自动帮你配置好。 （<em>注意：如果你的域名之前配置过其他的邮箱服务，这里可能会有冲突的 MX 记录，需要先删除旧的。</em>）</p><p><strong>第三步：创建自定义地址和转发规则</strong></p><ol><li>在“路由规则”标签页下，点击“创建地址”。</li><li><strong>自定义地址</strong>：这里你可以填写想创建的邮箱前缀，比如 <code>contact</code>，那么邮箱地址就是 <code>contact@yourdomain.com</code>。</li><li><strong>目标地址</strong>：填写你希望邮件被转发到的个人邮箱地址，比如 <code>your-name@gmail.com</code>。</li><li>点击“保存”。</li></ol><p><img src="https://img.996007.icu/file/1760669834688_20251017105711243.png" alt="image-20251017105711141"></p><p><strong>第四步：验证目标邮箱</strong></p><p>Cloudflare 会向你的目标邮箱（<code>your-name@gmail.com</code>）发送一封验证邮件。你需要登录邮箱，点击邮件中的验证链接，确认你对这个邮箱的所有权。</p><p>验证通过后，状态会显示为“已验证”，邮件转发就正式生效了。</p><p>（<em>经验之谈：我通常会再额外设置一个“全部捕获”规则。在“全部捕获地址”部分，选择“发送到”并填入我的个人邮箱。这样，不管别人发邮件到 <code>hello@yourdomain.com</code> 还是 <code>randomstring@yourdomain.com</code>，我都能收到，避免错过任何邮件。</em>）</p><hr><h3 id="两种方案的对比与选择"><a href="#两种方案的对比与选择" class="headerlink" title="两种方案的对比与选择"></a><strong>两种方案的对比与选择</strong></h3><ul><li><p><strong>方案一（搭建网站）</strong>：</p><ul><li><strong>优点</strong>：功能强大，是一个完整的服务，可以公开给他人使用，支持在线收发、附件等。</li><li><strong>缺点</strong>：配置相对复杂，涉及数据库、Worker、Pages 等多个环节，需要一定的排错能力。</li><li><strong>适用场景</strong>：希望提供公开临时邮箱服务，或者需要一个功能完备的“小号”邮箱系统。</li></ul></li><li><p><strong>方案二（邮件转发）</strong>：</p><ul><li><strong>优点</strong>：配置极其简单，几分钟就能搞定，完全在 Cloudflare 后台操作，稳定可靠。</li><li><strong>缺点</strong>：只能收邮件，不能以你的域名邮箱为发件人来发送邮件。所有邮件都汇集到一个邮箱，需要自己管理。</li><li><strong>适用场景</strong>：个人使用，希望用一个专业的域名邮箱地址来接收各类邮件，并统一在个人主邮箱中处理。</li></ul></li></ul><p>希望这份笔记能让你在 Cloudflare 上顺利地用起自己的域名邮箱。</p><h3 id="历史文章"><a href="#历史文章" class="headerlink" title="历史文章"></a>历史文章</h3><ul><li>基于CloudFlare搭建轻量级订阅管理系统 ( <a href="https://mp.weixin.qq.com/s?__biz=MzI0NTU1MTA5MA==&mid=2247487920&idx=1&sn=98756c2a2bba414c2a486cffdc9ee0bf&scene=21#wechat_redirect">https://mp.weixin.qq.com/s/1jiy9Nm18mH7z94RMOJGbw</a> )</li><li>基于CloudFlare搭建文字语音互转网站 ( <a href="https://mp.weixin.qq.com/s?__biz=MzI0NTU1MTA5MA==&mid=2247488352&idx=1&sn=c45d388605ab8643a12f15b6c9fd0d93&scene=21#wechat_redirect">https://mp.weixin.qq.com/s/F4-Pc6etHVXExGhPATLppw</a> )</li><li>基于CloudFlare搭建书签导航站 ( <a href="https://mp.weixin.qq.com/s?__biz=MzI0NTU1MTA5MA==&mid=2247487959&idx=1&sn=a083d382e17796f28a1e1d8aef7d002f&scene=21#wechat_redirect">https://mp.weixin.qq.com/s/6Q_mGL0Fx–4QZ_q6aq7gQ</a> )</li></ul>]]></content>
    
    
    <summary type="html">每当注册一个新网站或服务时，你是不是也曾犹豫过：到底要不要用自己的主邮箱？用吧，怕后面无穷无尽的广告和垃圾邮件；不用吧，还得专门去注册个“垃圾桶”邮箱，管理起来也麻烦。尤其是遇到一些只需要临时用一下的服务，这个纠结感就更强了。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="邮箱" scheme="https://www.wangwangit.com/tags/%E9%82%AE%E7%AE%B1/"/>
    
    <category term="CloudFlare" scheme="https://www.wangwangit.com/tags/CloudFlare/"/>
    
  </entry>
  
  <entry>
    <title>CloudFlare系列教程四：10分钟，给又长又丑的网址“一键瘦身”</title>
    <link href="https://www.wangwangit.com/CloudFlare%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%9B%9B%EF%BC%9A10%E5%88%86%E9%92%9F%EF%BC%8C%E7%BB%99%E5%8F%88%E9%95%BF%E5%8F%88%E4%B8%91%E7%9A%84%E7%BD%91%E5%9D%80%E2%80%9C%E4%B8%80%E9%94%AE%E7%98%A6%E8%BA%AB%E2%80%9D/"/>
    <id>https://www.wangwangit.com/CloudFlare%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%9B%9B%EF%BC%9A10%E5%88%86%E9%92%9F%EF%BC%8C%E7%BB%99%E5%8F%88%E9%95%BF%E5%8F%88%E4%B8%91%E7%9A%84%E7%BD%91%E5%9D%80%E2%80%9C%E4%B8%80%E9%94%AE%E7%98%A6%E8%BA%AB%E2%80%9D/</id>
    <published>2025-11-01T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.941Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.996007.icu/file/1762223735785_20251104103528734.png" alt="专属短链"></p><p>你肯定遇到过这种情况：想分享一个网址，结果复制出来的链接长得离谱，后面还跟着一大串 utm_ 开头的追踪参数。直接发出去不仅难看，在微信里还可能因为太长被折叠，甚至被某些平台误判为广告。</p><p>用公开的短链接服务是个办法，但域名不是自己的，总感觉差点意思，而且说不定哪天就停了，所有链接全部失效。</p><p>其实，只要你有一个在 Cloudflare 解析的域名，花上 10 分钟，就能搭一个完全属于你自己的短链接服务——用你自己的域名，稳定、高速、还没广告。我把具体的步骤整理成了笔记，跟着走一遍就能完成。</p><hr><h3 id="实操步骤"><a href="#实操步骤" class="headerlink" title="实操步骤"></a><strong>实操步骤</strong></h3><ol><li><p><strong>Fork 项目</strong> : <a href="https://github.com/x-dr/short">https://github.com/x-dr/short</a></p></li><li><p><strong>登录 Cloudflare 控制台：</strong> <a href="https://dash.cloudflare.com/">https://dash.cloudflare.com/</a></p></li><li><p><strong>创建 Pages 项目：</strong> 在您的 Cloudflare 账户中，选择 <code>Pages</code> &gt; <code>创建项目</code> &gt; <code>连接到 Git</code>。</p></li><li><p><strong>选择仓库并部署：</strong> 选择您 Fork 的项目仓库，在 <code>设置构建和部署</code> 部分保持默认设置，然后点击 <code>保存并部署</code>。</p></li><li><p><strong>创建 D1 数据库：</strong> 参考 <a href="https://github.com/x-dr/telegraph-Image/blob/main/docs/manage.md">https://github.com/x-dr/telegraph-Image/blob/main/docs/manage.md</a> 创建一个 D1 数据库。</p><p><img src="https://img.996007.icu/file/1761005864839_20251021081741604.png" alt="image-20251021081741503"></p></li><li><p><strong>创建数据库表：</strong> 在 D1 数据库控制台中执行以下 SQL 命令创建表：</p></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> links;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> links (</span><br><span class="line">  `id` <span class="type">integer</span> <span class="keyword">PRIMARY KEY</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `url` text,</span><br><span class="line">  `slug` text,</span><br><span class="line">  `ua` text,</span><br><span class="line">  `ip` text,</span><br><span class="line">  `status` <span class="type">int</span>,</span><br><span class="line">  `create_time` <span class="type">DATE</span>,</span><br><span class="line">  `expires_at` <span class="type">timestamp</span>  <span class="comment">-- 添加过期时间字段</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> logs;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> logs (</span><br><span class="line">  `id` <span class="type">integer</span> <span class="keyword">PRIMARY KEY</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `url` text ,</span><br><span class="line">  `slug` text,</span><br><span class="line">  `referer` text,</span><br><span class="line">  `ua` text ,</span><br><span class="line">  `ip` text ,</span><br><span class="line">  `create_time` <span class="type">DATE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="7"><li><p>选择部署完成short项目，前往后台依次点击<code>设置</code>-&gt;<code>函数</code>-&gt;<code>D1 数据库绑定</code>-&gt;<code>编辑绑定</code>-&gt;变量名称填写：<code>DB</code> 命名空间 <code>选择你提前创建好的D1</code> 数据库绑定</p><p><img src="https://img.996007.icu/file/1761005810037_20251021081638006.png" alt="image-20251021081637915"></p></li><li><p>重新部署项目，完成。</p></li></ol><h3 id="绑定自定义域名"><a href="#绑定自定义域名" class="headerlink" title="绑定自定义域名"></a><strong>绑定自定义域名</strong></h3><p>到这里，服务其实已经可以通过 <code>*.pages.dev</code> 的临时域名访问了。但我们的最终目的是用自己的域名。</p><ol><li>在 Pages 项目的管理页面，找到 <code>自定义域</code>。</li><li>输入你准备好的域名（比如 <code>s.yourdomain.com</code>），然后点击 <code>继续</code>。</li><li>Cloudflare 会引导你添加一个 <code>CNAME</code> 解析记录。按提示去你的 DNS 管理处操作即可。（如果你的域名本身就在 Cloudflare 解析，这一步它会自动帮你完成）。</li><li>等待几分钟，直到自定义域名的状态显示为 <code>有效</code>。Cloudflare 会自动帮你处理 SSL 证书。</li></ol><p><img src="https://img.996007.icu/file/1761005776705_20251021081604015.png" alt="image-20251021081556850"></p><p>至此，你的专属短链接服务就正式上线了。</p><p>整个过程没有涉及一行复杂的代码，却收获了一个稳定、私有且由全球 CDN 加速的服务。现在，无论是分享文章、管理推广链接，还是在简历上放一个清爽的个人主页地址，你都有了最佳选择。</p><p><strong>一个进阶玩法</strong>：我更喜欢把它当成一个“个人导航站”。你可以创建一些非常好记的短链接，指向你常用的服务，比如：</p><ul><li>s.mydomain.com&#x2F;note -&gt; 你的 Notion 笔记</li><li>s.mydomain.com&#x2F;cv -&gt; 你的在线简历</li><li>s.mydomain.com&#x2F;code -&gt; 你的 GitHub 主页</li></ul><p>这样一来，它就不只是一个工具，更是你个人品牌的延伸。希望这篇笔记对你有用。</p>]]></content>
    
    
    <summary type="html">你肯定遇到过这种情况：想分享一个网址，结果复制出来的链接长得离谱，后面还跟着一大串 utm_ 开头的追踪参数。直接发出去不仅难看，在微信里还可能因为太长被折叠，甚至被某些平台误判为广告。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="CloudFlare" scheme="https://www.wangwangit.com/tags/CloudFlare/"/>
    
    <category term="短链" scheme="https://www.wangwangit.com/tags/%E7%9F%AD%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>CloudFlare系列教程一：巧用 Workers，实现每日任务自动化</title>
    <link href="https://www.wangwangit.com/CloudFlare%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%80%EF%BC%9A%E5%B7%A7%E7%94%A8%20Workers%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%AF%8F%E6%97%A5%E4%BB%BB%E5%8A%A1%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>https://www.wangwangit.com/CloudFlare%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B8%80%EF%BC%9A%E5%B7%A7%E7%94%A8%20Workers%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%AF%8F%E6%97%A5%E4%BB%BB%E5%8A%A1%E8%87%AA%E5%8A%A8%E5%8C%96/</id>
    <published>2025-10-31T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.941Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.996007.icu/file/1760580722483_20251016101151327.png" alt="ChatGPT Image 2025年10月16日 10_11_29"></p><p>我手上有些服务，比如 GLaDOS之类的网站，都需要每天手动签到一下来维持活跃或获取积分。这个操作本身不复杂，但每天重复，就显得很繁琐，也容易忘记。</p><p>于是我开始琢磨，有没有一种“零成本”的自动化方案？</p><p>这个方案需要满足几个条件：</p><ol><li><strong>免费</strong>：只是个签到，不想为此付费。</li><li><strong>稳定</strong>：能持续、可靠地运行。</li><li><strong>省事</strong>：一次配置，长期有效。</li></ol><p>最后找到了一个比较理想的方案：<strong>CloudFlare Workers</strong>。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h3><p>在开始操作前，简单说一下我们在用什么。</p><ul><li><p><strong>CloudFlare (CF)</strong>：这是一家全球知名的网络服务公司，提供 CDN 加速、网络安全防护等服务。 很多人用它的免费套餐来加速和保护自己的网站。简单来说，它是一个非常强大的网络基础设施平台。</p></li><li><p><strong>CloudFlare Workers</strong>：这是 CF 提供的一项“无服务器”计算服务。 你可以把它理解成一个能“在全球边缘节点运行你的代码”的平台。最关键的是，它有一个免费套餐，每天提供 10 万次的免费请求额度。 对于我们这种每天仅需执行一两次的签到任务，这个额度绰绰有余。</p></li></ul><p>用 Workers 的好处是，我们不需要自己的服务器，代码部署上去就能按时自动运行，完美符合我们的需求。</p><p>另外后续教程经常会需要用到域名,这个可以参考下面的教程去注册或者购买一个域名!</p><blockquote><p><a href="https://mp.weixin.qq.com/s/7LuGZF1Uq1KBZVpMYDCBkA">https://mp.weixin.qq.com/s/7LuGZF1Uq1KBZVpMYDCBkA</a></p></blockquote><h3 id="实践指南"><a href="#实践指南" class="headerlink" title="实践指南"></a>实践指南</h3><p><img src="https://img.996007.icu/file/1760577440415_20251016091713976.png" alt="image-20251016091706846"></p><p>我以GLaDOS这个网站为例,来教大家如何使用CloudFlare Workers来实现签到功能! (对了,多说一句,要是有教育邮箱,这个网站可以领取365天的免费服务哦!~)</p><blockquote><p>脚本地址: <a href="https://github.com/axinhouzilaoyue/cloudflare">https://github.com/axinhouzilaoyue/cloudflare</a></p><p>GLaDOS官网: <a href="https://glados.rocks/">https://glados.rocks</a> </p></blockquote><ul><li><strong>第一步：创建 Worker</strong><ol><li>登录 Cloudflare Dashboard (<a href="https://dash.cloudflare.com/)%E3%80%82">https://dash.cloudflare.com/)。</a></li><li>在左侧菜单栏找到并进入 “Workers &amp; Pages” 页面。</li><li>点击“Create application”，然后选择“Create Worker”。</li><li>你可以为你的 Worker 自定义一个名字，比如 <code>glados-checkin</code>，然后点击“Deploy”。</li></ol></li></ul><p><img src="https://img.996007.icu/file/1760578787719_20251016093942779.png" alt="image-20251016092056993"></p><p><img src="https://img.996007.icu/file/1760577694006_20251016092129496.png" alt="image-20251016092129417"></p><ul><li><strong>第二步：复制代码</strong><ol><li>部署成功后，点击“Edit code”进入代码编辑器。</li><li>将前面脚本网站中 glados.js 脚本代码 的全部内容复制并替换掉编辑器里的所有默认代码。</li></ol></li></ul><p><img src="https://img.996007.icu/file/1760578831175_20251016094028087.png" alt="image-20251016094027981"></p><p><img src="https://img.996007.icu/file/1760577694006_20251016092129496.png" alt="image-20251016092129417"></p><ul><li><p><strong>第三步：配置账号信息（核心）</strong><br>这是最关键的一步，推荐使用环境变量，更安全。我这里是直接在代码里修改了!大家可以二选其一就行!</p><ol><li><p>返回 Worker 的详情页面，点击 <code>Settings</code> &gt; <code>Variables</code>。</p></li><li><p>在 “Environment Variables” 部分，点击 “Add variable”。</p></li><li><p>我们需要添加的变量是 <code>GLADOS_ACCOUNTS</code>。变量名填入 <code>GLADOS_ACCOUNTS</code>，<strong>变量值</strong>填入你的 GLaDOS 账号信息，格式是一个 JSON 数组。</p><ul><li><em>(旁注：JSON 格式要求比较严格，建议先在文本编辑器里编辑好再粘贴。注意使用英文双引号。)</em></li></ul><pre><code class="language-json">[  &#123;&quot;email&quot;: &quot;你的邮箱1@example.com&quot;, &quot;cookie&quot;: &quot;你的cookie值1&quot;&#125;,  &#123;&quot;email&quot;: &quot;你的邮箱2@example.com&quot;, &quot;cookie&quot;: &quot;你的cookie值2&quot;&#125;]```    4.  如果你需要 Telegram 通知，可以额外添加 `TGTOKEN` 和 `TGID` 两个变量，分别填入你的 Telegram Bot Token 和 Chat ID。如果不需要，忽略此项。</code></pre></li></ol></li></ul><p><img src="https://img.996007.icu/file/1760578988715_20251016094257887.png" alt="image-20251016094257764"></p><ul><li><p><strong>第四步：获取 Cookie</strong></p><ol><li>用浏览器登录 GLaDOS 官网。</li><li>按 F12 打开开发者工具，切换到 “Network” (网络) 标签页。</li><li>刷新页面，随便找一个请求，在 “Headers” (标头) 下找到 <code>Cookie</code> 字段，复制其完整的字符串值。这个值就是你需要的 <code>cookie</code>。<ul><li><em>(旁注：Cookie 是账号凭证，非常敏感，不要泄露给任何人。)</em></li></ul></li></ol><p><img src="https://img.996007.icu/file/1760577802644_20251016092314066.png" alt="image-20251016092313973"></p></li><li><p><strong>第五步：设置定时任务</strong></p><ol><li>回到 Worker 详情页面，点击 <code>Triggers</code> (触发器)。</li><li>在 “Cron Triggers” 部分，点击 “Add Cron Trigger”。</li><li>Cron 表达式可以填 <code>0 22 * * *</code>，这代表每天在 UTC 时间的 22:00（即北京时间第二天早上 6:00）执行一次。你可以根据自己的需求调整。</li><li>保存触发器。</li></ol></li></ul><p><img src="https://img.996007.icu/file/1760577899979_20251016092452337.png" alt="image-20251016092452241"></p><p>到这里，GLaDOS 的自动签到就配置完成了。它会每天自动在设定的时间运行一次。你也可以手动访问一下网址,进行签到!</p><p><img src="https://img.996007.icu/file/1760579079955_20251016094431211.png" alt="image-20251016094431125"></p><p><img src="https://img.996007.icu/file/1760577989914_20251016092617800.png" alt="image-20251016092617731"></p><h3 id="补充-FAQ"><a href="#补充-FAQ" class="headerlink" title="补充 (FAQ)"></a><strong>补充 (FAQ)</strong></h3><ul><li><strong>这个服务真的完全免费吗？</strong><ul><li>A：是的。CloudFlare Workers 每天有10万次免费调用额度，我们每天只用一两次，完全在免费范围内。所以没有额外费用。</li></ul></li><li><strong>安全吗？我的账号信息会不会泄露？</strong><ul><li>A：安全性取决于你自己。Cookie 和密码都存储在你的 CloudFlare 账户里，只要你的 CF 账户不泄露，这些信息就是安全的。这也是为什么推荐 GLaDOS 教程使用环境变量，因为它比直接写在代码里更安全一点。</li></ul></li><li><strong>如果签到失败怎么办？</strong><ul><li>A：最常见的原因是 GLaDOS 的 Cookie 过期了，需要重新获取并更新到环境变量里。对于 SSPanel，检查一下网址和账号密码是否填写正确。</li></ul></li></ul><hr><p>好了，今天的操作笔记就整理到这里。这个方案基本实现了“一劳永逸”的自动签到，值得一试。</p><h3 id="历史文章"><a href="#历史文章" class="headerlink" title="历史文章"></a>历史文章</h3><ul><li>基于CloudFlare搭建轻量级订阅管理系统 ( <a href="https://mp.weixin.qq.com/s/1jiy9Nm18mH7z94RMOJGbw">https://mp.weixin.qq.com/s/1jiy9Nm18mH7z94RMOJGbw</a> )</li><li>基于CloudFlare搭建文字语音互转网站 ( <a href="https://mp.weixin.qq.com/s/F4-Pc6etHVXExGhPATLppw">https://mp.weixin.qq.com/s/F4-Pc6etHVXExGhPATLppw</a> )</li><li>基于CloudFlare搭建书签导航站 ( <a href="https://mp.weixin.qq.com/s/6Q_mGL0Fx--4QZ_q6aq7gQ">https://mp.weixin.qq.com/s/6Q_mGL0Fx--4QZ_q6aq7gQ</a> )</li></ul>]]></content>
    
    
    <summary type="html">我手上有些服务，比如 GLaDOS之类的网站，都需要每天手动签到一下来维持活跃或获取积分。这个操作本身不复杂，但每天重复，就显得很繁琐，也容易忘记。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="自动化" scheme="https://www.wangwangit.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="CloudFlare" scheme="https://www.wangwangit.com/tags/CloudFlare/"/>
    
  </entry>
  
  <entry>
    <title>新买的电视成“摆设”？别急，这个工具让你的电视重获新生!</title>
    <link href="https://www.wangwangit.com/%E6%96%B0%E4%B9%B0%E7%9A%84%E7%94%B5%E8%A7%86%E6%88%90%E2%80%9C%E6%91%86%E8%AE%BE%E2%80%9D%EF%BC%9F%E5%88%AB%E6%80%A5%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%94%B5%E8%A7%86%E9%87%8D%E8%8E%B7%E6%96%B0%E7%94%9F/"/>
    <id>https://www.wangwangit.com/%E6%96%B0%E4%B9%B0%E7%9A%84%E7%94%B5%E8%A7%86%E6%88%90%E2%80%9C%E6%91%86%E8%AE%BE%E2%80%9D%EF%BC%9F%E5%88%AB%E6%80%A5%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%94%B5%E8%A7%86%E9%87%8D%E8%8E%B7%E6%96%B0%E7%94%9F/</id>
    <published>2025-10-18T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.948Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.996007.icu/file/1762223229209_20251104102703023.jpg" alt="微信图片_20250919161259_21_147"></p><p>现在的智能电视，系统是越来越封闭，想自己装个第三方软件，那叫一个费劲。</p><p><img src="https://img.996007.icu/file/1758268845872_20250919160042335.jpeg" alt="电视怎么解除禁止安装第三方软件？电视解除apk安装限制_小米电视_ZNDS"></p><p>不仅如此，最让人头疼的是，现在电视上各个视频App的会员都得单独开，跟手机会员还不通用，一个个那吃相，说实话是有点恶心了。折腾来折腾去，不就是想省点心、看个舒坦嘛。</p><p><img src="https://img.996007.icu/file/1758268814892_20250919160005173.jpeg" alt="让看电视更简单！电视“套娃”收费套路多，乱象治理全面展开"></p><p>所以，今天我就来给大家介绍一种方式，一个我最近在用的“曲线救国”方案，让你能自己给电视装上一些真正好用的软件！主角就是这个小工具——“野草助手”。</p><h4 id="野草助手是个啥？"><a href="#野草助手是个啥？" class="headerlink" title="野草助手是个啥？"></a>野草助手是个啥？</h4><p>简单来说，它就是一个能让你在电视上自由安装App的“摆渡”工具。</p><p>很多电视厂商为了推自家的应用商店，会限制你通过U盘安装下载好的App安装包（也就是APK文件）。野草助手的作用就是绕开这个限制。你先把野草助手装进电视，之后再想装别的软件，就可以通过它来安装，成功率高很多。</p><p><img src="https://img.996007.icu/file/1758267577918_20250919153925651.png" alt="img"></p><h4 id="具体怎么操作？"><a href="#具体怎么操作？" class="headerlink" title="具体怎么操作？"></a>具体怎么操作？</h4><p>整个过程分为两步：<strong>1. 安装野草助手本体</strong>；<strong>2. 通过它安装其他软件</strong>。</p><p><strong>第一步：把“野草助手”安装到电视里</strong></p><p>这步我们需要借助一台电脑和一个U盘(非必须)。也可以直接用手机传输软件到电视上!一般电视都自带传输助手的!</p><blockquote><p>官网: <a href="https://www.yecao.net/">https://www.yecao.net/</a></p></blockquote><ol><li><p><strong>准备工作</strong>：在电脑上搜索“野草助手”，找到它的官网或者一些比较知名的软件下载站，把它的安装包（一个<code>.apk</code>结尾的文件）下载下来，然后拷贝到你的U盘里。<strong>注意,这里要下载TV版本的,别下载错误</strong></p><ul><li><strong>（忘了提一点）</strong>：U盘最好格式化成<code>FAT32</code>格式，这是绝大多数电视都能识别的格式，可以避免很多奇怪的问题。</li></ul><p><img src="https://img.996007.icu/file/1758267623607_20250919154019463.png" alt="image-20250919154019317"></p></li><li><p><strong>电视端设置</strong>：这是最关键的一步。不同牌子的电视，操作路径可能不太一样，但核心思路都是找到“<strong>允许安装未知来源应用</strong>”这个选项。</p><ul><li>通常是在「设置」-「安全」或「开发者选项」里。</li><li>有些电视需要连续点击“版本号”或“序列号”几次，才能开启“开发者模式”，然后才能找到这个开关。我家的电视就是这样，当时找了好一会儿。大家可以根据自己电视的品牌去搜一下具体的开启方法。</li></ul><blockquote><p>这里官方提供了很多品牌的教程,可以前往: <a href="https://www.yecao.net/category/tutorial/">https://www.yecao.net/category/tutorial/</a> 查看!</p></blockquote></li><li><p><strong>开始安装</strong>：</p><ul><li>把存有安装包的U盘插到电视的USB接口上。</li><li>电视一般会自动弹出U盘文件的窗口，如果没有，就去「文件管理」或者「媒体中心」这类应用里找到U盘。</li><li>在U盘里找到你下载好的“野草助手”安装包，点击安装。如果前面的设置都做对了，这里应该就能顺利装上了。</li></ul></li></ol><p><strong>常见问题：</strong> 如果点击安装包没反应或者提示“禁止安装”怎么办？</p><ul><li>大概率是第二步的“允许未知来源”没打开，或者没找对地方。一定要先确认这个开关是打开状态。</li><li>换个USB接口试试，有时候电视的USB口会有兼容性问题。</li></ul><p><strong>第二步：用野草助手安装你需要的软件</strong></p><p>一旦野草助手装好了，后面就非常简单了。只需要打开软件,输入相关软件的取件码就可以了,或者自己安装一个手机版本,上传对应的软件,也可以安装到电视上了!</p><p><img src="https://img.996007.icu/file/1758267917519_20250919154505146.png" alt="image-20250919154505079"></p><p><img src="https://img.996007.icu/file/1758267845540_20250919154354053.png" alt="image-20250919154353976"></p><p>我这里分享了一个取件码,你也可以自己去贴吧或者抖音里搜索别人分享的取件码!  </p><p><img src="https://img.996007.icu/file/1758268703632_20250919155815813.png" alt="image-20250919155815507"></p><p><img src="https://img.996007.icu/file/1758268711845_20250919155826474.png" alt="image-20250919155826230"><img src="https://img.996007.icu/file/1758268726348_20250919155842162.png" alt="image-20250919155841961"></p><hr><p>好了，今天的分享就到这里。总的来说，“野草助手”算是一个非常实用的小工具，专门解决智能电视安装软件这个痛点。如果你也遇到了类似的问题，不妨按照上面的步骤试试看。</p><p>如果你有更好的方法或者其他好用的电视工具，也欢迎在评论区分享交流。</p>]]></content>
    
    
    <summary type="html">现在的智能电视，系统是越来越封闭，想自己装个第三方软件，那叫一个费劲。</summary>
    
    
    
    <category term="软件" scheme="https://www.wangwangit.com/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="追剧" scheme="https://www.wangwangit.com/tags/%E8%BF%BD%E5%89%A7/"/>
    
    <category term="看剧软件" scheme="https://www.wangwangit.com/tags/%E7%9C%8B%E5%89%A7%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>无需国外信用卡,教你0元无限开通ChatGPT Team</title>
    <link href="https://www.wangwangit.com/%E6%97%A0%E9%9C%80%E5%9B%BD%E5%A4%96%E4%BF%A1%E7%94%A8%E5%8D%A1,%E6%95%99%E4%BD%A00%E5%85%83%E6%97%A0%E9%99%90%E5%BC%80%E9%80%9AChatGPT%20Team/"/>
    <id>https://www.wangwangit.com/%E6%97%A0%E9%9C%80%E5%9B%BD%E5%A4%96%E4%BF%A1%E7%94%A8%E5%8D%A1,%E6%95%99%E4%BD%A00%E5%85%83%E6%97%A0%E9%99%90%E5%BC%80%E9%80%9AChatGPT%20Team/</id>
    <published>2025-10-12T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.948Z</updated>
    
    <content type="html"><![CDATA[<p>最近不少朋友应该都刷到了，OpenAI 开始给免费用户推送为期一个月的 ChatGPT Plus 试用!</p><p><img src="https://img.996007.icu/file/1760314725412_20251013081837548.png" alt="image-20251013081830406"></p><p>今天给大家介绍一下如何领取这份福利!以及如何无限制领取,可以将亲朋好友全部拉进来体验ChatGPT的最新模型!</p><p>开始之前,请大家先看一下我以前写的一篇关于”1美元体验ChatGPT Team”的教程,方便后续操作!</p><blockquote><p><a href="https://mp.weixin.qq.com/s/s9Gc0gLDOWcsfVgGukkLcg">https://mp.weixin.qq.com/s/s9Gc0gLDOWcsfVgGukkLcg</a></p></blockquote><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>一个美国的网络环境</li><li>一个Paypal账户,可以绑定国内Visa</li><li>一个新注册的ChatGPT账号</li></ul><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol><li><strong>美国IP,注册新账号</strong></li></ol><p>首先，这个 Plus 试用不是主动申请的，也没有固定的链接。你只能像我一样，没事就登录一下 ChatGPT 官网，看看有没有弹窗。</p><p>它长这个样子：</p><p><img src="https://img.996007.icu/file/1760315089902_20251013082438928.png" alt="image-20251013082438815"></p><ol start="2"><li><strong>进入订阅页面，找到 PayPal 入口</strong></li></ol><p>点击开始试用后，会跳转到一个订阅页面，这里注意把右下角的国家切换成法国!</p><p><img src="https://img.996007.icu/file/1760315343184_20251013082854964.png" alt="image-20251013082854868"></p><p><strong>如果你想要同时开通多个team,可以将窗口进行复制,要多少个就复制多少个!</strong></p><p><img src="https://img.996007.icu/file/1760315499564_20251013083134572.png" alt="image-20251013083134458"></p><ol start="3"><li><strong>登录并授权 PayPal</strong></li></ol><p>在弹出的窗口里，登录你的 PayPal 账号。这里用国内的 PayPal 账户就行，只要里面绑定了有效的银联储蓄卡或者信用卡。</p><p>登录成功后，PayPal 会请求你的授权，让你同意与 OpenAI 建立一个订阅关联。看清楚条款，一般就是同意让 OpenAI 在试用期后可以从你的 PayPal 扣款。确认无误后，点击“同意并继续”。</p><p><img src="https://img.996007.icu/file/1760315532999_20251013083206145.png" alt="image-20251013083206043"></p><p><strong>对于其他的窗口,同样点击订阅,然后等待第一个paypal登陆成功之后,刷新页面就可以直接付款了!</strong></p><ol start="4"><li><strong>完成验证，开通 Plus</strong></li></ol><p>授权完成后，页面会自动跳回 ChatGPT。顺利的话，系统会提示你订阅成功，你的账户就立刻升级到 Plus 了。左上角的模型选择那里，会出现 GPT-5的选项，这就说明你成功了。</p><p>说实话，整个过程比我想象的要顺畅，只要找到了 PayPal 入口，后面基本就是点几下鼠标的事。</p><p><img src="https://img.996007.icu/file/1760315631118_20251013083340988.png" alt="image-20251013083340908"></p><p><img src="https://img.996007.icu/file/1760315643542_20251013083355464.png" alt="image-20251013083355405"></p><h3 id="重要提醒"><a href="#重要提醒" class="headerlink" title="重要提醒"></a><strong>重要提醒</strong></h3><ul><li>**一定要记得取消订阅！**参考文章开头提到的文章进行取消订阅!</li></ul><p>好了，教程就到这里。总的来说，这是一个非常不错的官方福利，卡在支付环节确实可惜。希望这个方法能帮到有需要的朋友，赶紧去试试手气吧。</p>]]></content>
    
    
    <summary type="html">最近不少朋友应该都刷到了，OpenAI 开始给免费用户推送为期一个月的 ChatGPT Plus 试用!今天给大家介绍一下如何领取这份福利!以及如何无限制领取,可以将亲朋好友全部拉进来体验ChatGPT的最新模型!</summary>
    
    
    
    <category term="AI" scheme="https://www.wangwangit.com/categories/AI/"/>
    
    
    <category term="AI" scheme="https://www.wangwangit.com/tags/AI/"/>
    
    <category term="ChatGPT" scheme="https://www.wangwangit.com/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>国庆抢票还在花钱买加速包？别再交“智商税”了，我靠这套免费方案搞定回家票。</title>
    <link href="https://www.wangwangit.com/%E5%9B%BD%E5%BA%86%E6%8A%A2%E7%A5%A8%E8%BF%98%E5%9C%A8%E8%8A%B1%E9%92%B1%E4%B9%B0%E5%8A%A0%E9%80%9F%E5%8C%85%EF%BC%9F%E5%88%AB%E5%86%8D%E4%BA%A4%E2%80%9C%E6%99%BA%E5%95%86%E7%A8%8E%E2%80%9D%E4%BA%86%EF%BC%8C%E6%88%91%E9%9D%A0%E8%BF%99%E5%A5%97%E5%85%8D%E8%B4%B9%E6%96%B9%E6%A1%88%E6%90%9E%E5%AE%9A%E5%9B%9E%E5%AE%B6%E7%A5%A8/"/>
    <id>https://www.wangwangit.com/%E5%9B%BD%E5%BA%86%E6%8A%A2%E7%A5%A8%E8%BF%98%E5%9C%A8%E8%8A%B1%E9%92%B1%E4%B9%B0%E5%8A%A0%E9%80%9F%E5%8C%85%EF%BC%9F%E5%88%AB%E5%86%8D%E4%BA%A4%E2%80%9C%E6%99%BA%E5%95%86%E7%A8%8E%E2%80%9D%E4%BA%86%EF%BC%8C%E6%88%91%E9%9D%A0%E8%BF%99%E5%A5%97%E5%85%8D%E8%B4%B9%E6%96%B9%E6%A1%88%E6%90%9E%E5%AE%9A%E5%9B%9E%E5%AE%B6%E7%A5%A8/</id>
    <published>2025-09-18T04:14:00.000Z</published>
    <updated>2025-11-12T02:28:07.947Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.996007.icu/file/1758169279312_20250918122121899.png" alt="ChatGPT Image 2025年9月18日 12_20_59"></p><p>马上就十一国庆了，估计不少朋友又在为一张回家的火车票发愁。每年这个时候，“抢票”都成了头等大事。很多人第一时间会想到用携程、去哪儿这些第三方软件，花几十块钱买个加速包，感觉能更稳妥一些。</p><p>前几年我也这么干。但用了几次之后就发现，这东西越来越像“智商税”。今天给大家推荐“官方候补 + 12306Bypass”的抢票方式,帮我和亲友们抢到了很多节假日的车票!</p><p><img src="https://img.996007.icu/file/1758167311930_20250918114831524.png" alt="image-20250918114824418"></p><h3 id="第三方平台哪来的票"><a href="#第三方平台哪来的票" class="headerlink" title="第三方平台哪来的票?"></a>第三方平台哪来的票?</h3><p>实际上,官方曾经多次澄清没有给第三方提供优先购票权,但是很多用户依旧存在质疑!</p><p><img src="https://img.996007.icu/file/1758167478553_20250918115122474.png" alt="image-20250918115122424"></p><p>我们先来弄明白，携程、飞猪这些软件是怎么帮你“抢票”的。</p><p>其实原理很简单，它们并没有什么内部渠道，最终也都是要去 12306 的系统里买票。 它们的优势在于，你手动刷一次票，它用程序可以自动刷几百上千次。它们会把大量用户的需求收集起来，然后用企业级的带宽和高性能服务器，代替你高频率地刷新余票、提交订单。</p><p>你花钱买的“加速包”，本质上就是让你在它们的服务器里获得更高的刷新频率和更多的服务器资源，比如从 30 秒刷一次变成 5 秒一次，或者用多个服务器同时帮你抢。 听起来概率是高了，但最终能不能买到，还是个未知数。毕竟，车票总量没变，只是抢票的人换成了机器。</p><p>这里面有几个问题：</p><ol><li><strong>不保证成功：</strong> 几乎所有软件都会明确告诉你，加速包不保证 100% 成功。 抢到了，钱不退；抢不到，钱才退给你。怎么说呢，就是花了钱买个心理安慰。</li><li><strong>捆绑消费：</strong> 很多时候，加速包会和一些保险、酒店优惠券之类的东西默认勾选，一不小心就多花了不少冤枉钱。</li><li><strong>信息安全风险：</strong> 你需要把 12306 的账号密码授权给它们，这背后还是有一定个人信息泄露风险的。</li><li><strong>虚假宣传:</strong> 很多平台会在没票的情况下显示为有票,诱导你去购买相关的加速服务!</li></ol><p>最关键的是，自从 12306 官方推出了“候补购票”功能后，第三方软件的优势就大大降低了。</p><p><img src="https://img-xhpfm.xinhuaxmt.com/News/202201/0d07f6538b034418bc98c9ed76387f66.gif" alt="img"></p><h3 id="为什么“官方候补”才是真正的“王道”？"><a href="#为什么“官方候补”才是真正的“王道”？" class="headerlink" title="为什么“官方候补”才是真正的“王道”？"></a>为什么“官方候补”才是真正的“王道”？</h3><p>12306 的“候补购票”功能，我个人觉得是这几年最实用的一个更新。它的原理非常公平：当车票卖完后，你可以提交一个候补订单。一旦有其他旅客退票或者改签，系统会严格按照候补订单的提交时间顺序，依次把票给排队的人。</p><p>这就好比去食堂打饭，前面没饭了，你就在后面排队等着，新出锅的饭会按顺序给你，而不是谁嗓门大、跑得快就给谁。</p><p>这个机制直接把第三方抢票软件的“快速刷新”给架空了。因为无论它们刷得多快，都得遵守官方的排队规则。有余票放出来，也是先给候补队列里的人。</p><p>官方候补有几个很实用的优点：</p><ul><li><strong>公平透明：</strong> 严格按时间顺序排队，对所有人都一样。</li><li><strong>成功率高：</strong> 只要你提交得早，前面有人退票，你基本就能候补上。</li><li><strong>省心省力：</strong> 提交候补并预付票款后，系统会自动帮你排队和下单，成功了会通知你，失败了会自动退款，不需要你一直盯着。</li></ul><p>不过，官方候补也不是完美的。比如，你需要手动去查询哪些车次可以候补，然后一个个提交，如果想监控多个车次和日期，操作起来还是有点繁琐。</p><p>这时候，就轮到我们今天的主角——12306Bypass 出场了。</p><h3 id="自用推荐：12306Bypass"><a href="#自用推荐：12306Bypass" class="headerlink" title="自用推荐：12306Bypass"></a>自用推荐：12306Bypass</h3><blockquote><p>官网地址: <a href="https://www.bypass.cn/">https://www.bypass.cn/</a></p></blockquote><p>首先要说清楚，12306Bypass 是一款完全免费的、在你自己电脑上运行的辅助工具。你可以把它理解成一个帮你自动操作 12306 官网的“机器人”。</p><p>我用了这工具好几年了，逢年过节抢票基本都靠它。它的核心功能就是帮你不知疲倦地执行抢票操作，把我们从重复的刷新和点击中解放出来。</p><p><img src="https://img.996007.icu/file/1758168700743_20250918121144002.png" alt="image-20250918121143829"></p><p><strong>它是如何搭配官方候补的？</strong></p><p>12306Bypass 能自动帮你查询余票。当没有票的时候，它能自动帮你提交候补订单。你只需要提前在软件里设置好要买的车次、乘客、席别和日期，它就能在放票的一瞬间或者检测到可以候补时，以最快的速度帮你完成所有操作。</p><p><strong>详细使用步骤：</strong></p><ol><li><strong>下载与登录：</strong> 在网上搜索“12306Bypass”，找到官网或可靠的下载渠道下载。软件是绿色版，解压后双击就能运行。它需要你用 12306 手机 App 扫码登录。</li><li><strong>填写购票信息：</strong> 在软件界面上，填写出发地、目的地和乘车日期，然后点击“查询车票”。</li><li><strong>选择车次和乘客：</strong> 在查询出的车次列表里，勾选你想要候补的车次（可以多选），然后在右侧的乘客列表里勾选乘车人。你还可以指定席别，比如“二等座”、“硬卧”等。</li><li><strong>设置抢票参数：</strong> 这是最关键的一步。你可以在软件下方设置好“候补”相关的选项。比如，勾选“无票时自动提交候补”，并选择接受的席别。对了，还可以设置一个“截止兑现时间”。</li><li><strong>开始抢票&#x2F;候补：</strong> 所有信息设置好之后，点击“开始抢票”按钮。软件就会开始自动循环查询，一旦发现有机会，就会立即帮你提交订单或候补申请。接下来你把软件挂在后台就行，完全不用管了。</li></ol><p><img src="https://img.996007.icu/file/1758168574085_20250918120929685.png" alt="image-20250918120929534"></p><p>我一般就是将软件挂在云电脑上,让他自动抢就可以了!我的配置大概就是截图所示,可以根据自己的需求,自行配置!</p><p><strong>需要补充说明的几点：</strong></p><ul><li>这个工具只适用于 Windows 系统。</li><li>它只是一个辅助工具，最终能否买到票，还是取决于 12306 官方系统是否有票放出以及你的候补顺序。</li></ul><p>总而言之，在国庆这种抢票高峰期，花钱买第三方软件的加速包，不如踏踏实实地使用官方的候补功能。而 12306Bypass 这个免费工具，则能帮你更高效、更省力地利用好这个官方渠道，让你在抢票大战中，拥有一个可靠的技术“外挂”。</p><p>希望这个分享能对你有所帮助，祝大家都能顺利抢到回家的票！</p>]]></content>
    
    
    <summary type="html">马上就十一国庆了，估计不少朋友又在为一张回家的火车票发愁。每年这个时候，“抢票”都成了头等大事。很多人第一时间会想到用携程、去哪儿这些第三方软件，花几十块钱买个加速包，感觉能更稳妥一些。</summary>
    
    
    
    <category term="软件" scheme="https://www.wangwangit.com/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="12306" scheme="https://www.wangwangit.com/tags/12306/"/>
    
    <category term="抢票" scheme="https://www.wangwangit.com/tags/%E6%8A%A2%E7%A5%A8/"/>
    
  </entry>
  
  <entry>
    <title>别再忍受卡顿了！抛开向日葵和ToDesk，这个免费远程神器才是真香(二)</title>
    <link href="https://www.wangwangit.com/%E5%88%AB%E5%86%8D%E5%BF%8D%E5%8F%97%E5%8D%A1%E9%A1%BF%E4%BA%86%EF%BC%81%E6%8A%9B%E5%BC%80%E5%90%91%E6%97%A5%E8%91%B5%E5%92%8CToDesk%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%85%8D%E8%B4%B9%E8%BF%9C%E7%A8%8B%E7%A5%9E%E5%99%A8%E6%89%8D%E6%98%AF%E7%9C%9F%E9%A6%99(%E4%BA%8C)/"/>
    <id>https://www.wangwangit.com/%E5%88%AB%E5%86%8D%E5%BF%8D%E5%8F%97%E5%8D%A1%E9%A1%BF%E4%BA%86%EF%BC%81%E6%8A%9B%E5%BC%80%E5%90%91%E6%97%A5%E8%91%B5%E5%92%8CToDesk%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%85%8D%E8%B4%B9%E8%BF%9C%E7%A8%8B%E7%A5%9E%E5%99%A8%E6%89%8D%E6%98%AF%E7%9C%9F%E9%A6%99(%E4%BA%8C)/</id>
    <published>2025-08-27T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.947Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章里，我们聊了网易UU远程，它用完全免费的模式，提供了顶级的远程体验，可以说是目前“开箱即用”场景下的最优解。</p><p>不过，评论区也有朋友提出一个很深刻的问题：<strong>“这么好的东西完全免费，它到底图什么？能一直免费下去吗？”</strong></p><p><img src="https://img.996007.icu/file/1754383501413_image-20250805164455100.png" alt="image-20250805164455100"></p><p>这确实问到了点子上。怎么说呢，就是把所有的便利都建立在商业公司的“善意”上，心里总归有点不踏实。万一哪天它开始收费、或者加入广告、又或者它的隐私政策让你不再信任，我们又该何去何从？</p><p>这种不确定性，正是所有商业软件的通病。</p><p>所以今天，我要分享一个“一劳永逸”的解决方案。它能让你彻底摆脱对任何商业平台的依赖，将数据和连接的控制权100%掌握在自己手里。这条路，就是通往“数字主权”的自建之路，而我们要用的核心工具，就是大名鼎鼎的开源软件——<strong>RustDesk</strong>。</p><p>更关键的一点是，有细心的用户发现，RustDesk的官方公共服务器好像已经屏蔽了国内的直接访问。这意味着，对于咱们国内用户来说，<strong>自建服务几乎已经从一个“可选项”，变成了体验RustDesk的“必选项”</strong>。</p><blockquote><p>官网: <a href="https://rustdesk.com/zh-cn/">https://rustdesk.com/zh-cn/</a></p></blockquote><hr><table><thead><tr><th align="left">特性维度</th><th align="left"><strong>向日葵&#x2F;ToDesk (免费版)</strong></th><th align="left"><strong>网易UU远程</strong></th><th align="left"><strong>自建RustDesk</strong></th></tr></thead><tbody><tr><td align="left"><strong>理想用户</strong></td><td align="left">轻度、应急用户</td><td align="left">游戏玩家、学生、上班族</td><td align="left">技术爱好者、隐私至上者</td></tr><tr><td align="left"><strong>上手难度</strong></td><td align="left">⭐（极简）</td><td align="left">⭐（极简）</td><td align="left">⭐⭐⭐⭐（需要动手）</td></tr><tr><td align="left"><strong>性能体验</strong></td><td align="left">⭐⭐（高峰期卡顿）</td><td align="left">⭐⭐⭐⭐⭐（极致流畅）</td><td align="left">⭐⭐⭐⭐⭐（取决于自己）</td></tr><tr><td align="left"><strong>花费成本</strong></td><td align="left">免费（但体验受限）</td><td align="left"><strong>完全免费</strong></td><td align="left">少量服务器年费+时间成本</td></tr><tr><td align="left"><strong>核心优势</strong></td><td align="left">用户基数大</td><td align="left"><strong>免费提供顶级性能</strong></td><td align="left"><strong>数据主权，绝对隐私</strong></td></tr></tbody></table><p><img src="https://img.996007.icu/file/1754382947637_image-20250805163539252.png" alt="image-20250805163539252"></p><hr><h3 id="实践指南：别怕，搭建过程比想象中简单"><a href="#实践指南：别怕，搭建过程比想象中简单" class="headerlink" title="实践指南：别怕，搭建过程比想象中简单"></a><strong>实践指南：别怕，搭建过程比想象中简单</strong></h3><p>一听到“自建服务器”，很多朋友可能就望而却步了。但相信我，得益于Docker这样的现代化工具，整个过程已经被简化到了极致。下面这份教程，就是我为普通用户量身定制的。</p><p><strong>前提准备：你需要一台云服务器（VPS）</strong></p><p>这个是硬性条件，你得先有个“服务器”。别被名字吓到，它本质上就是一台位于云端的、24小时开机的迷你电脑。</p><ul><li><strong>去哪买？</strong> 国内的阿里云、腾讯云等都有“轻量应用服务器”产品，非常适合新手。</li><li><strong>买多贵？</strong> RustDesk对硬件的要求极低，买<strong>最便宜的入门款（通常是1核CPU&#x2F;2GB内存）就绰绰有余</strong>。得益于激烈的市场竞争，这类服务器针对新用户的价格非常亲民，一年下来大概也就一两百块钱。</li></ul><p><strong>开始搭建：真正的“三步走”</strong></p><p>在你买好服务器，并且能通过工具连接上它的命令行（那个黑底白字的界面）之后，跟着我敲代码就行。这块可能需要一些服务器使用的经验!</p><p><strong>步骤 1：安装 Docker</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash &lt;(wget -qO- https://get.docker.com)</span><br></pre></td></tr></table></figure><p><strong>步骤 2：下载 compose.yml</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget rustdesk.com/oss.yml -O compose.yml</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget rustdesk.com/pro.yml -O compose.yml</span><br></pre></td></tr></table></figure><p><strong>步骤 3：启动 Compose</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://img.996007.icu/file/1754383611911_image-20250805164643695.png" alt="image-20250805164643695"></p><p><strong>注意：配置客户端与防火墙</strong><br>现在，你需要在自己电脑和被控电脑上都装好RustDesk客户端。</p><p><strong>打开服务器的端口</strong>：登录你的云服务商后台，找到防火墙设置，确保TCP协议的<code>21114</code>到<code>21119</code>端口，以及UDP协议的<code>21116</code>端口是开放的。这是为了让你的电脑能顺利连接到服务器。</p><p><img src="https://img.996007.icu/file/1754383316482_image-20250805164144766.png" alt="image-20250805164144766"></p><p><strong>配置客户端</strong>：打开RustDesk客户端的设置，找到“ID&#x2F;中继服务器”选项。</p><ul><li>在“<strong>ID服务器</strong>”一栏，填入你云服务器的<strong>公网IP地址</strong>。</li><li>在“<strong>Key</strong>”一栏，填入一串公钥。这串密钥在你服务器的<code>compose.yml</code>文件中配置的数据目录里，可以在工作目录&#x2F;数据文件夹中的 <code>id_ed25519.pub</code> 文件中找到。</li></ul><p><img src="https://img.996007.icu/file/1754383772805_image-20250805164927987.png" alt="image-20250805164927987"></p><ul><li>其他选项留空，保存即可。</li></ul><p><img src="https://img.996007.icu/file/1754383118532_image-20250805163826311.png" alt="image-20250805163826311"></p><p><img src="https://img.996007.icu/file/1754383156706_image-20250805163902791.png" alt="image-20250805163902791"></p><p>至此，你的所有远程连接都将通过自己的专属服务器进行，大功告成！</p><hr><h3 id="自由的成本：这事儿到底值不值？"><a href="#自由的成本：这事儿到底值不值？" class="headerlink" title="自由的成本：这事儿到底值不值？"></a><strong>自由的成本：这事儿到底值不值？</strong></h3><p>自建服务虽然带来了无与伦比的控制权，但它并非完全没有成本。</p><ul><li><strong>金钱成本</strong>：主要是服务器的年费，<strong>大概每年100-200元人民币</strong>。说实话，这比订阅任何一款主流商业远程软件的年费都便宜得多。</li><li><strong>时间与学习成本</strong>：这才是真正的“隐性成本”。虽然过程已经简化，但它仍然要求你：<ul><li>不害怕黑乎乎的命令行界面。</li><li>愿意去理解IP地址、端口这些基础概念。</li><li>承担起维护服务器的责任（虽然RustDesk本身很稳定，基本不用管）。</li></ul></li></ul><p>总而言之，阻碍普通用户自建RustDesk的，从来不是钱，而是开始动手所需的动力和一点点学习意愿。</p><p><strong>我个人觉得，它更像是一种爱好或一项技能投资。对于那些乐于探索、珍视隐私、并希望将数字生活牢牢掌握在自己手中的朋友来说，自建RustDesk无疑是当前最理想、最酷的解决方案。</strong></p><p>希望这篇详细的指南能打消你的疑虑，给你带来动手的勇气。我们下期再见！</p>]]></content>
    
    
    <summary type="html">在上一篇文章里，我们聊了网易UU远程，它用完全免费的模式，提供了顶级的远程体验，可以说是目前“开箱即用”场景下的最优解。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="工具" scheme="https://www.wangwangit.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="远程" scheme="https://www.wangwangit.com/tags/%E8%BF%9C%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>保姆级攻略：2元搞定一年正版Office，非学生党也能冲！</title>
    <link href="https://www.wangwangit.com/%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%94%BB%E7%95%A5%EF%BC%9A2%E5%85%83%E6%90%9E%E5%AE%9A%E4%B8%80%E5%B9%B4%E6%AD%A3%E7%89%88Office%EF%BC%8C%E9%9D%9E%E5%AD%A6%E7%94%9F%E5%85%9A%E4%B9%9F%E8%83%BD%E5%86%B2%EF%BC%81/"/>
    <id>https://www.wangwangit.com/%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%94%BB%E7%95%A5%EF%BC%9A2%E5%85%83%E6%90%9E%E5%AE%9A%E4%B8%80%E5%B9%B4%E6%AD%A3%E7%89%88Office%EF%BC%8C%E9%9D%9E%E5%AD%A6%E7%94%9F%E5%85%9A%E4%B9%9F%E8%83%BD%E5%86%B2%EF%BC%81/</id>
    <published>2025-08-26T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.946Z</updated>
    
    <content type="html"><![CDATA[<p>最近在小红书上看到一个“2块钱用一年个人版Microsoft 365”的教程。本着爱折腾和分享的精神，我赶紧去研究了一下，今天就和大家聊聊这个方法到底是怎么回事。</p><h4 id="个人版订阅都有啥"><a href="#个人版订阅都有啥" class="headerlink" title="个人版订阅都有啥?"></a>个人版订阅都有啥?</h4><p>个人版包含的东西还是挺全的：</p><ul><li>全套的Office应用：Word, Excel, PowerPoint等等。</li><li>1TB的OneDrive云存储空间。</li><li>适用于PC、Mac和移动设备。</li></ul><p><img src="https://img.996007.icu/file/1755762387829_image-20250821154620434.png" alt="image-20250821154620434"></p><h4 id="如何操作"><a href="#如何操作" class="headerlink" title="如何操作?"></a>如何操作?</h4><p>具体的操作步骤大概是这样的：</p><ol><li><p><strong>访问学生优惠页面</strong>：打开微软中国的Microsoft 365学生定价页面</p><blockquote><p><a href="https://www.microsoft.com/zh-cn/microsoft-365/college-student-pricing">https://www.microsoft.com/zh-cn/microsoft-365/college-student-pricing</a></p></blockquote></li><li><p><strong>验证学生身份</strong>：这一步是关键。如果你是大学生，直接用学校提供的 <code>.edu</code> 后缀的邮箱进行验证就行，这是最正规的方式。(<strong>我的账号好像都没让我验证,可能以前绑定过</strong>)</p></li><li><p><strong>“特殊”验证方式</strong>：如果你没有教育邮箱，可以去找一个“临时教育邮箱”来完成验证。</p><blockquote><p>我的导航站里也有临时邮箱,可以自己去试试 <a href="https://nav.wangwangit.com/">https://nav.wangwangit.com</a></p></blockquote><p><img src="https://img.996007.icu/file/1755762592909_image-20250821154940640.png" alt="image-20250821154940640"></p></li><li><p><strong>订阅和支付</strong>：验证通过后，登录自己的微软账号，绑定支付宝，然后会看到一个订阅价格，比如18元&#x2F;月。先选择这个订阅。</p></li><li><p><strong>修改订阅</strong>：最关键的一步来了。在完成支付后，可以去订阅管理页面，把月度订阅改成年度订阅，这时候价格就会显示为每年2元。</p></li></ol><p><img src="https://img.996007.icu/file/1755762661269_image-20250821155049354.png" alt="image-20250821155049354"></p><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>说实话，这个方法我研究下来，感觉更像是一个有时效性的漏洞，而不是一个可以长期依赖的羊毛。</p><p><strong>1. 成功率不确定</strong><br>这个方法不适合所有人，而且很可能随时会“失效”。微软一旦修复了这个价格显示的Bug，或者加强了对临时邮箱的验证，这条路子就走不通了。你看到这篇文章的时候，可能已经无法复现了。</p><p><strong>2. 临时邮箱的风险</strong><br>用临时邮箱注册的账号，稳定性和安全性是个大问题。我个人不太推荐这种方式。首先，你无法长期持有这个邮箱，如果后续需要接收验证邮件，会非常麻烦。其次，微软会定期或不定期地重新验证用户的学生身份，一旦验证失败，账号的订阅资格就可能被取消。你存在OneDrive里的1TB文件，到时处理起来会相当棘手。</p><p><strong>3. “2元”价格能维持多久？</strong><br>即便你成功了，这个价格大概率也只是一次性的。明年续费的时候，基本不可能还是这个价。所以，它更适合那些有短期应急需求，比如就这一两个月需要用Office做个毕业设计之类的朋友。</p><h4 id="更稳妥的替代方案？"><a href="#更稳妥的替代方案？" class="headerlink" title="更稳妥的替代方案？"></a>更稳妥的替代方案？</h4><p>如果你需要长期、稳定地使用Office，我还是建议考虑下面两种更靠谱的方案：</p><ul><li><p><strong>方案一：和朋友合租“家庭版”</strong><br>这是我个人最推荐的方式。Microsoft 365家庭版最多支持6个用户，每个人都有独立的1TB云存储空间。找齐6个“车友”，在官方渠道或者靠谱的第三方渠道购买，平摊下来每个人一年也就几十块钱。安全、稳定，还省心。</p></li><li><p><strong>方案二：查询学校的免费福利</strong><br>很多国内外的大学本身就和微软有合作，会为在校学生提供免费的Office 365 A1账户。这个账户虽然云存储空间和功能上可能和个人版略有差异，但日常使用完全足够，而且是完全免费和正规的。你可以先去自己学校的IT部门网站或者信息化中心查一下，说不定有惊喜。</p></li></ul>]]></content>
    
    
    <summary type="html">最近在小红书上看到一个“2块钱用一年个人版Microsoft 365”的教程。本着爱折腾和分享的精神，我赶紧去研究了一下，今天就和大家聊聊这个方法到底是怎么回事。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Office" scheme="https://www.wangwangit.com/tags/Office/"/>
    
    <category term="工具" scheme="https://www.wangwangit.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>不用花一分钱！教你搭建专属文字转语音网站，支持20+种声音</title>
    <link href="https://www.wangwangit.com/%E4%B8%8D%E7%94%A8%E8%8A%B1%E4%B8%80%E5%88%86%E9%92%B1-%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BA%E4%B8%93%E5%B1%9E%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3%E7%BD%91%E7%AB%99-%E6%94%AF%E6%8C%8120%E5%A4%9A%E7%A7%8D%E5%A3%B0%E9%9F%B3/"/>
    <id>https://www.wangwangit.com/%E4%B8%8D%E7%94%A8%E8%8A%B1%E4%B8%80%E5%88%86%E9%92%B1-%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BA%E4%B8%93%E5%B1%9E%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3%E7%BD%91%E7%AB%99-%E6%94%AF%E6%8C%8120%E5%A4%9A%E7%A7%8D%E5%A3%B0%E9%9F%B3/</id>
    <published>2025-08-25T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Edge-TTS？"><a href="#什么是Edge-TTS？" class="headerlink" title="什么是Edge TTS？"></a>什么是Edge TTS？</h2><p>Edge TTS（Text-to-Speech）是微软Edge浏览器内置的语音合成技术，它具有以下惊人特点：</p><ul><li><strong>声音丰富</strong>：支持20+种高质量中文声音，包括晓晓、云希、晓伊等</li><li><strong>完全免费</strong>：无需API密钥，无使用限制</li><li><strong>响应迅速</strong>：毫秒级生成，体验流畅</li><li><strong>参数丰富</strong>：支持语速、音调、音量、语音风格调节</li><li><strong>跨平台</strong>：支持所有现代浏览器和移动设备</li></ul><blockquote><p>直接使用: <a href="https://tts.wangwangit.com/">https://tts.wangwangit.com</a></p></blockquote><p><img src="https://img.996007.icu/file/1754988428646_image-20250812164659353.png" alt="image-20250812164659353"></p><h2 id="实战教程"><a href="#实战教程" class="headerlink" title="实战教程"></a>实战教程</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>你只需要：</p><ul><li>一个GitHub账号</li><li>一个Cloudflare账号（免费）</li><li>5分钟时间</li></ul><h3 id="第一步：获取项目代码"><a href="#第一步：获取项目代码" class="headerlink" title="第一步：获取项目代码"></a>第一步：获取项目代码</h3><ol><li>访问项目地址：<code>https://github.com/wangwangit/tts</code></li><li>点击右上角的 <code>Fork</code> 按钮，将项目复制到你的GitHub账号</li></ol><h3 id="第二步：一键部署到Cloudflare-Workers"><a href="#第二步：一键部署到Cloudflare-Workers" class="headerlink" title="第二步：一键部署到Cloudflare Workers"></a>第二步：一键部署到Cloudflare Workers</h3><ol><li><p><strong>注册Cloudflare账号</strong></p><ul><li>访问 <a href="https://cloudflare.com/">cloudflare.com</a></li><li>注册免费账号</li></ul></li><li><p><strong>一键部署</strong></p><ul><li>点击项目中的部署按钮：</li></ul><p><img src="https://img.996007.icu/file/1754988168810_image-20250812164236857.png" alt="image-20250812164236857"></p><ul><li>授权GitHub访问权限</li><li>选择要部署的仓库</li></ul><p><img src="https://img.996007.icu/file/1754988204911_image-20250812164318127.png" alt="image-20250812164318127"></p><ul><li>等待部署完成</li></ul></li><li><p><strong>获取访问地址</strong></p><ul><li>部署成功后，你会得到一个类似 <code>https://your-app.workers.dev</code> 的地址</li><li>这就是你的专属语音合成网站！</li></ul></li></ol><p><img src="https://img.996007.icu/file/1754988251075_image-20250812164405087.png" alt="image-20250812164405087"></p><h3 id="第三步：自定义域名（可选）"><a href="#第三步：自定义域名（可选）" class="headerlink" title="第三步：自定义域名（可选）"></a>第三步：自定义域名（可选）</h3><ol><li>在Cloudflare控制台中找到你的Worker</li><li>添加自定义域名</li><li>配置DNS解析</li></ol><p><img src="https://img.996007.icu/file/1754988273478_image-20250812164430064.png" alt="image-20250812164430064"></p><h3 id="API调用示例"><a href="#API调用示例" class="headerlink" title="API调用示例"></a>API调用示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础调用</span></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://your-domain.com/v1/audio/speech&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="attr">input</span>: <span class="string">&quot;你好，这是一个测试&quot;</span>,</span><br><span class="line">        <span class="attr">voice</span>: <span class="string">&quot;zh-CN-XiaoxiaoNeural&quot;</span>,</span><br><span class="line">        <span class="attr">speed</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">pitch</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&quot;general&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> audioBlob = <span class="keyword">await</span> response.<span class="title function_">blob</span>();</span><br></pre></td></tr></table></figure><h3 id="批量处理脚本"><a href="#批量处理脚本" class="headerlink" title="批量处理脚本"></a>批量处理脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 批量转换文本文件</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *.txt; <span class="keyword">do</span></span><br><span class="line">    curl -X POST <span class="string">&quot;https://your-domain.com/v1/audio/speech&quot;</span> \</span><br><span class="line">      -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">      -d <span class="string">&quot;&#123;\&quot;input\&quot;: \&quot;<span class="subst">$(cat $file)</span>\&quot;, \&quot;voice\&quot;: \&quot;zh-CN-XiaoxiaoNeural\&quot;&#125;&quot;</span> \</span><br><span class="line">      --output <span class="string">&quot;<span class="variable">$&#123;file%.txt&#125;</span>.mp3&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="注意事项与最佳实践"><a href="#注意事项与最佳实践" class="headerlink" title="注意事项与最佳实践"></a>注意事项与最佳实践</h2><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><ul><li>遵守微软服务条款</li><li>避免大量并发请求</li><li>不要用于商业用途的大规模部署</li></ul>]]></content>
    
    
    <summary type="html">还在为找不到合适的语音合成工具而烦恼吗？今天教你用微软Edge TTS技术，零成本搭建一个专属的文字转语音网站！</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="工具" scheme="https://www.wangwangit.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="TTS" scheme="https://www.wangwangit.com/tags/TTS/"/>
    
  </entry>
  
  <entry>
    <title>别再忍受卡顿了！抛开向日葵和ToDesk，这个免费远程神器才是真香(一)</title>
    <link href="https://www.wangwangit.com/%E5%88%AB%E5%86%8D%E5%BF%8D%E5%8F%97%E5%8D%A1%E9%A1%BF%E4%BA%86%EF%BC%81%E6%8A%9B%E5%BC%80%E5%90%91%E6%97%A5%E8%91%B5%E5%92%8CToDesk%EF%BC%8C%E8%BF%992%E4%B8%AA%E5%85%8D%E8%B4%B9%E8%BF%9C%E7%A8%8B%E7%A5%9E%E5%99%A8%E6%89%8D%E6%98%AF%E7%9C%9F%E9%A6%99/"/>
    <id>https://www.wangwangit.com/%E5%88%AB%E5%86%8D%E5%BF%8D%E5%8F%97%E5%8D%A1%E9%A1%BF%E4%BA%86%EF%BC%81%E6%8A%9B%E5%BC%80%E5%90%91%E6%97%A5%E8%91%B5%E5%92%8CToDesk%EF%BC%8C%E8%BF%992%E4%B8%AA%E5%85%8D%E8%B4%B9%E8%BF%9C%E7%A8%8B%E7%A5%9E%E5%99%A8%E6%89%8D%E6%98%AF%E7%9C%9F%E9%A6%99/</id>
    <published>2025-08-23T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.947Z</updated>
    
    <content type="html"><![CDATA[<p>最近有几个朋友不约而同地跟我吐槽，说手里的远程控制软件越来越不好用了。具体来说，就是我们最熟悉的向日葵和ToDesk，免费版用起来是肉眼可见的卡，尤其在晚上高峰期，操作延迟高得能让人抓狂。</p><img src="https://img.996007.icu/file/1754379070175_image-20250805153104134.png" alt="image-20250805153104134" style="zoom:200%;" /><p><img src="https://img.996007.icu/file/1754379015296_image-20250805153007317.png" alt="image-20250805153007317"></p><p>我也用了很久，深有同感。其实这背后原因不复杂，任何软件做大了，用户多了，自然要考虑赚钱。于是，通过限制免费版的性能和功能，引导你升级付费，就成了一种心照不宣的“常规操作”。咱们普通用户，就成了被“挤压”的对象。</p><p>最烦人的是，有时候只是连接时间长一点，或者在工作时间用了一下，就会被弹窗警告“疑似商业用途”，连接说断就断。这种不确定性，让原本方便的工具变得一点也不可靠了。</p><p>难道就没有又免费、又好用的远程控制软件了吗？</p><p>当然有！经过我一番折腾和深度试用，今天就给大家带来一个主打开箱即用的神器!</p><table><thead><tr><th align="left">特性维度</th><th align="left"><strong>向日葵&#x2F;ToDesk (免费版)</strong></th><th align="left"><strong>网易UU远程</strong></th></tr></thead><tbody><tr><td align="left"><strong>理想用户</strong></td><td align="left">轻度、应急用户</td><td align="left">游戏玩家、学生、上班族</td></tr><tr><td align="left"><strong>上手难度</strong></td><td align="left">⭐（极简）</td><td align="left">⭐（极简）</td></tr><tr><td align="left"><strong>性能体验</strong></td><td align="left">⭐⭐（高峰期卡顿）</td><td align="left">⭐⭐⭐⭐⭐（极致流畅）</td></tr><tr><td align="left"><strong>花费成本</strong></td><td align="left">免费（但体验受限）</td><td align="left"><strong>完全免费</strong></td></tr><tr><td align="left"><strong>核心优势</strong></td><td align="left">用户基数大</td><td align="left"><strong>免费提供顶级性能</strong></td></tr></tbody></table><hr><h3 id="网易UU远程"><a href="#网易UU远程" class="headerlink" title="网易UU远程"></a><strong>网易UU远程</strong></h3><blockquote><p>官网: <a href="https://uuyc.163.com/">https://uuyc.163.com</a></p></blockquote><p><strong>真4K、真免费、真好用，目前普通用户的“最优解”。</strong></p><p><img src="https://img.996007.icu/file/1754376857437_image-20250805145408656.png" alt="image-20250805145408656"></p><p><img src="https://img.996007.icu/file/1754376774799_image-20250805145241352.png" alt="image-20250805145241352"></p><p>无意中发现了这个工具，试用后我直接把电脑上其他的远程软件都给卸了。网易做游戏加速器起家，“UU加速器”在玩家圈里口碑一直不错。现在，他们把这套成熟的网络优化技术和服务器资源，拿来做了个远程控制软件，属于是“降维打击”了。</p><p>先说好,不是打广告,不过目前用下来,在还没有开始收割用户之前,还是非常不错的! 总结下来它有几个让我拍案叫绝的优点：</p><p><strong>1. 性能强到离谱，而且完全免费</strong><br>这可能是它最核心的竞争力。UU远程直接把付费级的功能全都免费了：</p><ul><li><strong>画质超清</strong>：支持到4K分辨率和144Hz刷新率，还提供了“真彩模式”。这是什么概念？就是你用手机或平板远程连接电脑，看到的画面色彩、清晰度，几乎和直接坐在电脑前一模一样。我试着用它在平板上串流玩《原神》，延迟低到几乎感觉不到，体验极佳。</li><li><strong>连接丝滑</strong>：得益于网易的加速技术，连接速度和稳定性确实没得说。我这边测试，基本都是秒连，操作起来行云流水，跟在本地用没啥区别，告别了传统免费软件那种PPT式的卡顿感。</li><li><strong>文件传输不限速</strong>：这个功能，说实话，太实用了！之前用其他软件的免费版传个大点的文件，那速度能让你等到花儿都谢了。UU远程直接不限速、不限文件大小和数量，我经常用它在公司和家里的电脑间传几十个G的视频素材，非常方便。</li></ul><p><img src="https://img.996007.icu/file/1754381519467_wechat_2025-08-05_161117_314.png" alt="wechat_2025-08-05_161117_314"></p><p><img src="https://img.996007.icu/file/1754377122539_work_0ac97461.gif" alt="work_0ac97461"></p><p><strong>2. 贴心好用，是个“细节控”</strong></p><img src="https://img.996007.icu/file/1754381156207_image-20250805160544284.png" alt="image-20250805160544284" style="zoom:200%;" /><p>除了性能，它的界面简洁, 易用性也做得很好。比如支持远程开机、一键隐藏被控电脑屏幕的“隐私模式”、多显示器协同等等。界面设计也很现代化，用设备码和验证码就能连接，小白用户也能轻松上手。</p><p>对了，还有个细节差点忘了，它对外设的支持特别好。不仅支持游戏手柄，甚至连iPad的妙控键盘都能完美适配，对移动办公和娱乐用户来说绝对是福音。</p><p><strong>适用人群：</strong></p><ul><li><strong>游戏玩家</strong>：随时随地在手机、平板上畅玩你的PC大作。</li><li><strong>学生&#x2F;上班族</strong>：远程修改论文、传输资料、临时处理工作，体验一流。</li><li><strong>创意工作者</strong>：虽然达不到最顶级的专业色彩标准，但其高清低延迟的特性，处理一般的设计稿和视频剪辑也绰绰有余。</li></ul><p>网易UU远程凭借其免费且强大的性能，是目前绝大多数普通用户的首选。不过也要坦诚一点，这种完全免费的模式能持续多久是个未知数，未来可能会加入广告或付费版。但至少在当下，它就是那个“我全都要”的完美答案。</p><p>当然,你也可以去看看我前几期推荐的组网工具,然后搭配微软官方的RDP进行远程!</p><blockquote><p><a href="https://mp.weixin.qq.com/s/Bx7MmQ5kOL0pfov9geFogQ">https://mp.weixin.qq.com/s/Bx7MmQ5kOL0pfov9geFogQ</a></p></blockquote><p><img src="https://img.996007.icu/file/1754377981602_image-20250805151253855.png" alt="image-20250805151253855"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>希望今天的分享能对你有所帮助！如果你有其他好用的工具，也欢迎在评论区留言交流。我们下期再见！下期我将分享更加极客的远程工具!</p>]]></content>
    
    
    <summary type="html">最近有几个朋友不约而同地跟我吐槽，说手里的远程控制软件越来越不好用了。具体来说，就是我们最熟悉的向日葵和ToDesk，免费版用起来是肉眼可见的卡，尤其在晚上高峰期，操作延迟高得能让人抓狂。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="工具" scheme="https://www.wangwangit.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="远程" scheme="https://www.wangwangit.com/tags/%E8%BF%9C%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>解锁听书新姿势，这个神仙TTS搭档你还没用上吗？</title>
    <link href="https://www.wangwangit.com/%E8%A7%A3%E9%94%81%E5%90%AC%E4%B9%A6%E6%96%B0%E5%A7%BF%E5%8A%BF%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%A5%9E%E4%BB%99TTS%E6%90%AD%E6%A1%A3%E4%BD%A0%E8%BF%98%E6%B2%A1%E7%94%A8%E4%B8%8A%E5%90%97%EF%BC%9F/"/>
    <id>https://www.wangwangit.com/%E8%A7%A3%E9%94%81%E5%90%AC%E4%B9%A6%E6%96%B0%E5%A7%BF%E5%8A%BF%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%A5%9E%E4%BB%99TTS%E6%90%AD%E6%A1%A3%E4%BD%A0%E8%BF%98%E6%B2%A1%E7%94%A8%E4%B8%8A%E5%90%97%EF%BC%9F/</id>
    <published>2025-08-23T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.950Z</updated>
    
    <content type="html"><![CDATA[<p>前几天写了一篇文章,介绍如何自建一个免费的TTS网站,有留言说能不能用来听小说,手机自带的音频都太生硬,听起来容易出戏, 像微信读书之类的APP又听着听着就让你开通会员了!</p><p>所以，今天就直接上干货，给大家介绍一款能让朗读效果天翻地覆的工具——MultiTTS。它和“阅读”APP组合起来，绝对能让你惊喜。</p><h3 id="一、MultiTTS-是什么？"><a href="#一、MultiTTS-是什么？" class="headerlink" title="一、MultiTTS 是什么？"></a>一、MultiTTS 是什么？</h3><p>简单来说，MultiTTS 是一款免费的安卓文本转语音（TTS）工具。你可以把它理解成一个“语音引擎”的空壳，它的强大之处在于可以导入各种第三方的语音包，实现非常丰富和逼真的朗读效果，甚至可以做到离线使用。</p><p>相比手机系统自带的TTS，它的优点很明显：</p><ul><li><strong>音色丰富</strong>：从普通话、方言到外语，各种AI主播的声音几乎都能找到。</li><li><strong>离线使用</strong>：导入离线语音包后，不用联网也能听书，不耗流量。</li><li><strong>高度自定义</strong>：可以调整语速、音量，甚至设置多角色对话朗读。</li></ul><p><img src="https://img.996007.icu/file/1755495306867_image-20250818133453881.png" alt="image-20250818133453881"></p><h3 id="二、手把手教你用-MultiTTS"><a href="#二、手把手教你用-MultiTTS" class="headerlink" title="二、手把手教你用 MultiTTS"></a>二、手把手教你用 MultiTTS</h3><p>第一次使用可能会觉得有点复杂，但跟着步骤走一遍，其实很简单。</p><blockquote><p>下载地址:</p><p>● 百度网盘(订阅有更新提醒)：<br><a href="https://pan.baidu.com/s/1BrdTby1W_zkQBNh0AdELfQ?pwd=0000">https://pan.baidu.com/s/1BrdTby1W_zkQBNh0AdELfQ?pwd=0000</a><br>提取码:0000</p><p>● 城通网盘：<br><a href="https://url85.ctfile.com/d/55370485-63896491-039200?p=1324">https://url85.ctfile.com/d/55370485-63896491-039200?p=1324</a><br>密码：1324</p><p>● 123云盘：<br><a href="https://www.123pan.com/s/6chuVv-yiqWd.html">https://www.123pan.com/s/6chuVv-yiqWd.html</a><br><a href="https://www.123pan.cn/s/6chuVv-yiqWd.html">https://www.123pan.cn/s/6chuVv-yiqWd.html</a></p><p>● 夸克网盘：<br><a href="https://pan.quark.cn/s/c3b5f9152054">https://pan.quark.cn/s/c3b5f9152054</a></p><p>● UC网盘：<br><a href="https://drive.uc.cn/s/742d2cb4b9584?public=1">https://drive.uc.cn/s/742d2cb4b9584?public=1</a></p><p>● 迅雷云盘：<br><a href="https://pan.xunlei.com/s/VOC6fFRhiDVvI7iwOwIy8_TyA1?pwd=dbvm#">https://pan.xunlei.com/s/VOC6fFRhiDVvI7iwOwIy8_TyA1?pwd=dbvm#</a></p></blockquote><p><strong>第一步：安装软件本体</strong></p><p>MultiTTS 本身只是一个引擎框架。首先，你需要安装它的主程序。</p><p><img src="https://img.996007.icu/file/1755495445922_image-20250818133719581.png" alt="image-20250818133719581"></p><p><strong>第二步：下载并导入语音包</strong></p><p>这是最关键的一步。MultiTTS 安装好后是个空壳，没有任何声音，需要我们手动导入“声音数据”，也就是语音包。这些语音包通常是以<code>.zip</code>压缩文件的形式提供的。可以先下载一个试试,然后没有合适的再去下载其他的语音包就可以啦!</p><p><img src="https://img.996007.icu/file/1755495457565_image-20250818133738885.png" alt="image-20250818133738885"></p><p><strong>直接导入（推荐新手使用）</strong>：</p><ul><li>启动 MultiTTS 应用。</li><li>点击界面右上角的三个点按钮，选择“导入数据”。</li><li>在弹出的文件管理器中，找到你下载好的语音包压缩文件（比如 <code>voice.zip</code>），直接选择它。注意，<strong>不需要解压</strong>这个文件。</li><li>导入过程需要一点时间，特别是语音包比较大的时候，耐心等待一下。</li></ul><p><img src="https://img.996007.icu/file/1755495562337_image-20250818133919174.png" alt="image-20250818133919174"></p><p><strong>第三步：设置为系统默认 TTS 引擎</strong></p><p>语音包导入成功后，你会在 MultiTTS 的主界面看到很多语音角色。接下来，将系统TTS引擎修改为这个软件即可。</p><ul><li>同样是点击右上角的三个点，选择“设置TTS”。</li><li>这时会跳转到手机系统的“文字转语音设置”页面。</li><li>在“首选引擎”或类似选项中，选择“MultiTTS”。</li></ul><p><img src="https://img.996007.icu/file/1755495687364_image-20250818134125731.png" alt="image-20250818134125731"></p><p>完成这三步，基础配置就算完成了。</p><h3 id="三、实际使用效果与技巧"><a href="#三、实际使用效果与技巧" class="headerlink" title="三、实际使用效果与技巧"></a>三、实际使用效果与技巧</h3><p>设置好之后，就可以去支持朗读功能的APP（比如各种阅读软件）里体验了。在阅读软件的朗读设置里，把朗读引擎切换为“系统默认TTS”，它就会自动调用 MultiTTS 来为你朗读。</p><p><img src="https://img.996007.icu/file/1755496593587_1755496097896_image-20250818134812478.png" alt="image-20250818134812478"></p><p><strong>我个人比较喜欢的一个功能是“多角色朗读”</strong>。在 MultiTTS 里长按一个语音角色，可以将其设置为“对话合成引擎”。这样一来，朗读小说时，旁白和人物对话就会由不同的声音来朗读，听起来非常有沉浸感，怎么说呢，就是那种听广播剧的感觉。</p><p><strong>对了，还有个细节差点忘了</strong>：为了防止朗读过程中被系统“杀后台”导致中断，最好给 MultiTTS 加上后台运行权限。在应用的设置里，找到“电池优化”选项，允许它后台高耗电运行。</p><p><img src="https://img.996007.icu/file/1755496596748_1755496176784_image-20250818134932122.png" alt="image-20250818134932122"></p><h3 id="五、最后"><a href="#五、最后" class="headerlink" title="五、最后"></a>五、最后</h3><ul><li><strong>局限性</strong>：这个方法目前只适用于安卓系统。另外，语音包的质量参差不齐，需要自己多试试才能找到喜欢的声音。</li><li><strong>替代方案</strong>：如果你觉得手动导入语音包太麻烦，也可以考虑一些集成的听书软件，比如“微信阅读”APP之类的!</li></ul><p>总的来说，MultiTTS 虽然前期配置需要花一点点时间，但一旦配置完成，它带来的听书体验提升是巨大的。从生硬的机器音到媲美真人的多角色朗读，这个转变绝对值得你花时间去尝试一下。当然,软件还有更多强大的功能,就需要自己去探索了, 希望这篇分享对你有帮助！</p>]]></content>
    
    
    <summary type="html">所以，今天就直接上干货，给大家介绍一款能让朗读效果天翻地覆的工具——MultiTTS。它和“阅读”APP组合起来，绝对能让你惊喜。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="工具" scheme="https://www.wangwangit.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="TTS" scheme="https://www.wangwangit.com/tags/TTS/"/>
    
  </entry>
  
  <entry>
    <title>运营商不想让你知道的秘密：超低价套餐办理全指南</title>
    <link href="https://www.wangwangit.com/%E8%BF%90%E8%90%A5%E5%95%86%E4%B8%8D%E6%83%B3%E8%AE%A9%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E7%A7%98%E5%AF%86%EF%BC%9A%E8%B6%85%E4%BD%8E%E4%BB%B7%E5%A5%97%E9%A4%90%E5%8A%9E%E7%90%86%E5%85%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://www.wangwangit.com/%E8%BF%90%E8%90%A5%E5%95%86%E4%B8%8D%E6%83%B3%E8%AE%A9%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E7%A7%98%E5%AF%86%EF%BC%9A%E8%B6%85%E4%BD%8E%E4%BB%B7%E5%A5%97%E9%A4%90%E5%8A%9E%E7%90%86%E5%85%A8%E6%8C%87%E5%8D%97/</id>
    <published>2025-08-23T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.950Z</updated>
    
    <content type="html"><![CDATA[<p>每次看到手机账单，你是不是都有一种“被套路”的感觉？</p><p>几百分钟用不完的通话时长，像是上个时代的标配；而真正当饭吃的流量，却总在月底前就早早告急。我们明明活在靠视频、社交和游戏续命的时代，为什么手机套餐却还停留在过去？</p><p>告诉你一个公开的秘密：<strong>这一切，都是设计好的。</strong></p><p>运营商们陷入了一个自己制造的“怪圈”, 一方面，社会责任让他们必须保留那些几乎不赚钱的低价套餐；但作为生意人，他们又希望我们每个人都花更多的钱。这种矛盾，让他们选择把最划算、最适合“保号”的套餐“雪藏”起来。</p><p>这篇指南，我会先带你撕开信息壁垒，手把手教你办下那个被藏起来的官方保号套餐。还会带你探索各种流量卡,让你转变为一个精明的消费者!</p><p>先说一下我的保号方案吧!我目前采用的是“<strong>保号套餐 + 流量卡</strong>”双卡组合策略.其核心逻辑是：</p><ol><li><strong>主号保号</strong>：将自己长期使用、绑定了银行、微信、支付宝等关键服务的主力手机号，更换为运营商提供的月租最低的官方“保号套餐”。其唯一目的，是以最低成本（通常在每月5至8元）维持号码有效，确保能正常接听电话、接收短信验证码。</li><li><strong>副卡上网</strong>：另外办理一张高性价比的“流量卡”，专门用于满足日常所有的上网需求。这类卡通常提供海量数据流量，而月租远低于三大运营商主营业厅的同等流量套餐。</li></ol><p><img src="https://img.996007.icu/file/1753514674206_20250726152424551.png" alt="image-20250726152424310"></p><p><img src="https://img.996007.icu/file/1753514681503_20250726152434906.png" alt="image-20250726152434650"></p><h2 id="四大运营商保底套餐详细对比"><a href="#四大运营商保底套餐详细对比" class="headerlink" title="四大运营商保底套餐详细对比"></a>四大运营商保底套餐详细对比</h2><table><thead><tr><th>运营商</th><th>套餐名称</th><th>月租</th><th>通话分钟</th><th>流量</th><th>短信</th><th>超出资费</th></tr></thead><tbody><tr><td><strong>中国电信</strong></td><td>5元无忧卡保号套餐</td><td><strong>5元</strong></td><td>0分钟</td><td>200MB</td><td>0条</td><td>通话0.1元&#x2F;分钟<br/>流量阶梯收费</td></tr><tr><td><strong>中国移动</strong></td><td>8元4G飞享套餐</td><td><strong>8元</strong></td><td>30分钟</td><td>10MB+500MB优惠包</td><td>0条</td><td>通话0.25元&#x2F;分钟<br/>流量0.29元&#x2F;MB</td></tr><tr><td><strong>中国联通</strong></td><td>8元流量王套餐</td><td><strong>8元</strong></td><td>30分钟</td><td>200MB</td><td>0条</td><td>通话0.15元&#x2F;分钟<br/>流量0.1元&#x2F;MB</td></tr><tr><td><strong>中国广电</strong></td><td>精彩套餐</td><td><strong>23元</strong></td><td>50分钟</td><td>10GB</td><td>0条</td><td>按套餐规定</td></tr></tbody></table><p><strong>最优选择</strong>：纯保号选电信5元套餐，轻度使用选联通8元套餐，移动老用户选8元飞享套餐配合优惠包。</p><h2 id="保底套餐办理实战攻略"><a href="#保底套餐办理实战攻略" class="headerlink" title="保底套餐办理实战攻略"></a>保底套餐办理实战攻略</h2><h3 id="中国移动8元套餐办理方法"><a href="#中国移动8元套餐办理方法" class="headerlink" title="中国移动8元套餐办理方法"></a>中国移动8元套餐办理方法</h3><p><strong>推荐方法：移动APP在线客服</strong></p><ol><li>打开中国移动APP，找到客服入口</li><li>输入”8元套餐”查询确认存在</li><li>输入”转人工”进入人工客服</li><li><strong>开场白</strong>：直接说”我要办理8元自由选套餐”</li><li>提供6位服务密码验证身份</li><li>选择30分钟通话版（推荐）</li><li>办理成功，次月生效</li></ol><p><strong>备用方法：10086电话客服</strong></p><ul><li>直拨10086转人工</li><li>坚持要求办理，不接受推诿</li></ul><h3 id="中国联通8元套餐办理方法"><a href="#中国联通8元套餐办理方法" class="headerlink" title="中国联通8元套餐办理方法"></a>中国联通8元套餐办理方法</h3><p><strong>微信公众号办理</strong>：</p><ol><li>关注”中国联通客服”微信公众号</li><li>选择在线客服→转人工</li><li>明确要求办理”全国流量王8元套餐”</li><li><strong>特殊要求</strong>：需现场拍摄身份证正反面上传</li><li>按提示完成办理</li></ol><p><strong>备用方法：10010客服</strong></p><ul><li>直拨10086转人工</li><li>坚持要求办理，不接受推诿</li></ul><h3 id="中国电信5元套餐办理方法"><a href="#中国电信5元套餐办理方法" class="headerlink" title="中国电信5元套餐办理方法"></a>中国电信5元套餐办理方法</h3><p><strong>最简单</strong>：直接拨打10000客服，表明办理5元保底套餐需求。电信客服阻挠相对最少。</p><h2 id="办理前必要条件"><a href="#办理前必要条件" class="headerlink" title="办理前必要条件"></a>办理前必要条件</h2><h3 id="必备条件检查清单"><a href="#必备条件检查清单" class="headerlink" title="必备条件检查清单"></a>必备条件检查清单</h3><ul><li><strong>号码状态</strong>：无欠费，账户余额充足</li><li><strong>绑定业务</strong>：未绑定宽带、副卡等业务</li><li><strong>合约状态</strong>：无保底消费合约限制</li><li><strong>服务密码</strong>：准备6位服务密码</li><li><strong>身份证件</strong>：确保信息准确无误</li></ul><h3 id="办理失败的主要原因"><a href="#办理失败的主要原因" class="headerlink" title="办理失败的主要原因"></a>办理失败的主要原因</h3><ol><li><strong>合约限制</strong>：有保底消费合约未到期</li><li><strong>绑定业务</strong>：宽带、副卡等绑定业务</li><li><strong>欠费状态</strong>：账户有未结清费用</li><li><strong>地区限制</strong>：部分地区政策收紧</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>通常,我们去联系客服更改套餐时,客服可能会做一些阻挠,只要坚持态度,一般都是能正常办理成功的! <strong>正常业务办理可以态度坚决一些,另外不推荐大家以这种方式去获取一些不符合规则的流量套餐之类的!</strong></p><table><thead><tr><th>客服话术</th><th>应对方法</th></tr></thead><tbody><tr><td>“套餐已下架，无法办理”</td><td>“请帮我查询确认，我看APP上还有这个套餐”</td></tr><tr><td>“18元以下需要营业厅办理”</td><td>“为什么之前可以在线办理？我记录客服工号准备投诉”</td></tr><tr><td>“系统升级，暂时无法办理”</td><td>“请明确回答能或不能，我已录音并准备投诉工信部”</td></tr><tr><td>“需要老年证&#x2F;贫困证明”</td><td>“工信部未规定需要额外证件，这是违规要求”</td></tr></tbody></table><p>最后,实在没有办法,可以前往工信部进行投诉,这是我们的正常权益!</p><p><strong>投诉步骤</strong>：</p><ol><li>访问工信部投诉网站：yhssglxt.miit.gov.cn</li><li>投诉类型选择：”限制办理业务”</li><li>投诉内容：”运营商拒绝办理8元套餐，限制用户选择权”</li><li>等待运营商主动联系处理</li></ol><h2 id="如何选择流量卡"><a href="#如何选择流量卡" class="headerlink" title="如何选择流量卡?"></a>如何选择流量卡?</h2><p>很多人担心这些流量卡会跑路,实际上,抖音,淘宝等平台的号卡都是这种,也会有物联网卡类似的,下面给大家介绍一下两者的区别!</p><h3 id="物联网卡"><a href="#物联网卡" class="headerlink" title="物联网卡"></a>物联网卡</h3><p>在所有风险中，最需要警惕的是买到被违规销售的“物联网卡”（IoT卡）。</p><ul><li><strong>本质区别</strong>：物联网卡是运营商为企业用户设计的，用于连接物联网设备（如共享单车、智能电表、POS机等），而非个人手机。工信部明令禁止向个人用户销售物联网卡，也禁止个人用户在手机上使用 。</li><li><strong>灰色产业</strong>：一些不法商家通过非正规渠道套取企业用的物联网卡，包装成“流量卡”卖给个人用户，形成了灰色产业链 。</li><li><strong>巨大风险</strong>：使用物联网卡的风险极高。首先，卡的所有权不在您名下，您的权益无法得到保障。其次，代理商随时可能“跑路”，您充值的钱款和未使用的流量将血本无归。最重要的是，运营商一旦检测到物联网卡被用于个人手机，有权（且被要求）随时封停该卡，届时您将面临突然断网的窘境，且难以维权 。</li></ul><h3 id="流量卡"><a href="#流量卡" class="headerlink" title="流量卡"></a>流量卡</h3><p>一个典型的流量卡分销价值链条如下：</p><ol><li><strong>运营商</strong>：设计基础的促销资费方案。</li><li><strong>省级&#x2F;市级总代理</strong>：与运营商签约，批量获取号卡资源。</li><li><strong>分销平台（如172号卡）</strong>：与总代理合作，将号卡产品上架至平台，并提供技术支持和佣金结算。</li></ol><blockquote><p>流量卡一般都是有一年两年的优惠价格,到期后会恢复原价,当然,也有长期优惠的,这个看个人选择,比我们日常在营业厅办理的套餐肯定是优惠很多的!</p></blockquote><p><img src="https://img.996007.icu/file/1753516090759_20250726154806766.png" alt="image-20250726154806523"></p><h3 id="流量卡分销平台运作模式"><a href="#流量卡分销平台运作模式" class="headerlink" title="流量卡分销平台运作模式"></a>流量卡分销平台运作模式</h3><p><strong>172号卡平台核心模式</strong>：</p><ul><li><strong>规模</strong>：下单用户已超5000万</li><li><strong>佣金机制</strong>：”秒返+月返”复合结算，首充返现80-180元</li><li><strong>层级体系</strong>：金钻、黑钻、一级、二级代理等多级分销</li><li><strong>结算方式</strong>：平台自动分佣，抽取6%税费</li></ul><p><strong>其他主流平台对比</strong>：</p><ul><li><strong>卡博世</strong>：注册需299元代理费，5天提取佣金</li><li><strong>感叹号平台</strong>：C2C模式，风险较高</li><li><strong>秒返、号易等</strong>：数百个大小平台并存</li></ul><h3 id="流量卡选择的风险与防范"><a href="#流量卡选择的风险与防范" class="headerlink" title="流量卡选择的风险与防范"></a>流量卡选择的风险与防范</h3><p><strong>主要骗局类型</strong>：</p><ol><li><strong>货不对板</strong>：用便宜卡吸引下单，推销高价产品</li><li><strong>信息诈骗</strong>：骗取身份信息申请合约产品</li><li><strong>返费陷阱</strong>：承诺补贴需主动申请，经常”忘记”</li><li><strong>虚假宣传</strong>：物联卡冒充流量卡，无法正常使用</li><li><strong>商家跑路</strong>：收费后直接失联</li></ol><p><strong>用户防范建议</strong>：</p><ul><li>选择正规平台，避免无备案小平台</li><li>仔细阅读协议期、违约金等条款</li><li>核实归属地，避免异地办理麻烦</li><li>保留购买记录等维权证据</li><li>可向工信部12381或12315投诉</li></ul><h2 id="最佳省钱方案推荐"><a href="#最佳省钱方案推荐" class="headerlink" title="最佳省钱方案推荐"></a>最佳省钱方案推荐</h2><h3 id="方案一：保底套餐-流量卡组合"><a href="#方案一：保底套餐-流量卡组合" class="headerlink" title="方案一：保底套餐+流量卡组合"></a>方案一：保底套餐+流量卡组合</h3><ul><li><strong>主卡</strong>：电信5元保底套餐（保号）</li><li><strong>副卡</strong>：19元大流量卡（185G流量）</li><li><strong>总费用</strong>：24元&#x2F;月，年省费用2000+元</li></ul><h3 id="方案二：单独保底套餐-活动流量"><a href="#方案二：单独保底套餐-活动流量" class="headerlink" title="方案二：单独保底套餐+活动流量"></a>方案二：单独保底套餐+活动流量</h3><ul><li><strong>选择</strong>：联通8元套餐+官方APP流量活动</li><li><strong>优势</strong>：操作简单，风险较低</li><li><strong>费用</strong>：约15-25元&#x2F;月</li></ul><h3 id="方案三：移动用户专属"><a href="#方案三：移动用户专属" class="headerlink" title="方案三：移动用户专属"></a>方案三：移动用户专属</h3><ul><li><strong>套餐</strong>：移动8元飞享+6元流量优惠包</li><li><strong>流量扩容</strong>：签到领流量、咪咕赠送等</li><li><strong>总费用</strong>：14元&#x2F;月+额外福利</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>有需要172平台邀请码的,可以给公众号留言,我看到后会回复,或者有需要办卡的,可以去这里看一下!</p><p><img src="https://img.996007.icu/file/1753516175199_20250726154925268.png" alt="image-20250726154925111"></p>]]></content>
    
    
    <summary type="html">这篇指南，我会先带你撕开信息壁垒，手把手教你办下那个被藏起来的官方保号套餐。还会带你探索各种流量卡,让你转变为一个精明的消费者!</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="手机卡" scheme="https://www.wangwangit.com/tags/%E6%89%8B%E6%9C%BA%E5%8D%A1/"/>
    
    <category term="低价套餐" scheme="https://www.wangwangit.com/tags/%E4%BD%8E%E4%BB%B7%E5%A5%97%E9%A4%90/"/>
    
  </entry>
  
  <entry>
    <title>求你了，买东西前先搜一下，能省下一顿火锅钱</title>
    <link href="https://www.wangwangit.com/%E6%B1%82%E4%BD%A0%E4%BA%86%EF%BC%8C%E4%B9%B0%E4%B8%9C%E8%A5%BF%E5%89%8D%E5%85%88%E6%90%9C%E4%B8%80%E4%B8%8B%EF%BC%8C%E8%83%BD%E7%9C%81%E4%B8%8B%E4%B8%80%E9%A1%BF%E7%81%AB%E9%94%85%E9%92%B1/"/>
    <id>https://www.wangwangit.com/%E6%B1%82%E4%BD%A0%E4%BA%86%EF%BC%8C%E4%B9%B0%E4%B8%9C%E8%A5%BF%E5%89%8D%E5%85%88%E6%90%9C%E4%B8%80%E4%B8%8B%EF%BC%8C%E8%83%BD%E7%9C%81%E4%B8%8B%E4%B8%80%E9%A1%BF%E7%81%AB%E9%94%85%E9%92%B1/</id>
    <published>2025-08-21T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.948Z</updated>
    
    <content type="html"><![CDATA[<p>哥们，我先摊牌了。</p><p>我现在买东西，几乎都能有优惠价。</p><p>不是我抠，是真的肉疼。上个月，我原价买了双鞋，399。两天后，我一哥们儿也买了，他花了多少？100出头。</p><p>我当时就炸了，直接微信电话轰炸他：“你丫是不是有内部渠道？！”</p><p>他悠悠地回了我一句：“渠道个屁，你不会用返利啊？”</p><p>那一刻，我感觉我过去二十多年网购，花的钱都跟大风刮来的一样。</p><blockquote><p>下面是我京东试用中奖领到的一台空调,有兴趣的也可以去了解一下京东试用!</p></blockquote><p><img src="https://img.996007.icu/file/1753857624530_image-20250730144020001.png" alt="image-20250730144020001"></p><p>今天，我就给你讲讲“羊毛党”背后的秘密，让你也感受一下，每次下单都能省钱的快乐。</p><h3 id="这优惠到底哪来的？合法吗？"><a href="#这优惠到底哪来的？合法吗？" class="headerlink" title="这优惠到底哪来的？合法吗？"></a>这优惠到底哪来的？合法吗？</h3><p>我知道你第一个问题肯定是这个：“这玩意儿靠谱吗？别是骗人的吧？”</p><p>我一开始也这么想。总觉得是占了平台便宜，心里发虚。</p><p>后来我那哥们儿给我画了个图，我秒懂了：</p><p><strong>商家（比如卖鞋的那个店） → 想多卖货 → 找人推广（比如我哥们儿）→ 推广成功了 → 商家给推广的人发佣金 → 我哥们儿把佣金分我一点，拉我下次还找他。</strong></p><p>看明白没？</p><p>你收到的那点“返利”，就是推广的人，从商家给的广告费里，分给你的“辛苦费”。</p><p>这事儿对三方都有好处：</p><ul><li><strong>商家</strong>：卖出货才给钱，不亏。</li><li><strong>推广的人</strong>：赚了点零花钱。</li><li><strong>咱</strong>：实打实地省钱了。</li></ul><p>所以，这不是什么见不得人的事儿，是淘宝、京东官方都点头认可的正规玩法。咱不是在钻空子，是在理直气壮地拿回本该属于消费者的福利。</p><h3 id="我能自己推广么"><a href="#我能自己推广么" class="headerlink" title="我能自己推广么?"></a>我能自己推广么?</h3><p>市面上一堆返利APP，名字五花八门，其实说白了就下面几种，你按需取用就行。<br><strong>第一种：官方推广，安全可靠</strong></p><p>各大电商平台都拥有自己的官方推广平台，这是整个生态的源头。有网站也有APP,可以自行搜索下载!官方的返利都是有等级制度的,可以自行与第三方平台对比一下返利,因为这里第三方一般是按最高级别获取的返利!</p><p><strong>淘宝: 淘宝联盟</strong></p><blockquote><p>地址: <a href="https://aff-open.taobao.com/">https://aff-open.taobao.com</a></p></blockquote><p><img src="https://img.996007.icu/file/1753856668516_image-20250730142423573.png" alt="image-20250730142423573"></p><p><strong>京东: 京粉</strong></p><p><img src="https://img.996007.icu/file/1753860524658_image-20250730152836042.png" alt="image-20250730152836042"></p><p><strong>拼多多: 多多进宝</strong></p><p><img src="https://img.996007.icu/file/1753856705825_image-20250730142501827.png" alt="image-20250730142501827"></p><p><strong>第二种：懒人必备，主打一个“方便”</strong><br>（比如什么蜜源、一淘、返利网……名字不重要，逻辑都一样）</p><p>这就是我现在的日常主力。操作简单到发指：</p><blockquote><p><strong>淘宝看中东西 → 复制标题&#x2F;链接 → 打开这类APP → 自动弹出优惠券和返利 → 点一下跳回淘宝下单。</strong></p></blockquote><p><img src="https://img.996007.icu/file/1753856622628_image-20250730142338235.png" alt="image-20250730142338235"></p><p>完事儿。</p><p>**优点：**傻瓜式操作，一个APP能搜淘宝、京东、拼多多甚至美团饿了么，简直是省钱界的“万能钥匙”。<br>**缺点：**它作为“二道贩子”，会抽一点点佣金。比如商家给了10块推广费，它可能给你8块，自己留2块。</p><p>但讲真，为了这份方便，让它赚两块，我认了。</p><p><strong>第二种：买大件、做研究必备，主打一个“专业”</strong><br>（我就直说吧，就是“什么值得买”，人称张大妈）</p><p>这家伙跟上面那些完全不是一个路子。</p><p>你什么时候用它？<strong>当你要买个贵的东西，又怕买错的时候。</strong></p><p>比如你要买手机、买冰箱、买车，你上去一搜，铺天盖地的真实用户评测(<strong>曾经</strong>)、长文分析、优缺点对比，能把你从小白直接武装成半个专家。实际上每个平台刚开始出来的时候,都比较真诚,没有那么多套路,现在<strong>张大妈里面也各种刷好评,商家套路了,需要自己分辨!</strong></p><p>它帮你省的，不只是钱，更是买回来就后悔的“沉没成本”。</p><p><strong>我的建议，简单粗暴：</strong></p><ul><li><strong>日常买小东西，用第一种，无脑省钱。</strong></li><li><strong>要花大钱了，先去“什么值得买”泡一天，看看别人怎么说，再决定买不买，怎么买。</strong></li></ul><p>为了更清晰地对比，下表总结了三大主流返利平台的模式：</p><table><thead><tr><th>平台</th><th>核心模式</th><th>主要优点</th><th>主要缺点</th><th>适合人群</th></tr></thead><tbody><tr><td>**淘宝联盟&#x2F;京粉 **</td><td>官方CPS直连</td><td>佣金比例最高，无中间商</td><td>操作复杂，对普通用户不友好</td><td>专业的推广者，有技术能力的资深玩家</td></tr><tr><td>**返利网&#x2F;蜜源 **</td><td>第三方API聚合</td><td>操作简单，一站式覆盖多平台</td><td>佣金被中间商抽成，返利非最高</td><td>追求方便快捷的普通购物者</td></tr><tr><td>**什么值得买 **</td><td>内容驱动+CPS</td><td>专业评测和导购，避免踩坑</td><td>返利并非核心，需要主动搜索</td><td>做购物研究，购买高价值或不熟悉品类的消费者</td></tr></tbody></table><h3 id="返利群是咋实现的"><a href="#返利群是咋实现的" class="headerlink" title="返利群是咋实现的?"></a>返利群是咋实现的?</h3><p>这里就需要大家去看看我公众号<code>一只会飞的旺旺</code>前段时间写的微信机器人的文章了!</p><p><img src="https://img.996007.icu/file/1753857401111_image-20250730143634300.png" alt="image-20250730143634300"></p><p>你可能正在某个“XX好物分享”、“XX妈咪内买”、“XX内部优惠”的群里待着。群主每天不知疲倦地发着各种带链接的商品，从十几块的垃圾袋到几千块的手机，号称都是“神价”。</p><p>说白了，<strong>群主就是个“人工选品机”+“推广员”</strong>。</p><p>他干的活，就是把咱们用返利APP要做的“搜索”那一步，替你干了。他会花大量时间在各种渠道里找那些折扣力度大、佣金高的商品，然后把链接转换成他自己的推广链接，再一股脑地扔进群里。</p><p>群里只要有任何一个人，通过他发的链接买了东西，这笔佣金就归群主所有。他一个人，赚整个群的钱。</p><p><strong>那为啥有人愿意待在群里，而不是自己搜？</strong></p><p>一个字：<strong>懒</strong>。而且，群里偶尔真的会冒出一些 <strong>“神车”</strong>。</p><p>啥叫“神车”？就是商家因为各种原因（比如价格设置错误、优惠券力度太大、或者为了冲销量亏本赚吆喝），搞出来的限时、限量的超低价商品。比如一件衣服标价199，结果弹出张180的券，你10几块就到手了。</p><p>这种好事，手快有，手慢无。而群主这种“职业选手”，往往是消息最灵通的，能第一时间发现并分享出来。所以，很多人待在群里，就是为了等这种可遇不可求的“捡漏”机会。</p><p>但说实话，<strong>这种“神车”一年也碰不到几次。群里99%的内容，还是那些常规的、咱们自己用APP也能搜到的返利商品。</strong> 群主只是把它们筛选打包，喂到你嘴边而已。</p><blockquote><p>针对商家误操作之类的优惠价格,还是希望大家手下留情,毕竟做生意也不容易!薅羊毛也得有道德是不!</p></blockquote><h3 id="最重要的来了！千万别让“省钱”变成“被骗”！"><a href="#最重要的来了！千万别让“省钱”变成“被骗”！" class="headerlink" title="最重要的来了！千万别让“省钱”变成“被骗”！"></a>最重要的来了！千万别让“省钱”变成“被骗”！</h3><p>朋友，前面说的都是怎么捡钱，现在我要跟你说的，是怎么保命。</p><p><strong>你一定，一定，一定听过“刷单”吧？</strong></p><p>我发誓，这是我见过最蠢、也最狠的骗局。它就是蹭了“返利”这个词的热度，来骗你钱的。</p><p><strong>求你了，人间清醒一点！天上不会掉馅饼，只会掉铁饼！</strong></p><p>骗子的套路，我都能背下来了：</p><ol><li>用“日赚800”、“点赞赚钱”的短信当诱饵。</li><li>让你下载个来路不明的APP，先给你个100块的小单子，刷完，立马返你105。</li><li>你信了。然后告诉你，有个“组合任务”，要刷满5000块，才能一次性返你6000。</li><li>你东拼西凑投了5000进去。然后……就没有然后了。对方会用“系统卡单”、“账户冻结”各种理由，让你继续投钱，直到把你骨髓都榨干。</li></ol><p>每年都有人因为这个家破人亡，新闻都报烂了。</p><p><strong>怎么分辨？我给你一个100%管用的方法，记住这条铁律，能保住你的钱包：</strong></p><blockquote><p><strong>咱玩的购物返利，从头到尾，钱都是付给淘宝、京东的官方订单。</strong></p><p><strong>骗子玩的刷单，第一步就是要你“垫付”！让你把钱转给他们！</strong></p></blockquote><p><strong>一句话总结：</strong></p><h3 id="凡是要你先掏钱垫付的，全是诈骗！一个字都别信！"><a href="#凡是要你先掏钱垫付的，全是诈骗！一个字都别信！" class="headerlink" title="凡是要你先掏钱垫付的，全是诈骗！一个字都别信！"></a><strong>凡是要你先掏钱垫付的，全是诈骗！一个字都别信！</strong></h3><p>咱们是在规则里<strong>省钱</strong>，不是在规则外<strong>送钱</strong>。</p><p>还有，如果一个APP，不教你怎么买东西省钱，天天催你“交99块升级”、“拉人头拿提成”，你也赶紧跑，那是传销的坑。</p><p>好了，掏心窝子的话就说这么多了。</p><p>这门省钱手艺，说难不难，说简单，也得你亲自试试。</p><p>秘籍交给你了，下次买东西前，花个10秒钟搜一下，省下的钱，给自己加个鸡腿，不香吗？</p><p>如果觉得这篇文章帮助到你了,请动动小手,一键三连一下!!</p>]]></content>
    
    
    <summary type="html">今天，我就给你讲讲“羊毛党”背后的秘密，让你也感受一下，每次下单都能省钱的快乐。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="购物" scheme="https://www.wangwangit.com/tags/%E8%B4%AD%E7%89%A9/"/>
    
    <category term="羊毛" scheme="https://www.wangwangit.com/tags/%E7%BE%8A%E6%AF%9B/"/>
    
  </entry>
  
  <entry>
    <title>人人都能看懂的HTTP学习笔记</title>
    <link href="https://www.wangwangit.com/HTTP%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.wangwangit.com/HTTP%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-07-25T09:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP的基本概念"><a href="#HTTP的基本概念" class="headerlink" title="HTTP的基本概念"></a>HTTP的基本概念</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">  %% 配色和样式</span><br><span class="line">  classDef title fill:#6366f1,stroke:#1e3a8a,color:#fff,stroke-width:2px;</span><br><span class="line">  classDef group fill:#c7d2fe,stroke:#4f46e5,stroke-width:1px;</span><br><span class="line">  classDef detail fill:#eff6ff,stroke:#60a5fa,stroke-width:1px,color:#111827;</span><br><span class="line"></span><br><span class="line">  %% 节点定义</span><br><span class="line">  A[&quot;📘 章1: Web与网络基础&quot;]:::title</span><br><span class="line"></span><br><span class="line">  A --&gt; B[&quot;🧱 网络基石：TCP/IP 协议族&quot;]:::group</span><br><span class="line">  B --&gt; B1[&quot;📐 分层管理&quot;]:::group</span><br><span class="line">  B1 --&gt; B1a[&quot;🌐 应用层 (HTTP, DNS, FTP...)&quot;]:::detail</span><br><span class="line">  B1 --&gt; B1b[&quot;📦 传输层 (TCP, UDP)&quot;]:::detail</span><br><span class="line">  B1 --&gt; B1c[&quot;🛰️ 网络层 (IP, ARP)&quot;]:::detail</span><br><span class="line">  B1 --&gt; B1d[&quot;🧩 链路层 (驱动, 网卡)&quot;]:::detail</span><br><span class="line">  B --&gt; B2[&quot;🔁 通信流程&quot;]:::group</span><br><span class="line">  B2 --&gt; B2a[&quot;📤 封装（从上到下加头）&quot;]:::detail</span><br><span class="line">  B2 --&gt; B2b[&quot;📥 解封装（从下到上拆头）&quot;]:::detail</span><br><span class="line"></span><br><span class="line">  A --&gt; C[&quot;🤝 HTTP 的三大协作伙伴&quot;]:::group</span><br><span class="line">  C --&gt; C1[&quot;📍 IP：负责寻址和路由&quot;]:::detail</span><br><span class="line">  C --&gt; C2[&quot;🔐 TCP：可靠传输（三次握手）&quot;]:::detail</span><br><span class="line">  C --&gt; C3[&quot;🔎 DNS：域名到 IP 的解析&quot;]:::detail</span><br><span class="line"></span><br><span class="line">  A --&gt; D[&quot;🗺️ Web 资源定位&quot;]:::group</span><br><span class="line">  D --&gt; D1[&quot;🆔 URI vs URL&quot;]:::group</span><br><span class="line">  D1 --&gt; D1a[&quot;📎 URI（标识符）是父集&quot;]:::detail</span><br><span class="line">  D1 --&gt; D1b[&quot;📍 URL（定位符）是子集&quot;]:::detail</span><br><span class="line">  D --&gt; D2[&quot;📑 URL 格式&quot;]:::group</span><br><span class="line">  D2 --&gt; D2a[&quot;scheme://user:pass@host:port/path?query#fragment&quot;]:::detail</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="HTTP请求-响应流程图"><a href="#HTTP请求-响应流程图" class="headerlink" title="HTTP请求-响应流程图"></a>HTTP请求-响应流程图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant User as 👤 用户</span><br><span class="line">    participant Browser as 🧭 浏览器 (客户端)</span><br><span class="line">    participant DNS as 🌐 DNS服务器</span><br><span class="line">    participant Server as 🖥️ 服务器</span><br><span class="line"></span><br><span class="line">    User-&gt;&gt;Browser: 输入 www.example.com&lt;br&gt;并回车</span><br><span class="line">    Browser-&gt;&gt;DNS: 查询域名 IP</span><br><span class="line">    DNS--&gt;&gt;Browser: 返回 IP 地址</span><br><span class="line">    Browser-&gt;&gt;Server: 建立TCP连接</span><br><span class="line">    Browser-&gt;&gt;Server: 发送 HTTP 请求&lt;br&gt;(GET / HTTP/1.1)</span><br><span class="line">    Note over Server: 服务器处理请求，查找资源</span><br><span class="line">    Server--&gt;&gt;Browser: 返回 HTTP 响应&lt;br&gt;(200 OK, HTML)</span><br><span class="line">    Browser-&gt;&gt;User: 解析 HTML&lt;br&gt;渲染页面并显示</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生活案例"><a href="#生活案例" class="headerlink" title="生活案例"></a>生活案例</h3><p>把HTTP通信想象成你去一家图书馆借书。</p><ul><li><strong>你（客户端）</strong> 想借一本书（资源）。</li><li>你知道书的准确位置（URL），比如“三楼社科区A-18架第3排”。</li><li>你填写一张借书单（<strong>HTTP请求</strong>）并交给图书管理员（<strong>服务器</strong>）。</li><li>图书管理员根据单子找到书，连同借阅凭证一起给你（<strong>HTTP响应</strong>）。</li><li>如果书不在或者你没借书证，他会告诉你“没找到”（404）或“请出示证件”（401）。</li></ul><h3 id="真实案例"><a href="#真实案例" class="headerlink" title="真实案例"></a>真实案例</h3><p>在一个电商网站中，当你点击“我的订单”时：</p><ol><li>你的浏览器（前端应用，如Vue&#x2F;React）会发起一个HTTP GET 请求，URL可能是 <a href="https://api.ecommerce.com/orders?user_id=123%E3%80%82">https://api.ecommerce.com/orders?user_id=123。</a></li><li>这个请求通过互联网发送到电商的后端API服务器。</li><li>服务器验证你的身份，然后去数据库查询用户123的所有订单信息。</li><li>服务器将订单信息打包成一个JSON格式的字符串，放入HTTP响应体中，并返回给你的浏览器。</li><li>浏览器接收到JSON数据后，动态地将订单列表渲染到页面上。</li></ol><p>在这个案例中，HTTP扮演了前后端数据通信的“信使”角色。</p><h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>问题: 当你在浏览器地址栏里输入一个URL，然后按下回车，直到你看到页面，这中间发生了什么？</p></blockquote><p><strong>1. 应用层 - URL解析与HTTP请求构建：</strong></p><ul><li>浏览器首先会解析我输入的URL，识别出协议（HTTP&#x2F;HTTPS）、域名、端口、路径等信息。</li><li>它会构建一个HTTP请求报文，最核心的是请求行，比如 GET &#x2F;index.html HTTP&#x2F;1.1，以及包含Host在内的各种请求头。</li></ul><p><strong>2. 应用层 - DNS解析：</strong></p><ul><li>浏览器需要将URL中的域名（比如 <a href="http://www.example.com)解析成服务器的ip地址./">www.example.com）解析成服务器的IP地址。</a></li><li>它会依次查询：浏览器缓存 -&gt; 操作系统缓存 -&gt; 本地Hosts文件 -&gt; 本地DNS服务器。如果都找不到，本地DNS服务器会向根DNS服务器发起递归查询，最终找到目标IP地址。</li></ul><p><strong>3. 传输层 - TCP连接（三次握手）：</strong></p><ul><li>知道了服务器IP和端口（HTTP默认80，HTTPS默认443）后，浏览器会通过TCP协议与服务器建立连接。</li><li>这个过程就是著名的“三次握手”：客户端发送SYN包，服务器回复SYN+ACK包，客户端再回复ACK包，连接建立。如果是HTTPS，这里还会进行TLS握手。</li></ul><p><strong>4. 网络层 - IP寻址与路由：</strong></p><ul><li>TCP将HTTP请求报文分割成TCP报文段，并打包成IP数据包。通过IP寻址和路由器一跳一跳的转发，最终将数据包发送到目标服务器。</li></ul><p><strong>5. 服务器处理请求：</strong></p><ul><li>服务器接收到请求后，Web服务器（如Nginx）会进行处理，可能会将请求转发给后端的业务逻辑（如Node.js, Tomcat）。</li><li>后端应用处理请求，可能涉及数据库查询等操作，然后生成一个HTTP响应报文。</li></ul><p><strong>6. 返回响应与浏览器渲染：</strong></p><ul><li>服务器将HTTP响应报文（包含状态码200 OK和HTML页面内容）通过TCP连接发回给浏览器。</li><li>浏览器接收到响应后，开始解析HTML，构建DOM树。同时，如果HTML中包含CSS、JavaScript、图片等外部资源，浏览器会重复上述过程为每个资源发起新的HTTP请求。</li><li>最终，浏览器将DOM树、CSSOM树结合，进行布局（Layout）和绘制（Paint），将完整的页面呈现给我。</li></ul><p><strong>7. 连接关闭（四次挥手）：</strong></p><ul><li>在HTTP&#x2F;1.1的持久连接下，TCP连接可能不会立即关闭，以便复用。但最终会通过“四次挥手”来断开连接。</li></ul><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><ul><li>流程中的位置：DNS解析阶段</li></ul><ul><li><strong>核心概念：</strong> CDN（Content Delivery Network，内容分发网络）本质上是一个<strong>分布式的缓存系统</strong>。它将网站的静态资源（如图片、CSS、JavaScript文件，甚至部分动态内容）缓存到全球各地、靠近用户的“边缘节点”（Edge Node）上。</li><li><strong>解决的问题：</strong> <strong>物理延迟</strong>。如果你的服务器在纽约，上海的用户访问它，数据来回需要跨越太平洋，光速的限制是无法逾越的。CDN通过让用户访问离他最近的节点来获取资源，极大地缩短了物理距离，从而降低延迟。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant User as 👤 用户&lt;br&gt;(上海)</span><br><span class="line">    participant SmartDNS as 🌐 智能DNS&lt;br&gt;(CDN)</span><br><span class="line">    participant CdnNode as 🏢 CDN边缘节点&lt;br&gt;(香港)</span><br><span class="line">    participant OriginServer as 🖥️ 源服务器&lt;br&gt;(纽约)</span><br><span class="line"></span><br><span class="line">    User-&gt;&gt;SmartDNS: DNS查询&lt;br&gt;www.example.com</span><br><span class="line">    Note over SmartDNS: 检测到用户来自上海&lt;br&gt;（基于IP地理定位）</span><br><span class="line">    SmartDNS--&gt;&gt;User: 返回IP&lt;br&gt;香港CDN节点IP地址</span><br><span class="line"></span><br><span class="line">    User-&gt;&gt;CdnNode: HTTP请求&lt;br&gt;访问资源</span><br><span class="line">    alt 缓存命中 (Cache Hit)</span><br><span class="line">        CdnNode--&gt;&gt;User: 直接返回&lt;br&gt;缓存资源</span><br><span class="line">    else 缓存未命中 (Cache Miss)</span><br><span class="line">        CdnNode-&gt;&gt;OriginServer: 回源请求资源</span><br><span class="line">        OriginServer--&gt;&gt;CdnNode: 返回资源</span><br><span class="line">        Note over CdnNode: 缓存资源&lt;br&gt;并返回给用户</span><br><span class="line">        CdnNode--&gt;&gt;User: 返回资源</span><br><span class="line">    end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul><li>流程中的位置：TCP连接建立阶段</li></ul><ul><li><strong>核心概念：</strong> 负载均衡器是服务器集群的“交通警察”。当大量请求涌入时，它会将这些请求根据预设的策略（如轮询、最少连接数、IP哈希）分发到后方的多台Web服务器上。</li><li><strong>解决的问题：</strong> <strong>单点瓶颈和可扩展性</strong>。单个服务器的处理能力是有限的，无法应对高并发场景。负载均衡能将压力均分，使得系统可以通过简单地增加服务器数量（水平扩展）来提升整体处理能力。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    %% 样式定义</span><br><span class="line">    classDef req fill:#fee2e2,stroke:#ef4444,stroke-width:2px,color:#b91c1c;</span><br><span class="line">    classDef lb fill:#fef9c3,stroke:#eab308,stroke-width:2px,color:#a16207;</span><br><span class="line">    classDef server fill:#e0f2fe,stroke:#2563eb,stroke-width:2px,color:#0c4a6e;</span><br><span class="line">    classDef serverN fill:#f3f4f6,stroke:#9ca3af,stroke-dasharray:5 3,color:#6b7280;</span><br><span class="line"></span><br><span class="line">    %% 节点定义</span><br><span class="line">    Request(&quot;🌐 来自CDN/用户的&lt;br&gt;HTTP请求&quot;):::req</span><br><span class="line">    LB(&quot;🎛️ 负载均衡器&quot;):::lb</span><br><span class="line">    Server1(&quot;🖥️ Web服务器 1&quot;):::server</span><br><span class="line">    Server2(&quot;🖥️ Web服务器 2&quot;):::server</span><br><span class="line">    Server3(&quot;🖥️ Web服务器 3&quot;):::server</span><br><span class="line">    ServerN(&quot;🖥️ Web服务器 N&quot;):::serverN</span><br><span class="line"></span><br><span class="line">    %% 分组</span><br><span class="line">    subgraph 数据中心</span><br><span class="line">        LB</span><br><span class="line">        Server1</span><br><span class="line">        Server2</span><br><span class="line">        Server3</span><br><span class="line">        ServerN</span><br><span class="line">        LB --&gt;|分发策略| Server1</span><br><span class="line">        LB --&gt;|分发策略| Server2</span><br><span class="line">        LB --&gt;|分发策略| Server3</span><br><span class="line">        LB --&gt;|分发策略| ServerN</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    Request --&gt; LB</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="HTTP-2多路复用"><a href="#HTTP-2多路复用" class="headerlink" title="HTTP&#x2F;2多路复用"></a>HTTP&#x2F;2多路复用</h3><ul><li>流程中的位置：浏览器获取页面资源阶段</li><li><strong>核心概念：</strong> HTTP&#x2F;1.1存在“队头阻塞”（Head-of-Line Blocking）问题。虽然浏览器可以开多个TCP连接（通常6-8个），但每个连接同一时间只能处理一个请求-响应。而HTTP&#x2F;2的<strong>多路复用</strong>（Multiplexing）允许在<strong>单个TCP连接</strong>上同时发送和接收多个请求和响应，它们被分解成更小的帧，可以并行、交错地传输。</li><li><strong>解决的问题：</strong> <strong>网络传输效率</strong>。它消除了队头阻塞，减少了TCP连接建立的开销，使得页面资源加载速度更快。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    %% 样式</span><br><span class="line">    classDef http1 fill:#fee2e2,stroke:#ef4444,color:#b91c1c,stroke-width:2px;</span><br><span class="line">    classDef http2 fill:#d1fae5,stroke:#10b981,color:#065f46,stroke-width:2px;</span><br><span class="line">    classDef req fill:#fef9c3,stroke:#eab308,color:#b45309;</span><br><span class="line">    classDef stream fill:#e0e7ff,stroke:#6366f1,color:#312e81;</span><br><span class="line">    classDef compare fill:#f3f4f6,stroke:#a3a3a3,color:#111827,stroke-dasharray:5 3;</span><br><span class="line">    </span><br><span class="line">    %% HTTP/1.1</span><br><span class="line">    subgraph HTTP1[&quot;🌐 HTTP/1.1 (多连接, 队头阻塞)&quot;]</span><br><span class="line">        direction LR</span><br><span class="line">        TCP1(&quot;🔗 TCP连接1&quot;):::http1 --&gt; R1(&quot;📄 请求1&quot;):::req --&gt; R2(&quot;📄 请求2&quot;):::req</span><br><span class="line">        TCP2(&quot;🔗 TCP连接2&quot;):::http1 --&gt; R3(&quot;📄 请求3&quot;):::req --&gt; R4(&quot;📄 请求4&quot;):::req</span><br><span class="line">        TCP3(&quot;🔗 TCP连接3&quot;):::http1 --&gt; R5(&quot;📄 请求5&quot;):::req --&gt; R6(&quot;📄 请求6&quot;):::req</span><br><span class="line">        classDef HTTP1 fill:#fee2e2,stroke:#ef4444,stroke-width:2px;</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    %% HTTP/2</span><br><span class="line">    subgraph HTTP2[&quot;🚀 HTTP/2 (单连接, 多路复用)&quot;]</span><br><span class="line">        direction LR</span><br><span class="line">        subgraph &quot;🔗 一个TCP连接&quot;</span><br><span class="line">            direction TB</span><br><span class="line">            S1(&quot;🔀 流1: 请求HTML&quot;):::stream</span><br><span class="line">            S2(&quot;🔀 流2: 请求CSS&quot;):::stream</span><br><span class="line">            S3(&quot;🔀 流3: 请求JS&quot;):::stream</span><br><span class="line">            S4(&quot;🔀 流4: 请求Img1&quot;):::stream</span><br><span class="line">            S1 &lt;--&gt; S2</span><br><span class="line">            S2 &lt;--&gt; S3</span><br><span class="line">            S3 &lt;--&gt; S4</span><br><span class="line">        end</span><br><span class="line">        classDef HTTP2 fill:#d1fae5,stroke:#10b981,stroke-width:2px;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    HTTP1 -- &quot;🆚对比&quot; compare --&gt; HTTP2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>“无状态”是HTTP协议最根本的设计哲学之一。理解它，是理解为何需要Cookie、Session、Token等会话管理技术的起点。这是架构设计和面试中的高频话题。</p><p>在现代的分布式、微服务架构和云原生环境下，服务的“无状态性”变得前所未有的重要。因为一个无状态的服务可以被轻易地水平扩展（简单地增加服务器实例），也可以被负载均衡器自由地调度到任何一台机器上，而无需担心会话数据丢失。<strong>将“无状态”与“可伸缩性(Scalability)”强关联，是现代架构师的必备思维。</strong></p><ul><li><strong>Cookie-Session 时代：</strong> Cookie只在客户端存储一个无意义的session_id，所有用户的具体状态数据（如购物车、登录信息）都保存在<strong>服务器端的内存或数据库</strong>中。</li><li><strong>Token-Based (JWT) 时代：</strong> 为了让后端服务也“无状态”，我们不再在服务器端存储会话数据。取而代之的是，服务器在用户认证成功后，生成一个加密的、包含用户信息的<strong>Token (如JWT)</strong>，并将其发送给客户端。客户端在后续请求中携带这个Token，服务器只需验证Token的合法性即可，无需查询自己的“会话存储”。这使得后端服务可以无限水平扩展。</li></ul><p><img src="https://s2.loli.net/2025/07/11/ZjEnYaINp3Rv7bs.png" alt="http"></p><h3 id="生活案例-1"><a href="#生活案例-1" class="headerlink" title="生活案例"></a>生活案例</h3><ul><li><strong>无状态协议</strong>就像是与一个记忆力很差的<strong>自动售货机</strong>打交道。你每次投币买东西，它都会给你对应的商品，但它完全不记得你之前买过什么。如果你想连续买两瓶可乐，你必须完整地做两次“投币-按按钮”的操作。</li><li><strong>有状态协议</strong>则像是你和一个熟悉的<strong>酒吧老板</strong>打交道。你第一次去说：“我是张三，以后我的酒都记在账上。” 老板记住了。之后你每次去，只需要说：“老样子，来一杯。” 他就知道该给你什么，并记在你的账上。</li></ul><h3 id="真实案例-1"><a href="#真实案例-1" class="headerlink" title="真实案例"></a>真实案例</h3><p>考虑一个大型电商的“购物车”功能。</p><ul><li><strong>早期设计（有状态）：</strong> 每个用户的购物车内容都存在Web服务器的内存（Session）里。当用户量巨大时，服务器内存会成为瓶颈。如果该服务器宕机，用户的购物车数据就全部丢失了。而且，负载均衡器必须使用“粘性会话”（Sticky Session），把同一个用户的请求始终转发到同一台服务器，这降低了负载均衡的灵活性。</li><li><strong>现代设计（无状态）：</strong> 用户在<strong>未登录</strong>时，购物车信息被加密存储在<strong>客户端的Cookie或LocalStorage</strong>里。用户<strong>登录</strong>后，购物车信息被同步到<strong>服务端的分布式缓存（如Redis）或数据库</strong>中。Web服务器本身不存储任何购物车状态，每次请求过来，它都根据请求中的用户信息（可能是session_id或JWT）去后端存储中查询购物车数据。这样的服务器可以无限水平扩展。</li></ul><h3 id="经典问题-1"><a href="#经典问题-1" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>面试题: 既然HTTP是无状态的，那我们是如何实现用户登录状态的保持的？请比较一下基于Session和基于JWT的两种主要方案。</p></blockquote><p>是的，HTTP的无状态性意味着服务器本身不记录客户端的状态，这就需要我们引入额外的机制来管理会话，其中最主流的就是基于Session和基于Token（特别是JWT）的方案。</p><p><strong>1. 基于Cookie-Session的方案（传统方案）：</strong><br>* <strong>流程：</strong> 客户端首次登录成功后，服务器会创建一个Session对象，里面存储着用户的状态信息（如用户ID、角色等），并为这个Session生成一个唯一的session_id。然后，服务器通过Set-Cookie响应头将这个session_id返回给客户端。客户端浏览器会自动保存这个Cookie。在后续的每次请求中，浏览器都会自动带上这个session_id。服务器收到请求后，通过session_id找到对应的Session，从而识别出用户身份。<br>* <strong>优点：</strong> 状态数据存储在服务端，相对安全；客户端Cookie中只存储无意义的ID，数据量小。<br>* <strong>缺点：</strong> <strong>服务器有状态，不易扩展</strong>。在分布式环境下，需要解决Session共享问题，比如使用粘性会话、Session复制或集中的Session存储（如Redis），这增加了架构复杂性。</p><p><strong>2. 基于JWT（JSON Web Token）的方案（现代主流）：</strong><br>* <strong>流程：</strong> 客户端登录成功后，服务器不再创建Session。而是将用户的核心信息（如用户ID、角色、过期时间）编码成一个JWT字符串。这个JWT本身包含了签名，可以防止被篡改。服务器将这个JWT直接返回给客户端。客户端通常将其存储在LocalStorage或HttpOnly Cookie中。在后续请求中，客户端通过HTTP的Authorization头（通常是Bearer <token>）将JWT发送给服务器。<br>* <strong>优点：</strong> <strong>服务器完全无状态</strong>。服务器无需存储任何会话信息，只需验证JWT签名的有效性即可。这使得后端服务可以非常容易地进行水平扩展。天然地避免了CSRF攻击（如果存储在LocalStorage中）。<br>* <strong>缺点：</strong> Token本身可能较大；一旦签发，在过期前难以强制吊销；由于信息存在客户端，不适合存放敏感数据。</p><p><strong>总结对比：</strong> Session方案将状态的包袱留给了服务端，而JWT方案则将状态（以加密Token的形式）“甩”给了客户端。在当今追求<strong>高可伸缩性、跨域通信和微服务</strong>的架构下，JWT这种<strong>服务端无状态</strong>的方案已成为事实上的主流选择。</p><h3 id="补充知识-1"><a href="#补充知识-1" class="headerlink" title="补充知识"></a>补充知识</h3><h4 id="请求与线程的关系"><a href="#请求与线程的关系" class="headerlink" title="请求与线程的关系"></a>请求与线程的关系</h4><p><img src="https://s2.loli.net/2025/07/11/irIwBycGYnHtV6g.png" alt="req"></p><p><strong>一个HTTP请求通常会由一个后台线程来处理，但这只是最终呈现的结果。前端请求与后台线程的真正关系，取决于Web服务器的I&#x2F;O模型和并发模型。</strong></p><p>这个关系取决于服务器的并发模型。</p><ol><li>在传统的<strong>阻塞I&#x2F;O模型</strong>下，可以近似地认为<strong>一个请求独占一个线程</strong>。这种模式简单直观，但由于线程开销巨大，无法支持高并发。</li><li>在现代高性能服务器普遍采用的<strong>非阻塞I&#x2F;O（或异步I&#x2F;O）模型</strong>下，这种关系被解耦了。前端的大量请求首先由<strong>少数几个I&#x2F;O线程</strong>来接收和分发，这些I&#x2F;O线程利用事件循环机制，可以高效地管理成千上万的并发连接。而请求中真正的<strong>业务逻辑处理</strong>，则被封装成任务，交由一个<strong>数量固定的后台工作线程池</strong>来执行。</li></ol><p>因此，前端的请求和后台的多线程是<strong>多对多</strong>的关系，但中间通过一个高效的<strong>I&#x2F;O事件分发层</strong>进行了调度。我们Java后台开发中讨论的‘线程共享’，通常指的是工作线程池中的线程共享数据库连接池、缓存等公共资源。而我们说‘这个请求很耗时’，通常是指它在工作线程中执行业务逻辑（比如一个复杂的数据库查询）花费了很长时间，但这并不会阻塞I&#x2F;O线程接收其他新的请求。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie是一种允许服务器在客户端（浏览器）上存储少量文本信息的机制。其核心流程是：</p><ol><li>服务器通过在HTTP响应报文中添加Set-Cookie头部，将信息“种”到客户端。</li><li>客户端收到后，会将这些信息存储起来。</li><li>当客户端再次向<strong>同一个服务器</strong>发起请求时，会自动在HTTP请求报文中添加Cookie头部，将之前存储的信息回传给服务器。</li></ol><p><strong>HttpOnly属性：</strong></p><ul><li><strong>作用：</strong> 这是最重要的安全属性。设置了HttpOnly的Cookie，将<strong>无法通过JavaScript的document.cookie API进行读写</strong>。</li><li><strong>解决的问题：</strong> 有效地防御了绝大部分的<strong>跨站脚本攻击（XSS）</strong>。黑客即使在你的页面注入了恶意脚本，也无法窃取到这个Cookie，从而无法轻易地劫持你的会话。</li><li><strong>业界标准：</strong> 所有承载敏感信息（如session_id, token）的Cookie，<strong>必须</strong>设置为HttpOnly。</li></ul><p><strong>Secure属性：</strong></p><ul><li><strong>作用：</strong> 设置了Secure的Cookie，只有在<strong>HTTPS</strong>连接中才会被发送。在HTTP连接中，浏览器会忽略这个Cookie，不会发送它。</li><li><strong>解决的问题：</strong> 防止Cookie在不安全的HTTP连接中被中间人嗅探和窃取。</li><li><strong>业界标准：</strong> 所有承载敏感信息的Cookie，<strong>必须</strong>设置为Secure。</li></ul><p><strong>SameSite属性：</strong></p><ul><li><strong>作用：</strong> 这是防御**跨站请求伪造（CSRF）**攻击的利器。它定义了浏览器在**跨站请求**时是否应发送Cookie。</li><li><strong>它有三个值：</strong><ul><li>Strict: 最严格。任何跨站请求（比如从A网站点击链接到B网站），都不会携带B网站的Cookie。</li><li>Lax: (目前多数浏览器的默认值) 在一些安全的顶层导航（如点击链接、GET表单）时允许发送Cookie，但在POST请求、img、iframe等加载中则会禁止。</li><li>None: 任何跨站请求都会发送Cookie。但<strong>必须同时设置Secure属性</strong>，否则无效。常用于需要跨域认证的API场景。</li></ul></li><li><strong>解决的问题：</strong> CSRF攻击的核心是利用了用户在A网站的操作，会<strong>自动携带</strong>B网站的Cookie去请求B网站。SameSite属性正是打破了这个“自动携带”的链条。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%%&#123;init: &#123; &quot;themeVariables&quot;: &#123; &quot;sequenceNumberColor&quot;: &quot;#546E7A&quot;, &quot;actorBorder&quot;: &quot;#78909C&quot;, &quot;actorBkg&quot;: &quot;#E3F2FD&quot;, &quot;actorTextColor&quot;: &quot;#1E88E5&quot;, &quot;noteBkgColor&quot;: &quot;#fffde7&quot;, &quot;noteBorderColor&quot;: &quot;#FFD600&quot; &#125;, &quot;theme&quot;: &quot;neo&quot; &#125; &#125;%%</span><br><span class="line">sequenceDiagram</span><br><span class="line">    participant Client as 浏览器</span><br><span class="line">    participant Server as 服务器</span><br><span class="line"></span><br><span class="line">    Client-&gt;&gt;Server: 1. 登录请求 (POST /login) user: a, pass: b</span><br><span class="line">    Note over Server: 验证成功，创建会话</span><br><span class="line">    Server--&gt;&gt;Client: 2. 响应: Set-Cookie: session_id=xyz123 HttpOnly Secure SameSite=Strict</span><br><span class="line">    Note over Client: 浏览器存储了安全 Cookie</span><br><span class="line"></span><br><span class="line">    Client-&gt;&gt;Server: 3. 后续请求 (GET /my/orders) Cookie: session_id=xyz123</span><br><span class="line">    Note over Server: session_id 识别用户，返回数据</span><br><span class="line">    Server--&gt;&gt;Client: 4. 响应: [订单数据]</span><br><span class="line"></span><br><span class="line">    Note over Client: 用户点击了恶意网站链接…</span><br><span class="line">    participant AttackerSite as 恶意网站</span><br><span class="line">    Client-&gt;&gt;AttackerSite: 访问恶意网站</span><br><span class="line">    AttackerSite--&gt;&gt;Client: 页面包含 &lt;img src=&quot;https://server.com/delete_account&quot;&gt;</span><br><span class="line">    Note over Client: 浏览器尝试加载图片，向服务器发起请求（CSRF攻击尝试）</span><br><span class="line">    Note over Client: 因 SameSite=Strict，浏览器拒绝在此跨站请求中发送 Cookie！</span><br><span class="line">    Client-xServer: 请求被发送（但不带 Cookie）</span><br><span class="line">    Note over Server: 服务器因收不到 Cookie，认证失败，CSRF防御成功！</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生活案例-2"><a href="#生活案例-2" class="headerlink" title="生活案例"></a>生活案例</h3><p><strong>Cookie</strong>就像是游乐场的<strong>腕带</strong>。</p><ul><li>你买票入场时（<strong>登录</strong>），工作人员（<strong>服务器</strong>）给你戴上一个腕带（<strong>Set-Cookie</strong>），上面有个独一无二的条形码（<strong>session_id</strong>）。</li><li><strong>HttpOnly</strong>属性就像这个腕带是<strong>一次性锁死</strong>的，你自己用手摘不下来（JS无法读取），只能由专门的机器（浏览器协议）来识别。</li><li><strong>Secure</strong>属性意味着只有在游乐场<strong>官方通道</strong>（HTTPS）才能扫描这个腕带，你在外面的小卖部（HTTP）用不了。</li><li><strong>SameSite&#x3D;Strict</strong>属性就像是规定，这个腕带<strong>只能在游乐场内部</strong>使用。如果你跑到隔壁的商场，想用这个腕带打折，商场的扫描仪（其他网站）会拒绝识别。</li></ul><h3 id="真实案例-2"><a href="#真实案例-2" class="headerlink" title="真实案例"></a>真实案例</h3><p><strong>场景：</strong> 设计一个银行网站的“记住我”功能。</p><ul><li><strong>错误实践：</strong> 将用户的明文用户名和密码保存在普通Cookie中。这是极度危险的，一旦被XSS攻击，用户的凭证将立刻泄露。</li><li><strong>正确实践：</strong><ol><li>用户登录时，如果勾选了“记住我”，服务器会生成一个<strong>长期的、高熵的、随机的令牌（Token）</strong>。</li><li>服务器在数据库中存储这个令牌，并关联到该用户，同时设置一个较长的过期时间（比如30天）。</li><li>服务器通过Set-Cookie将这个令牌返回给客户端，并<strong>必须</strong>设置以下属性：token&#x3D;abc…xyz; Expires&#x3D;…; HttpOnly; Secure; SameSite&#x3D;Lax。</li><li>用户下次访问时，浏览器会自动携带这个令牌Cookie。服务器端的“自动登录”过滤器会检查这个令牌，在数据库中验证其有效性。如果有效，则为用户自动创建一次性的登录会话，实现“记住我”功能。</li></ol></li></ul><h3 id="经典问题-2"><a href="#经典问题-2" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>HttpOnly和SameSite这两个Cookie属性分别是为了解决什么安全问题的？请具体说明。</p></blockquote><p>这两个属性是现代Web安全中用于加固Cookie、防御两大核心攻击的关键手段。</p><ol><li><strong>HttpOnly 主要防御的是跨站脚本攻击（XSS）。</strong> XSS攻击的核心是攻击者在网页中注入了恶意的JavaScript脚本。在没有HttpOnly的情况下，这个脚本可以通过document.cookie窃取到用户的会话Cookie（比如session_id），然后发送到攻击者的服务器，攻击者就可以利用这个Cookie伪装成用户进行操作，这就是“会话劫持”。而设置了HttpOnly属性后，JavaScript就无法再访问这个Cookie，从根本上切断了XSS攻击窃取会话Cookie的路径，极大地提升了安全性。</li><li><strong>SameSite 主要防御的是跨站请求伪造（CSRF）。</strong> CSRF攻击的核心是利用了浏览器在发送跨站请求时会自动携带目标站点Cookie的特性。攻击者会诱导已登录的用户（比如银行网站的用户）去点击一个恶意链接，这个链接会向银行服务器发起一个转账请求。由于浏览器会自动带上银行的Cookie，银行服务器会误以为这是用户的真实操作，从而导致资金被盗。SameSite属性通过限制跨站请求发送Cookie来防御这种攻击。SameSite&#x3D;Strict最为严格，几乎禁止所有跨站Cookie发送；而Lax模式则是一种平衡，它允许在用户主动导航（如点击链接）这种风险较低的场景下发送Cookie，但在高风险的场景（如POST请求或通过<img>、<iframe>发起的请求）下则会阻止，这已经能防御绝大多数CSRF攻击了。</li></ol><p><strong>总结来说，HttpOnly保护Cookie不被“内鬼”（页面内的JS）偷走，而SameSite保护Cookie不被“外人”（其他网站）利用。</strong> 在实际开发中，对敏感Cookie同时设置这两个属性，是构建安全防线的标准操作。</p><h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    autonumber</span><br><span class="line"></span><br><span class="line">    participant C1 as Client 1</span><br><span class="line">    participant S1 as Server 1</span><br><span class="line">    participant C2 as Client 2</span><br><span class="line">    participant S2 as Server 2</span><br><span class="line">    participant C3 as Client 3</span><br><span class="line">    participant S3 as Server 3</span><br><span class="line"></span><br><span class="line">    rect rgba(240,248,255,0.4)</span><br><span class="line">    Note over C1,S1: HTTP/1.0 短连接（3个资源）</span><br><span class="line">        C1-&gt;&gt;S1: TCP Handshake</span><br><span class="line">        C1-&gt;&gt;S1: Request 1 (HTML)</span><br><span class="line">        S1--&gt;&gt;C1: Response 1</span><br><span class="line">        C1--&gt;&gt;S1: TCP Teardown</span><br><span class="line"></span><br><span class="line">        C1-&gt;&gt;S1: TCP Handshake</span><br><span class="line">        C1-&gt;&gt;S1: Request 2 (CSS)</span><br><span class="line">        S1--&gt;&gt;C1: Response 2</span><br><span class="line">        C1--&gt;&gt;S1: TCP Teardown</span><br><span class="line"></span><br><span class="line">        C1-&gt;&gt;S1: TCP Handshake</span><br><span class="line">        C1-&gt;&gt;S1: Request 3 (JS)</span><br><span class="line">        S1--&gt;&gt;C1: Response 3</span><br><span class="line">        C1--&gt;&gt;S1: TCP Teardown</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    rect rgba(224,255,255,0.4)</span><br><span class="line">    Note over C2,S2: HTTP/1.1 持久连接</span><br><span class="line">        C2-&gt;&gt;S2: TCP Handshake</span><br><span class="line">        C2-&gt;&gt;S2: Request 1 (HTML)</span><br><span class="line">        S2--&gt;&gt;C2: Response 1</span><br><span class="line">        C2-&gt;&gt;S2: Request 2 (CSS)</span><br><span class="line">        S2--&gt;&gt;C2: Response 2</span><br><span class="line">        C2-&gt;&gt;S2: Request 3 (JS)</span><br><span class="line">        S2--&gt;&gt;C2: Response 3</span><br><span class="line">        Note over C2,S2: Reuse 连接，响应完再发下一个请求</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    rect rgba(255,240,245,0.4)</span><br><span class="line">    Note over C3,S3: HTTP/1.1 管线化（理论）</span><br><span class="line">        C3-&gt;&gt;S3: TCP Handshake</span><br><span class="line">        C3-&gt;&gt;S3: Request 1 (HTML)</span><br><span class="line">        C3-&gt;&gt;S3: Request 2 (CSS)</span><br><span class="line">        C3-&gt;&gt;S3: Request 3 (JS)</span><br><span class="line">        S3--&gt;&gt;C3: Response 1</span><br><span class="line">        S3--&gt;&gt;C3: Response 2</span><br><span class="line">        S3--&gt;&gt;C3: Response 3</span><br><span class="line">        Note over C3,S3: 请求并行发出，但响应需按顺序返回</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><h3 id="生活案例-3"><a href="#生活案例-3" class="headerlink" title="生活案例"></a>生活案例</h3><ul><li><strong>短连接</strong>就像是每次去超市买一件商品，你都要完整地经历一次“开车去 -&gt; 停车 -&gt; 进店 -&gt; 结账 -&gt; 开车回家”的流程。买三件商品，就要跑三趟。</li><li><strong>持久连接</strong>就像是你开车到超市后，把车停在停车场，然后进店里把购物车装满，最后统一结账再开车回家。你只跑了一趟，节省了大量的“开车”和“停车”时间（TCP握手和慢启动）。</li><li><strong>管线化</strong>则像是，你把购物清单一口气全扔给一个超市导购员，但他必须严格按照清单的顺序一件一件找齐了，再统一给你。如果第一件商品（比如进口奶酪）特别难找，你就要一直等到他找到为止，即使他已经路过了后面清单上的所有商品。</li></ul><h3 id="真实案例-3"><a href="#真实案例-3" class="headerlink" title="真实案例"></a>真实案例</h3><ul><li>几乎所有现代Web网站的性能都受益于持久连接。以加载一个新闻门户网站为例，主页面index.html加载完成后，浏览器需要继续加载数十个CSS文件、JS文件、logo图片、广告图片、文章缩略图等。</li><li>如果没有持久连接，每个资源的加载都需要一次独立的TCP连接建立和关闭，页面加载时间可能会从2-3秒延长到10秒以上，用户体验将是灾难性的。</li><li><strong>HTTP&#x2F;1.1的持久连接机制</strong>，配合浏览器的<strong>并行连接</strong>（通常对一个域名开6-8个持久连接），是支撑现代复杂网页快速加载的基础。</li></ul><h3 id="经典问题-3"><a href="#经典问题-3" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>HTTP&#x2F;1.1的持久连接相比于HTTP&#x2F;1.0的短连接，主要解决了什么问题？它自身又有什么局限性，而HTTP&#x2F;2又是如何解决这些局限性的？</p></blockquote><p>HTTP&#x2F;1.1的持久连接主要解决了HTTP&#x2F;1.0短连接模型的两大性能瓶颈：</p><ol><li><strong>高昂的连接建立开销：</strong> 短连接模型下，每个HTTP请求都需要经过一次TCP三次握手，这至少会产生一个RTT的延迟。对于包含大量小资源的页面，这些握手延迟累加起来非常可观。持久连接通过复用同一个TCP连接，完全避免了后续请求的握手开销。</li><li><strong>TCP慢启动的性能影响：</strong> 每个新的TCP连接都会经历一个“慢启动”过程，即连接的传输速度会从一个较低的值开始，慢慢提升。对于小文件频繁的Web请求，连接很可能在速度还没达到峰值时就被关闭了，导致TCP的性能优势无法发挥。持久连接由于长时间保持，可以使得连接“预热”，始终工作在较高的传输速率下。</li></ol><p><strong>然而，HTTP&#x2F;1.1的持久连接自身也存在一个核心局限性，那就是队头阻塞（Head-of-Line Blocking）：</strong></p><ul><li>在一个TCP连接上，虽然可以发送多个请求，但响应必须按请求的顺序串行返回。如果第一个请求的服务器处理时间很长，它就会阻塞后面所有请求的响应，即使后面的响应早已准备就绪。虽然管线化（Pipelining）技术试图解决这个问题，但由于其自身的复杂性和兼容性问题，并未被广泛采用。</li></ul><p><strong>HTTP&#x2F;2则通过引入“多路复用”（Multiplexing）机制，完美地解决了队头阻塞问题：</strong></p><ul><li>HTTP&#x2F;2允许在<strong>单个TCP连接</strong>上，将多个请求&#x2F;响应分割成更小的、独立的<strong>帧（Frame）</strong>，并将它们交错地发送和接收。每个帧都带有自己的流标识符（Stream ID），所以接收端可以根据ID将它们重新组装成完整的请求或响应。这样，一个慢请求的响应就不会再阻塞其他快速的响应，真正实现了并行传输。</li></ul><h2 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    subgraph &quot;HTTP/1.1 报文 (纯文本)&quot;</span><br><span class="line">        direction TB</span><br><span class="line">        A[&quot;&lt;b&gt;请求行:&lt;/b&gt; GET /index.html HTTP/1.1\r\n&quot;]:::request</span><br><span class="line">        B[&quot;&lt;b&gt;首部:&lt;/b&gt; Host: example.com\r\nUser-Agent: ...\r\n&quot;]:::headers</span><br><span class="line">        C[&quot;&lt;b&gt;空行:&lt;/b&gt; \r\n&quot;]:::emptyline</span><br><span class="line">        D[&quot;&lt;b&gt;(无主体)&lt;/b&gt;&quot;]:::noBody</span><br><span class="line">        A --&gt; B --&gt; C --&gt; D</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph &quot;HTTP/2 报文 (二进制帧流)&quot;</span><br><span class="line">        direction LR</span><br><span class="line">        H1[HEADERS Frame&lt;br&gt;包含:method, path, host等&lt;br&gt;&lt;b&gt;经过HPACK压缩&lt;/b&gt;]:::headers2 --&gt; D1[DATA Frame&lt;br&gt;可选的主体数据]:::data</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    classDef request fill:#f9f,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef headers fill:#ccf,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef emptyline fill:#fff,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef noBody fill:#fdd,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef headers2 fill:#ddf,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef data fill:#cfc,stroke:#333,stroke-width:2px;</span><br><span class="line">    class A,B,C,D,H1,D1 fill:#fff,stroke:#ddd,stroke-width:1px;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生活案例-4"><a href="#生活案例-4" class="headerlink" title="生活案例"></a>生活案例</h3><ul><li><strong>HTTP&#x2F;1.1的报文</strong>就像一封传统的<strong>信件</strong>。有信封上的地址和收件人（<strong>起始行</strong>），有信头写的日期和主题（<strong>首部</strong>），还有信纸上的正文内容（<strong>主体</strong>）。它们是作为一个整体寄送的。</li><li><strong>HTTP&#x2F;2的报文</strong>则像是把这封信的内容拆分成了很多张标准大小的<strong>卡片（帧）</strong>，并进行了编码。HEADERS帧就像是包含了所有收发件人信息的“地址卡”，DATA帧就像是一张张写着正文内容的“内容卡”。这些卡片可以和其他信件的卡片混在一起（<strong>多路复用</strong>）寄送，到了目的地再根据信件编号重新组装起来。</li></ul><h3 id="真实案例-4"><a href="#真实案例-4" class="headerlink" title="真实案例"></a>真实案例</h3><p>当你在Chrome开发者工具（F12）的Network面板中查看一个请求时，你看到的“Headers”和“Payload”&#x2F;“Response”标签页，就是对HTTP报文逻辑结构的完美呈现。</p><ul><li><strong>General</strong> 和 <strong>Request&#x2F;Response Headers</strong> 部分对应<strong>起始行和首部</strong>。</li><li><strong>Payload</strong>（对于POST）或 <strong>Response</strong>（对于GET）标签页的内容对应<strong>主体</strong>。</li></ul><h3 id="经典问题-4"><a href="#经典问题-4" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>HTTP&#x2F;1.1和HTTP&#x2F;2在报文结构上最核心的区别是什么？这个区别带来了什么好处？</p></blockquote><p>最核心的区别在于，<strong>HTTP&#x2F;1.1是一个文本协议，其报文结构是基于文本的，而HTTP&#x2F;2是一个二进制协议，它引入了全新的帧（Frame）层。</strong></p><p>具体来说：</p><ol><li><strong>HTTP&#x2F;1.1</strong>的报文是由可读的ASCII文本构成的，包括起始行、首部和主体，它们之间通过换行符（CRLF）分隔。这种格式对人类友好，但对机器解析效率不高，且存在安全注入的风险。</li><li><strong>HTTP&#x2F;2</strong>则将一个逻辑上的请求或响应，在传输时分解为多个二进制编码的帧。比如，所有首部信息被打包到一个HEADERS帧中，而响应主体则被放入一个或多个DATA帧中。</li></ol><p>这个从“文本”到“二进制帧”的根本转变，带来了两大革命性的好处：</p><ul><li><strong>实现了多路复用（Multiplexing）：</strong> 来自不同请求的帧可以在同一个TCP连接上交错传输，每个帧都带有流ID，从而解决了HTTP&#x2F;1.1的队头阻塞问题，极大地提高了并发传输效率。</li><li><strong>实现了头部压缩（HPACK）：</strong> 由于首部被独立成HEADERS帧，HTTP&#x2F;2可以对大量重复的头部字段（如User-Agent, Accept等）使用HPACK算法进行高效压缩，显著减少了请求的体积，这在移动网络环境下尤其重要。</li></ul><h2 id="内容编码与传输编码"><a href="#内容编码与传输编码" class="headerlink" title="内容编码与传输编码"></a>内容编码与传输编码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    subgraph &quot;服务器处理流程&quot;</span><br><span class="line">        direction TB</span><br><span class="line">        A[原始资源&lt;br&gt;&lt;b&gt;实体主体&lt;/b&gt;&lt;br&gt;例如: 10KB的HTML]:::raw</span><br><span class="line">        B[Content-Encoding: gzip&lt;br&gt;压缩后的实体主体&lt;br&gt;例如: 2KB]:::encoded</span><br><span class="line">        C[Transfer-Encoding: chunked&lt;br&gt;将压缩后的数据分块&lt;br&gt;例如: Chunk1+Chunk2...]:::chunked</span><br><span class="line">        D[通过TCP连接发送&lt;br&gt;&lt;b&gt;报文主体&lt;/b&gt;]:::transferred</span><br><span class="line">        A --&gt;|Step 1: 内容编码| B --&gt;|Step 2: 传输编码| C --&gt; D</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph &quot;编码目的&quot;</span><br><span class="line">        Content_Encoding[&quot;&lt;b&gt;内容编码 (Content-Encoding)&lt;/b&gt;&lt;br&gt;为&lt;b&gt;资源&lt;/b&gt;瘦身, 节省带宽&lt;br&gt;作用于&lt;b&gt;实体主体&lt;/b&gt;&quot;]:::purpose</span><br><span class="line">        Transfer_Encoding[&quot;&lt;b&gt;传输编码 (Transfer-Encoding)&lt;/b&gt;&lt;br&gt;为&lt;b&gt;传输&lt;/b&gt;服务, 改变报文结构&lt;br&gt;作用于&lt;b&gt;报文主体&lt;/b&gt;&quot;]:::purpose</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    style Content_Encoding fill:#cde,stroke:#333,stroke-width:2px</span><br><span class="line">    style Transfer_Encoding fill:#fce,stroke:#333,stroke-width:2px</span><br><span class="line">    classDef raw fill:#f9f,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef encoded fill:#ccf,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef chunked fill:#cfc,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef transferred fill:#fdd,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef purpose fill:#fff,stroke:#333,stroke-width:2px;</span><br><span class="line"></span><br><span class="line">    class A,B,C,D Content_Encoding,Transfer_Encoding;</span><br></pre></td></tr></table></figure><h3 id="生活案例-5"><a href="#生活案例-5" class="headerlink" title="生活案例"></a>生活案例</h3><p>想象你要寄送一个大型的<strong>乐高模型（原始资源）</strong>。</p><ul><li><strong>内容编码 (gzip&#x2F;Brotli)</strong>：你发现直接寄送盒子太大、运费太贵。于是你把乐高模型<strong>拆散成一个个零件</strong>，并用<strong>真空压缩袋</strong>把它们打包起来。这样体积就大大减小了。这个“真空压缩”的过程，就是<strong>内容编码</strong>，它改变了“内容”本身（从组装好的模型变成了零件袋），目的是让它变得更小。</li><li><strong>传输编码 (chunked)</strong>：现在你有一包压缩好的零件，但你没有一个足够大的箱子一次装下。于是你决定<strong>分批寄送</strong>。你找了几个小盒子，在第一个盒子上写“第1箱，共3箱”，在第二个盒子上写“第2箱，共3箱”… 这就是<strong>分块传输编码</strong>。它没有改变盒子里的内容（零件还是那些零件），而是改变了“寄送的方式”（从一个大包裹变成几个小包裹）。</li></ul><h3 id="真实案例-5"><a href="#真实案例-5" class="headerlink" title="真实案例"></a>真实案例</h3><ul><li><strong>内容编码 (gzip&#x2F;Brotli)：</strong> 你打开任何一个现代网站，查看其HTML、CSS、JS文件的网络请求，你都会在响应头中看到Content-Encoding: gzip或Content-Encoding: br。这表明服务器对这些文本资源进行了压缩，你的浏览器在接收到后会自动解压。这是前端性能优化的标准操作。</li><li><strong>传输编码 (chunked)：</strong> 当你访问一个需要大量后台计算的报表页面时，比如“生成过去一年的销售报告”。服务器可能不会等所有数据都计算完毕（可能需要几十秒），而是采用<strong>流式处理</strong>：每计算出一部分数据，就立刻通过<strong>分块传输</strong>将这部分数据发送给浏览器。这样，用户很快就能看到页面的头部和第一部分数据，而不是面对一个长时间的白屏等待。你在开发者工具中会看到响应头里有Transfer-Encoding: chunked，并且看不到Content-Length头。</li></ul><h3 id="经典问题-5"><a href="#经典问题-5" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>Content-Encoding和Transfer-Encoding这两个HTTP头部有什么区别？</p></blockquote><p>Content-Encoding和Transfer-Encoding虽然都涉及“编码”，但它们是HTTP中两个完全不同层面、用于解决不同问题的机制。</p><ol><li><strong>目的不同：</strong><ul><li>Content-Encoding（内容编码）的目的是<strong>压缩实体主体</strong>，减少传输数据的大小，从而节省带宽、加快传输速度。常见的编码有gzip, deflate, br。它作用的对象是<strong>资源本身</strong>。</li><li>Transfer-Encoding（传输编码）的目的是<strong>改变报文的传输方式</strong>，以利于网络传输。目前唯一的标准值是chunked（分块传输）。它解决的是服务器无法在传输前确定整个响应体大小的问题（比如动态生成的内容），使得服务器可以流式地发送数据。它作用的对象是<strong>整个报文</strong>的结构。</li></ul></li><li><strong>作用位置不同：</strong><ul><li>内容编码是在<strong>服务器生成响应后，发送给客户端前</strong>对实体主体进行的“端到端”编码。客户端接收后需要先解码，才能得到原始的实体内容。</li><li>传输编码是<strong>逐跳</strong>的，它只在相邻的两个节点间有效。一个代理接收到chunked编码的报文后，必须先解码（将分块数据合并），然后再决定是否以chunked或其他方式转发给下一个节点。</li></ul></li><li><strong>与Content-Length的关系：</strong><ul><li>当使用Content-Encoding时，Content-Length头部的值是**编码后（压缩后）**的实体主体大小。</li><li>当使用Transfer-Encoding: chunked时，<strong>必须不能</strong>出现Content-Length头部，因为内容的长度是未知的，由最后一个大小为0的块来表示结束。</li></ul></li></ol><p><strong>总结来说，Content-Encoding是给“货物”做真空包装，而Transfer-Encoding是改变“送货”的方式。</strong></p><h2 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    subgraph &quot;服务器上的完整资源 (比如一个10MB的视频文件)&quot;</span><br><span class="line">        A[0MB] --&gt; B[2MB] --&gt; C[4MB] --&gt; D[6MB] --&gt; E[8MB] --&gt; F[10MB]</span><br><span class="line">        style A fill:#eee,stroke:#333</span><br><span class="line">        style B fill:#eee,stroke:#333</span><br><span class="line">        style C fill:#eee,stroke:#333</span><br><span class="line">        style D fill:#eee,stroke:#333</span><br><span class="line">        style E fill:#eee,stroke:#333</span><br><span class="line">        style F fill:#eee,stroke:#333</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph &quot;客户端的操作与请求&quot;</span><br><span class="line">        direction LR</span><br><span class="line">        P1[&quot;1. 正常播放&lt;br&gt;请求 Range: bytes=0-1999999&quot;] --&gt;|获取前2MB| S1[服务器]</span><br><span class="line">        P2[&quot;2. 拖动进度条到中段&lt;br&gt;请求 Range: bytes=4000000-5999999&quot;] --&gt;|只获取4-6MB| S1</span><br><span class="line">        P3[&quot;3. 多线程下载&lt;br&gt;T1: Range: 0-4999999&lt;br&gt;T2: Range: 5000000-&quot;] --&gt;|同时请求两部分| S1</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    S1 -- &quot;响应: 206 Partial Content&lt;br&gt;Content-Range: bytes 0-1999999/10000000&quot; --&gt; P1</span><br><span class="line">    S1 -- &quot;响应: 206 Partial Content&lt;br&gt;Content-Range: bytes 4000000-5999999/10000000&quot; --&gt; P2</span><br><span class="line">    S1 -- &quot;响应: 206 Partial Content (给T1)&lt;br&gt;响应: 206 Partial Content (给T2)&quot; --&gt; P3</span><br><span class="line"></span><br><span class="line">    style P1 fill:#ccf,stroke:#333,stroke-width:2px;</span><br><span class="line">    style P2 fill:#ccf,stroke:#333,stroke-width:2px;</span><br><span class="line">    style P3 fill:#ccf,stroke:#333,stroke-width:2px;</span><br><span class="line">    style S1 fill:#ddf,stroke:#333,stroke-width:2px;</span><br><span class="line">    class P1,P2,P3,S1 fill:#fff,stroke:#ddd,stroke-width:1px;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><strong>多线程下载器的工作原理：</strong> 现代的下载工具（如迅雷、IDM）和一些浏览器插件，正是利用了范围请求的**多部分请求（Multipart Ranges）**能力来加速下载。它们会同时对一个资源发起多个范围请求，每个请求下载文件的一部分，最后在本地将这些部分拼接起来。</li><li><strong>视频流媒体的“拖动”播放：</strong> 当你在B站或YouTube上观看视频并拖动进度条时，你实际上触发了一个新的范围请求。播放器会计算出你想看的时间点对应于整个视频文件（比如一个mp4文件）的哪个字节范围，然后向服务器发起一个Range请求，只获取那一小段数据，从而实现快速的“空降”播放，而无需下载整个文件。</li><li><strong>大文件上传的断点续传：</strong> 虽然范围请求主要用于下载，但其理念也被应用于上传。客户端可以先向服务器查询已上传了多少字节，然后通过类似Content-Range的机制（通常是自定义头部）从断点处继续上传剩余部分。</li></ol><h3 id="生活案例-6"><a href="#生活案例-6" class="headerlink" title="生活案例"></a>生活案例</h3><p>想象你在读一本非常厚的<strong>电子书（资源）</strong>。</p><ul><li><strong>没有范围请求：</strong> 你每次打开书，都必须从第一页开始下载整本书，即使你只想看第500页。</li><li><strong>有范围请求：</strong> 你可以直接告诉服务器：“我只想看第500页到第510页的内容”（Range: pages&#x3D;500-510，如果是字节就是bytes&#x3D;…）。服务器就只把这10页的内容发给你，非常高效。这就是<strong>断点续传和跳转阅读</strong>的原理。</li></ul><h3 id="真实案例-6"><a href="#真实案例-6" class="headerlink" title="真实案例"></a>真实案例</h3><p>除了上面提到的视频播放和下载工具，<strong>云存储服务</strong>（如阿里云OSS、AWS S3）的API也大量使用了范围请求。当你需要从云端下载一个几GB大的备份文件时，它们的SDK（软件开发工具包）在底层就是利用范围请求，将文件分块下载，并支持在网络中断后从失败的块开始续传，大大提升了大文件操作的稳定性和效率。</p><h3 id="经典问题-6"><a href="#经典问题-6" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>HTTP的206状态码是什么含义？它通常与哪两个头部字段一起工作来实现什么功能？</p></blockquote><p>206 Partial Content是HTTP中一个表示<strong>部分内容</strong>的成功状态码。它表明服务器成功处理了客户端的<strong>范围请求（Range Request）</strong>，并且响应体中只包含了资源的一部分，而不是全部。</p><p>它通常与以下两个核心的头部字段协同工作：</p><ol><li><strong>请求头：Range</strong><ul><li>由客户端发送，用于告诉服务器它想要获取资源的哪个或哪些部分。其值的单位最常见的是bytes，例如Range: bytes&#x3D;0-499表示请求资源的前500个字节。</li></ul></li><li><strong>响应头：Content-Range</strong><ul><li>由服务器在返回206响应时发送，用于告诉客户端这次返回的部分内容在整个资源中的位置。它的格式通常是bytes <start>-<end>&#x2F;<total>，例如Content-Range: bytes 0-499&#x2F;1234，表示这次发送的是第0到499字节，而整个资源的总长度是1234字节。</li></ul></li></ol><p>这套机制协同工作的核心功能是<strong>实现资源的部分获取</strong>，其最重要的两大应用场景是：</p><ul><li><strong>断点续传：</strong> 当下载大文件时，如果网络中断，客户端可以记录下已下载的字节数，然后通过Range头请求剩余的部分，服务器返回206响应，从而实现从断点继续下载。</li><li><strong>流媒体播放：</strong> 在线视频播放器通过发送带有不同字节范围的Range请求，来获取用户当前想观看或者预加载的视频片段，实现了“即点即播”和进度条拖动的功能。</li></ul><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[章4: HTTP状态码] </span><br><span class="line">    A1[1xx: 信息性]:::info</span><br><span class="line">    A2[2xx: 成功]:::success</span><br><span class="line">    A3[3xx: 重定向]:::redirect</span><br><span class="line">    A4[4xx: 客户端错误]:::clientError</span><br><span class="line">    A5[5xx: 服务器错误]:::serverError</span><br><span class="line"></span><br><span class="line">    A --&gt; A1</span><br><span class="line">    A --&gt; A2</span><br><span class="line">    A --&gt; A3</span><br><span class="line">    A --&gt; A4</span><br><span class="line">    A --&gt; A5</span><br><span class="line"></span><br><span class="line">    A1 --&gt; B1[100 Continue]</span><br><span class="line">    A2 --&gt; B2[200 OK]</span><br><span class="line">    A2 --&gt; B3[204 No Content]</span><br><span class="line">    A2 --&gt; B4[206 Partial Content]</span><br><span class="line">    A3 --&gt; B5[301 Moved Permanently - 面试重点]</span><br><span class="line">    A3 --&gt; B6[302 Found - 面试重点]</span><br><span class="line">    A3 --&gt; B7[304 Not Modified - 面试重点]</span><br><span class="line">    A3 --&gt; B8[307 Temporary Redirect]</span><br><span class="line">    A4 --&gt; B9[400 Bad Request]</span><br><span class="line">    A4 --&gt; B10[401 Unauthorized]</span><br><span class="line">    A4 --&gt; B11[403 Forbidden]</span><br><span class="line">    A4 --&gt; B12[404 Not Found]</span><br><span class="line">    A5 --&gt; B13[500 Internal Server Error]</span><br><span class="line">    A5 --&gt; B14[502 Bad Gateway]</span><br><span class="line">    A5 --&gt; B15[503 Service Unavailable]</span><br><span class="line"></span><br><span class="line">    classDef info fill:#cfe,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef success fill:#cfc,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef redirect fill:#ffb,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef clientError fill:#fcc,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef serverError fill:#fdd,stroke:#333,stroke-width:2px;</span><br><span class="line">    class A1,A2,A3,A4,A5 fill:#fff,stroke:#ddd,stroke-width:1px;</span><br><span class="line">    class B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B11,B12,B13,B14,B15 fill:#fff,stroke:#ddd,stroke-width:1px;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3xx重定向状态码"><a href="#3xx重定向状态码" class="headerlink" title="3xx重定向状态码"></a>3xx重定向状态码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant B as 浏览器/搜索引擎</span><br><span class="line">    participant S1 as 旧地址 (example.com/old)</span><br><span class="line">    participant S2 as 新地址 (example.com/new)</span><br><span class="line"></span><br><span class="line">    %% Permanent Redirect (301)</span><br><span class="line">    B-&gt;&gt;S1: GET /old</span><br><span class="line">    S1--&gt;&gt;B: 301 Moved Permanently&lt;br&gt;Location: /new</span><br><span class="line">    B-&gt;&gt;S2: GET /new</span><br><span class="line">    Note over B: 记住! 下次直接访问/new</span><br><span class="line">    B-&gt;&gt;S2: (下次) GET /new</span><br><span class="line"></span><br><span class="line">    %% Temporary Redirect (302/307)</span><br><span class="line">    B-&gt;&gt;S1: GET /old</span><br><span class="line">    S1--&gt;&gt;B: 302 Found&lt;br&gt;Location: /new</span><br><span class="line">    B-&gt;&gt;S2: GET /new</span><br><span class="line">    Note over B: 只是临时跳转, 下次还访问/old</span><br><span class="line">    B-&gt;&gt;S1: (下次) GET /old</span><br></pre></td></tr></table></figure><ul><li><strong>301 Moved Permanently (永久重定向):</strong> 表示请求的资源已被<strong>永久</strong>地移动到了新的URL。浏览器和搜索引擎在收到301后，会更新自己的书签和索引，未来会直接访问新的URL。</li><li><strong>302 Found (临时重定向):</strong> 表示请求的资源<strong>临时</strong>被移动到了新的URL。浏览器和搜索引擎不会更新记录，下次还是会访问原始的URL。</li><li><strong>304 Not Modified (未修改):</strong> 这是服务器对一个<strong>附带条件的请求</strong>（Conditional Request，通常是带有If-Modified-Since或If-None-Match头部）的回应。它告诉客户端，你本地缓存的资源还是最新的，直接用缓存吧，我这次就不给你发内容了。</li></ul><h4 id="生活案例-7"><a href="#生活案例-7" class="headerlink" title="生活案例"></a>生活案例</h4><ul><li><strong>301 永久重定向</strong>：你搬家了，你去邮局办理了<strong>地址永久迁移</strong>。从此以后，所有寄给你的信件，邮局都会<strong>直接改投到你的新家</strong>，并且会通知你的朋友们：“他搬家了，以后请直接寄到新地址。”</li><li><strong>302&#x2F;307 临时重定向</strong>：你只是去朋友家<strong>暂住几天</strong>。你告诉邮局，这几天的信件<strong>临时转寄</strong>到朋友家。邮局不会更改你的档案，你的朋友们也不知道你出门了，信件还是会先寄到你家，再由邮局转送。</li></ul><h4 id="真实案例-7"><a href="#真实案例-7" class="headerlink" title="真实案例"></a>真实案例</h4><ul><li><strong>301 永久重定向的典型应用：</strong><ul><li><strong>网站换域名：</strong> 当公司将域名从 old-brand.com 更换为 new-brand.com 时，必须在旧域名的服务器上配置对所有请求返回301，指向新域名对应的页面。这对**SEO（搜索引擎优化）**至关重要，它能告诉搜索引擎将旧域名的权重和排名**全部转移**到新域名上。</li><li><strong>URL规范化：</strong> 确保 <a href="http://example.com、http//www.example.com">http://example.com、http://www.example.com</a> 等多个入口都301重定向到唯一的、规范的URL（比如 <a href="https://www.example.com),避免搜索引擎认为这是重复内容./">https://www.example.com），避免搜索引擎认为这是重复内容。</a></li></ul></li><li><strong>302&#x2F;307 临时重定向的典型应用：</strong><ul><li><strong>未登录用户访问受限页面：</strong> 用户访问 my.example.com&#x2F;dashboard，服务器发现用户未登录，会返回一个302&#x2F;307重定向到登录页 my.example.com&#x2F;login，并在URL中附带一个参数告诉登录页登录成功后应该跳回dashboard。</li><li><strong>服务维护：</strong> 网站进行短暂维护时，可以临时将所有请求302重定向到一个静态的“维护中”页面。</li></ul></li></ul><h4 id="经典问题-7"><a href="#经典问题-7" class="headerlink" title="经典问题"></a>经典问题</h4><blockquote><p> 301和302在实际应用中，特别是对SEO，有什么本质区别？</p></blockquote><p>301和302最本质的区别在于它们向客户端和搜索引擎传递的<strong>语义</strong>完全不同，这直接影响了<strong>缓存行为和SEO权重</strong>。</p><ol><li><strong>301 (永久重定向)</strong> 告诉浏览器和搜索引擎：“这个地址<strong>永远废弃</strong>了，请以后都去访问新的地址”。因此：<ul><li><strong>浏览器行为：</strong> 浏览器会强烈地缓存这个重定向关系。在缓存有效期内，下次访问旧地址时，它可能<strong>不再向旧地址发请求</strong>，而是直接从本地缓存读取新地址并发起请求。</li><li><strong>SEO影响：</strong> 这是对SEO最友好的方式。搜索引擎会理解为网站<strong>权重和排名的永久性转移</strong>，它会把旧URL积累的“链接权重”（link juice）几乎全部传递给新的URL。</li></ul></li><li><strong>302 (临时重定向)</strong> 告诉浏览器和搜索引擎：“这个地址<strong>只是临时不在</strong>，请这次先去新地址访问，但下次还应该来访问我这个旧地址”。因此：<ul><li><strong>浏览器行为：</strong> 浏览器<strong>不会缓存</strong>这个重定向关系，每次访问旧地址时，它还是会先请求旧地址，然后再根据服务器的302响应进行跳转。</li><li><strong>SEO影响：</strong> 搜索引擎会认为旧URL依然是主体，<strong>不会将权重传递给新URL</strong>。如果长期错误地使用302进行永久性的域名或URL更换，将导致新页面的权重始终无法提升，对SEO是灾难性的。</li></ul></li></ol><p><strong>总结来说，网站改版、换域名等永久性变更必须使用301；而像登录跳转、服务临时维护等临时性跳转，则应该使用302（或者更精确的303&#x2F;307）。</strong></p><h3 id="4xx-客户端错误-5xx-服务器错误"><a href="#4xx-客户端错误-5xx-服务器错误" class="headerlink" title="4xx 客户端错误 &amp; 5xx 服务器错误"></a>4xx 客户端错误 &amp; 5xx 服务器错误</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Client as 客户端</span><br><span class="line">    participant Gateway as API网关 (Nginx)</span><br><span class="line">    participant ServiceA as 后端服务A</span><br><span class="line"></span><br><span class="line">    %% 场景一: 触发 502 Bad Gateway</span><br><span class="line">    Client -&gt;&gt; Gateway: 请求 /service-a/data</span><br><span class="line">    Gateway -&gt;&gt; ServiceA: 转发请求</span><br><span class="line">    Note over ServiceA: 服务A内部崩溃或&lt;br&gt;配置错误, 返回了&lt;br&gt;一个无效的响应/或直接断开连接</span><br><span class="line">    ServiceA --x Gateway: 返回无效响应 / 连接重置</span><br><span class="line">    Gateway --&gt;&gt; Client: &lt;b&gt;502 Bad Gateway&lt;/b&gt;</span><br><span class="line"></span><br><span class="line">    %% 场景二: 触发 504 Gateway Timeout</span><br><span class="line">    Client -&gt;&gt; Gateway: 请求 /service-a/report</span><br><span class="line">    Gateway -&gt;&gt; ServiceA: 转发请求</span><br><span class="line">    Note over ServiceA: 这是一个非常耗时的&lt;br&gt;报表计算任务</span><br><span class="line">    loop 等待响应 (例如超过30秒)</span><br><span class="line">        ServiceA -&gt;&gt; ServiceA: 仍在处理中...</span><br><span class="line">    end</span><br><span class="line">    Note over Gateway: 等待超时!</span><br><span class="line">    Gateway --&gt;&gt; Client: &lt;b&gt;504 Gateway Timeout&lt;/b&gt;</span><br><span class="line"></span><br><span class="line">    %% 场景三: 触发 401 Unauthorized</span><br><span class="line">    Client -&gt;&gt; Gateway: 请求 /service-a/secure-data</span><br><span class="line">    Gateway -&gt;&gt; ServiceA: 转发请求</span><br><span class="line">    Note over ServiceA: 服务A检查权限，&lt;br&gt;但客户端未提供有效的认证信息</span><br><span class="line">    ServiceA --x Gateway: 返回 401 Unauthorized</span><br><span class="line">    Gateway --&gt;&gt; Client: &lt;b&gt;401 Unauthorized&lt;/b&gt;</span><br><span class="line"></span><br><span class="line">    %% 场景四: 触发 403 Forbidden</span><br><span class="line">    Client -&gt;&gt; Gateway: 请求 /service-a/private-data</span><br><span class="line">    Gateway -&gt;&gt; ServiceA: 转发请求</span><br><span class="line">    Note over ServiceA: 客户端提供的认证信息&lt;br&gt;无权访问此资源</span><br><span class="line">    ServiceA --x Gateway: 返回 403 Forbidden</span><br><span class="line">    Gateway --&gt;&gt; Client: &lt;b&gt;403 Forbidden&lt;/b&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>4xx (Client Error):</strong> 表明错误是由<strong>客户端</strong>引起的。比如，客户端请求了一个不存在的URL，或者没有提供有效的认证信息。<ul><li><strong>401 (Unauthorized):</strong> <strong>“未认证”</strong>。表示当前请求需要用户认证，但客户端没有提供认证信息，或者认证信息无效（比如Token错误或过期）。它暗示客户端<strong>应该去认证</strong>（或重新认证）。</li><li><strong>403 (Forbidden):</strong> <strong>“未授权”</strong>。表示服务器已经成功识别了客户端的身份，但该用户<strong>没有权限</strong>访问这个资源。它暗示认证是没用的，换个有权限的账号来吧。例如，普通用户尝试访问管理员才能访问的后台接口。</li></ul></li><li><strong>5xx (Server Error):</strong> 表明错误发生在<strong>服务器端</strong>。服务器清楚地知道自己出了问题，无法完成一个看起来有效的请求。<ul><li><strong>502 (Bad Gateway):</strong> 通常是你的<strong>网关（如Nginx）</strong> 尝试去请求后端的<strong>上游服务（如一个Node.js应用）</strong>，但上游服务出了问题，返回了一个无效的响应，或者<strong>上游服务直接挂了，连接被拒绝</strong>。网关无法理解这个响应，于是返回502。<strong>核心是：连接已建立，但上游服务没正常工作。</strong></li><li><strong>504 (Gateway Timeout):</strong> 网关向上游服务发起了请求，但上游服务<strong>在网关设定的超时时间内，一直没有返回任何响应</strong>。网关等不及了，就返回504。<strong>核心是：上游服务活着，但处理太慢了。</strong></li></ul></li></ul><h4 id="生活案例-8"><a href="#生活案例-8" class="headerlink" title="生活案例"></a>生活案例</h4><ul><li><strong>4xx 客户端错误</strong> 就像是你去银行办业务：<ul><li><strong>400 Bad Request:</strong> 你填的表单格式不对，业务员看不懂。</li><li><strong>401 Unauthorized:</strong> 你没带身份证，业务员要求你先证明你是你。</li><li><strong>403 Forbidden:</strong> 你带了身份证，但你想查别人的账户，业务员告诉你“你没这个权限”。</li><li><strong>404 Not Found:</strong> 你要办的这个业务，银行根本就没有。</li></ul></li><li><strong>5xx 服务器错误</strong> 则是银行内部的问题：<ul><li><strong>500 Internal Server Error:</strong> 你的请求完全合规，但银行的电脑系统突然死机了。</li><li><strong>502 Bad Gateway:</strong> 你找的大堂经理（网关）去后台找柜员（上游服务）办业务，结果那个柜员给了他一张错误的单据，经理没法处理。</li><li><strong>503 Service Unavailable:</strong> 银行正在年终决算，所有窗口都暂停服务。</li><li><strong>504 Gateway Timeout:</strong> 大堂经理把你的申请交到后台了，但那个业务流程太复杂，后台一直没办完，经理等得不耐烦了，只能告诉你“超时了”。</li></ul></li></ul><h4 id="真实案例-8"><a href="#真实案例-8" class="headerlink" title="真实案例"></a>真实案例</h4><p>在一次线上问题排查中，监控系统报警大量出现502 Bad Gateway错误。</p><ol><li><strong>第一反应：</strong> 这不是客户端的问题，也不是网关本身的问题，而是<strong>网关后面的上游服务出了问题</strong>。</li><li><strong>排查路径：</strong> 登录到API网关（Nginx）服务器，查看错误日志（error.log）。</li><li><strong>发现日志：</strong> 日志中大量出现类似 (111: Connection refused) while connecting to upstream, client: … 的错误。</li><li><strong>定位问题：</strong> Connection refused（连接被拒绝）是一个非常明确的信号，它表明网关尝试去连接上游服务的IP和端口时，上游服务<strong>进程已经不存在或者端口没有被监听</strong>。</li><li><strong>解决问题：</strong> 登录到上游服务所在的服务器，发现对应的应用进程确实已经崩溃。重启服务后，问题解决。</li></ol><h4 id="经典问题-8"><a href="#经典问题-8" class="headerlink" title="经典问题"></a>经典问题</h4><blockquote><p>用户反馈网站打不开，你作为后端开发，会如何排查？如果抓包发现返回了502，这通常意味着什么？</p></blockquote><p>网站打不开的原因有很多，我会从客户端到服务器逐层排查。但如果明确返回了502状态码，那么排查的焦点就可以非常集中。</p><p>502 Bad Gateway是一个服务器端的错误码，但它特指作为<strong>网关或代理</strong>的服务器，在尝试访问上游服务器时，收到了一个<strong>无效的响应</strong>。在现代微服务架构中，这通常是API网关（比如Nginx）返回的。</p><p>收到502，我基本可以断定：</p><ol><li><strong>客户端到网关的网络是通的</strong>。</li><li><strong>网关本身是正常工作的</strong>。</li><li><strong>问题出在网关与某个上游后端服务之间的通信上</strong>。</li></ol><p>我会立刻采取以下排查步骤：</p><ol><li><strong>定位上游服务：</strong> 首先，我会根据用户访问的URL路径，去Nginx的配置文件中查找这个请求被proxy_pass到了哪个具体的上游服务（upstream）。</li><li><strong>查看网关日志：</strong> 登录Nginx服务器，查看error.log。502错误通常伴随着具体的错误原因，最常见的有：<ul><li>connect() failed (111: Connection refused)：这说明上游服务进程挂了，或者防火墙阻止了连接。我会立刻去检查上游服务的健康状态。</li><li>upstream prematurely closed connection：这说明连接建立了，但上游服务在返回完整响应前就提前关闭了连接，很可能是上游服务代码内部发生了崩溃。</li><li>upstream sent invalid header：上游服务返回的HTTP响应头不规范，Nginx无法解析。</li></ul></li><li><strong>检查上游服务：</strong> 根据网关日志的线索，直接去排查对应的上游服务。查看它的应用日志、系统资源（CPU、内存）使用情况，确定它为什么没有正常响应网关的请求。</li></ol><h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><h3 id="缓存控制首部"><a href="#缓存控制首部" class="headerlink" title="缓存控制首部"></a>缓存控制首部</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A(开始: 浏览器准备发起请求) --&gt; B&#123;检查本地缓存&#125;;</span><br><span class="line">    B -- 有缓存 --&gt; C&#123;检查强制缓存&#125;;</span><br><span class="line">    B -- 无缓存 --&gt; I(直接向服务器发起请求);</span><br><span class="line"></span><br><span class="line">    C -- 缓存有效 --&gt; D[直接使用缓存, 状态码200];</span><br><span class="line">    C -- 缓存无效 --&gt; E[发起协商缓存请求, 携带If-None-Match 或 If-Modified-Since];</span><br><span class="line"></span><br><span class="line">    E --&gt; F&#123;服务器验证&#125;;</span><br><span class="line">    F -- 资源未改变 --&gt; G[返回304 Not Modified];</span><br><span class="line">    F -- 资源已改变 --&gt; H[返回200 OK和新资源];</span><br><span class="line"></span><br><span class="line">    G --&gt; K(浏览器使用本地缓存并更新过期时间);</span><br><span class="line">    H --&gt; L(浏览器使用新资源并更新缓存);</span><br><span class="line">    I --&gt; H;</span><br><span class="line"></span><br><span class="line">    subgraph &quot;客户端决策区&quot;</span><br><span class="line">        A; B; C; E;</span><br><span class="line">    end</span><br><span class="line">    subgraph &quot;服务器决策区&quot;</span><br><span class="line">        F;</span><br><span class="line">    end</span><br><span class="line">    subgraph &quot;最终结果&quot;</span><br><span class="line">         D; K; L;</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    style D fill:#cde,stroke:#333,stroke-width:2px</span><br><span class="line">    style K fill:#cde,stroke:#333,stroke-width:2px</span><br></pre></td></tr></table></figure><p>HTTP缓存分为两大类：**强制缓存（也叫强缓存）*<em>和*<em>协商缓存</em></em>。</p><ul><li><p><strong>强制缓存 (Strong Caching):</strong> 浏览器在发起请求前，先检查本地缓存的副本是否<strong>在有效期内</strong>。如果在，就<strong>不向服务器发送任何请求</strong>，直接使用本地副本，HTTP状态码是 200 OK (from memory cache &#x2F; from disk cache)。</p></li><li><p><strong>协商缓存 (Negotiation Caching):</strong> 当强制缓存失效（过期）后，浏览器会向服务器<strong>发起一个验证请求</strong>。服务器根据请求中的验证信息判断资源是否有更新。如果没有更新，服务器返回一个<strong>极小的304 Not Modified响应</strong>，不包含响应体，告诉浏览器继续使用本地缓存。如果有更新，才返回200 OK和新的完整资源。</p></li><li><p><strong>Cache-Control的绝对统治地位：</strong> 《图解HTTP》中提到的Pragma: no-cache是HTTP&#x2F;1.0的产物，用于兼容性。Expires也是HTTP&#x2F;1.0的，它使用<strong>绝对时间</strong>，如果客户端和服务器时间不同步，就会出问题。在HTTP&#x2F;1.1中，Cache-Control使用<strong>相对时间</strong>（如 max-age&#x3D;3600 秒），并且指令更丰富，<strong>已完全取代了Expires</strong>。当Cache-Control和Expires同时存在时，Cache-Control的优先级更高。</p></li><li><p><strong>ETag优于Last-Modified：</strong></p><ul><li>Last-Modified（最后修改时间）是协商缓存的一种验证方式，但它存在两个问题：1) 时间戳的精度只能到秒，一秒内多次修改无法识别；2) 某些服务器上，只是打开文件但未修改，也可能导致修改时间变化。</li><li>ETag（实体标签）是服务器为资源生成的唯一标识符（类似文件指纹）。只要资源内容有任何变动，ETag就会改变。它比Last-Modified更精确、更可靠。</li><li><strong>业界标准：</strong> 当ETag和Last-Modified同时存在时，服务器<strong>必须优先使用ETag</strong> 来进行验证。</li></ul></li></ul><h4 id="生活案例-9"><a href="#生活案例-9" class="headerlink" title="生活案例"></a>生活案例</h4><ul><li><strong>强制缓存</strong>就像是你冰箱里的<strong>牛奶</strong>。你每次想喝牛奶时，都会先看一眼保质期（Expires &#x2F; Cache-Control: max-age）。只要还在保质期内，你就直接拿出来喝，根本不用出门去超市问。</li><li><strong>协商缓存</strong>就像是牛奶过期了，但你觉得可能还能喝。你不会直接扔掉，而是会<strong>打开闻一闻</strong>（发起协商缓存请求）。如果闻起来没问题（304 Not Modified），你就继续喝了。如果闻起来坏了（200 OK + 新牛奶），你才会去超市买一瓶新的回来。ETag就像是牛奶包装上的一个独特的批次码，比单看生产日期更可靠。</li></ul><h4 id="真实案例-9"><a href="#真实案例-9" class="headerlink" title="真实案例"></a>真实案例</h4><p> 前端性能优化中对不同资源设置缓存策略。</p><ul><li><strong>不常变动的资源（如库文件 antd.js, vue.js, logo图片）：</strong><ul><li><strong>策略：</strong> 设置一个非常长的<strong>强制缓存</strong>时间。比如 Cache-Control: public, max-age&#x3D;31536000 (一年)。</li><li><strong>配合：</strong> 文件名中通常会带上内容的哈希值，如antd.a3b4c5.js。一旦文件内容有变动，哈希值会变，文件名也变了，这会触发一个新的URL请求。这种策略叫**“内容哈希命名”（Content-addressable storage）**。</li><li><strong>效果：</strong> 用户第一次访问后，这些资源会被永久缓存，后续访问速度极快。</li></ul></li><li><strong>经常变动的资源（如业务逻辑index.js, 主index.html）：</strong><ul><li><strong>策略：</strong> 不设置或设置很短的强制缓存，但<strong>必须开启协商缓存</strong>。比如 Cache-Control: no-cache。no-cache并不是“不缓存”，而是“每次都必须去服务器验证一下”。</li><li><strong>效果：</strong> 保证了用户总能获取到最新的业务逻辑，同时在逻辑未变时，又能通过304响应来利用本地缓存，节省带宽。</li></ul></li></ul><h4 id="经典问题-9"><a href="#经典问题-9" class="headerlink" title="经典问题"></a>经典问题</h4><blockquote><p>请详细描述一下浏览器的缓存机制，特别是强制缓存和协商缓存的区别和联系。</p></blockquote><p>浏览器缓存是HTTP性能优化的核心机制，它主要分为强制缓存和协商缓存两大类，两者是协同工作的。</p><p><strong>1. 强制缓存（Strong Caching）：</strong><br>* <strong>触发机制：</strong> 浏览器在请求资源前，会先检查本地缓存的副本是否在有效期内。<br>* <strong>相关头部：</strong> 主要由服务器响应中的Cache-Control头（HTTP&#x2F;1.1，优先级高）和Expires头（HTTP&#x2F;1.0）控制。Cache-Control: max-age&#x3D;3600表示资源在3600秒内有效。<br>* <strong>表现：</strong> 如果缓存有效，浏览器<strong>不会向服务器发送任何请求</strong>，而是直接从本地内存或磁盘中读取资源，网络请求的状态码会是200 OK (from memory cache&#x2F;disk cache)，速度极快。</p><p><strong>2. 协商缓存（Negotiation Caching）：</strong><br>* <strong>触发机制：</strong> 当强制缓存过期后（或者收到了Cache-Control: no-cache指令），浏览器<strong>必须向服务器发起一次验证请求</strong>。<br>* <strong>相关头部：</strong> 这个验证请求会携带一些“凭证”：<br>* If-None-Match: 携带上一次响应中的ETag值。<br>* If-Modified-Since: 携带上一次响应中的Last-Modified值。<br>* <strong>服务器行为：</strong> 服务器收到请求后，会用这些凭证与当前资源进行比对。<br>* 如果资源<strong>未改变</strong>，服务器返回一个<strong>304 Not Modified</strong>状态码，响应体为空，告诉浏览器“你本地的版本还能用”。<br>* 如果资源<strong>已改变</strong>，服务器返回一个<strong>200 OK</strong>状态码，并在响应体中附上<strong>全新的资源内容</strong>和新的ETag&#x2F;Last-Modified。</p><p><strong>区别与联系：</strong></p><ul><li><strong>联系：</strong> 两者是前后衔接的流程。浏览器总是<strong>先检查强制缓存</strong>，强制缓存失效后，<strong>再发起协商缓存</strong>。</li><li><strong>区别：</strong> 强制缓存的核心是**“不问”<strong>，在有效期内完全不与服务器通信；而协商缓存的核心是</strong>“要问”**，每次都会与服务器通信，但服务器可能只返回一个极简的304响应，而不是完整的资源。</li></ul><p>在性能上，<strong>强制缓存 &gt; 协商缓存（命中304） &gt; 无缓存（完整200）</strong>。</p><h3 id="内容协商相关首部"><a href="#内容协商相关首部" class="headerlink" title="内容协商相关首部"></a>内容协商相关首部</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Client as 浏览器</span><br><span class="line">    participant Server as 服务器</span><br><span class="line"></span><br><span class="line">    Client-&gt;&gt;Server: 发起请求 (GET /article/123)</span><br><span class="line">    Note right of Client: 请求头: Accept-Language: zh-CN, Accept-Encoding: br, gzip</span><br><span class="line">    Server-&gt;&gt;Server: 解析请求头，选择压缩方式</span><br><span class="line">    Server--&gt;&gt;Client: 返回响应 (200 OK)</span><br><span class="line">    Note right of Client: Content-Language: zh-CN, Content-Encoding: br</span><br><span class="line"></span><br><span class="line">    Note over Client: 浏览器解压并渲染页面</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>Accept头部的“退化”与“重生”：</strong><ul><li><strong>传统Web页面：</strong> 在过去，浏览器发送的Accept头部非常复杂，比如Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,<em>&#x2F;</em>;q&#x3D;0.8。它试图告诉服务器它能处理的各种内容类型。但实际上，大多数Web服务器都<strong>忽略</strong>了这个复杂的头部，因为它们通常只返回text&#x2F;html。</li><li><strong>现代API（RESTful）：</strong> Accept头部在API交互中迎来了<strong>重生</strong>。一个设计良好的RESTful API，其同一个端点（URL）可以根据客户端Accept头部的不同，返回不同格式的数据。例如：<ul><li>GET &#x2F;api&#x2F;users&#x2F;1 + Accept: application&#x2F;json -&gt; 返回JSON格式的用户数据。</li><li>GET &#x2F;api&#x2F;users&#x2F;1 + Accept: application&#x2F;xml -&gt; 返回XML格式的用户数据。<br>这使得API具有更好的灵活性和向后兼容性。</li></ul></li></ul></li><li><strong>权重值q：</strong> q因子（quality value）是内容协商的量化工具，范围从0到1。它告诉服务器不同选项的<strong>优先级</strong>。例如 Accept-Language: fr-CH, fr;q&#x3D;0.9, en;q&#x3D;0.8 表示客户端最想要瑞士法语，其次是普通法语，再次是英语。</li><li><strong>Accept-Encoding的重要性：</strong> 这是内容协商中<strong>最常用、最有效</strong>的首部。浏览器通过发送 Accept-Encoding: gzip, deflate, br 告诉服务器它支持这三种解压算法，服务器则可以从中选择一种来压缩响应体，显著减少传输体积。</li></ul><h4 id="生活案例-10"><a href="#生活案例-10" class="headerlink" title="生活案例"></a>生活案例</h4><p>内容协商就像你去一家<strong>国际餐厅</strong>点菜。</p><ul><li>你对服务员（<strong>服务器</strong>）说：“我想点一份牛排（<strong>URL</strong>），我能看懂<strong>中文和英文菜单</strong>（Accept-Language），我喜欢吃<strong>七分熟</strong>的（Accept的一个变体，表示偏好），而且我<strong>不吃辣</strong>（Accept-Encoding的一个变体，表示能力限制）。”</li><li>服务员（<strong>服务器</strong>）听了你的要求，去厨房看了一下，发现今天有中文菜单，并且可以做七分熟不辣的牛排。</li><li>最后，他给你端上了<strong>七分熟的牛排</strong>，并附上了一张<strong>中文账单</strong>（Content-Language: zh）。</li></ul><h4 id="真实案例-10"><a href="#真实案例-10" class="headerlink" title="真实案例"></a>真实案例</h4><p>设计一个图片服务API，需要为不同设备提供最优化的图片格式。</p><ul><li><strong>背景：</strong> 现代浏览器（如Chrome）支持一种名为 <strong>WebP</strong> 的新图片格式，它在同等画质下比JPEG和PNG的体积小很多。但老浏览器不支持。</li><li><strong>实现：</strong><ol><li>服务器上为同一张图片存储多个版本，如 image.jpg, image.png, image.webp。</li><li>现代浏览器发起的图片请求，其Accept头会包含image&#x2F;webp，例如：Accept: image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,image&#x2F;<em>,</em>&#x2F;*;q&#x3D;0.8。</li><li>服务器（或CDN边缘节点）接收到请求后，检查Accept头部。如果发现其中包含image&#x2F;webp，就<strong>优先返回image.webp文件</strong>。</li><li>如果Accept头中没有image&#x2F;webp（说明是老浏览器），则根据情况返回image.jpg或image.png。</li></ol></li><li><strong>效果：</strong> 通过内容协商，为现代浏览器用户提供了加载速度更快的WebP图片，同时保持了对老浏览器的兼容性，实现了渐进式增强的性能优化。</li></ul><h4 id="经典问题-10"><a href="#经典问题-10" class="headerlink" title="经典问题"></a>经典问题</h4><blockquote><p>Accept-Encoding和Content-Encoding是如何配合工作的？这个机制有什么好处？</p></blockquote><p>Accept-Encoding和Content-Encoding是HTTP内容协商中用于<strong>传输压缩</strong>的一对核心请求&#x2F;响应头，它们共同实现了一种高效的数据传输机制。</p><p><strong>工作流程如下：</strong></p><ol><li><strong>客户端声明能力：</strong> 浏览器在发起请求时，通过Accept-Encoding请求头告诉服务器自己支持哪些解压算法。例如：Accept-Encoding: gzip, deflate, br，这表示浏览器能处理gzip、deflate和brotli这三种格式的压缩数据。</li><li><strong>服务器选择并执行压缩：</strong> 服务器收到请求后，会检查这个头部。如果服务器也支持这些算法，并且认为对响应内容进行压缩是有益的（通常对文本类资源有效），它就会选择其中一种算法（通常是压缩率最高的Brotli或最通用的gzip）来压缩响应体。</li><li><strong>服务器告知压缩方式：</strong> 服务器在返回的HTTP响应中，通过Content-Encoding响应头明确告知客户端，它实际使用了哪种算法进行压缩。例如：Content-Encoding: br。</li><li><strong>客户端解码：</strong> 浏览器接收到响应后，根据Content-Encoding头的值，调用相应的解压算法对响应体进行解压，最终得到原始的、可渲染的内容。</li></ol><p><strong>这个机制最大的好处是：</strong></p><ul><li><strong>显著减少了网络传输的数据量</strong>，通常能将HTML&#x2F;CSS&#x2F;JS等文本资源压缩到原始大小的20%-30%，从而<strong>大大加快了页面加载速度，降低了带宽成本，并改善了用户体验</strong>，尤其是在移动网络环境下效果非常明显。这是一种对客户端和服务器都非常有益的双赢机制。</li></ul><h3 id="连接管理首部"><a href="#连接管理首部" class="headerlink" title="连接管理首部"></a>连接管理首部</h3><ul><li><strong>Connection 首部：</strong> 这是一个非常特殊的“元”首部，它有两个核心作用：<ol><li><strong>控制连接的关闭&#x2F;保持：</strong> 它的值可以是close或keep-alive。在HTTP&#x2F;1.1中，默认是持久连接，所以通常只有在想明确关闭连接时，才会发送 Connection: close。</li><li><strong>标识“逐跳”首部：</strong> 这是它更复杂也更重要的作用。Connection首部可以列出一些其他的首部字段名，这些被列出的首部字段被认为是“逐跳”的，<strong>绝不能</strong>被代理服务器转发到下一跳。</li></ol></li><li><strong>Keep-Alive 首部：</strong> 这是一个<strong>已过时</strong>的、非标准的头部，最初在HTTP&#x2F;1.0的持久连接中被引入。它通常包含一些参数，比如 timeout（连接空闲超时时间）和 max（此连接上可处理的最大请求数）。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant C as 客户端</span><br><span class="line">    participant P as 代理服务器</span><br><span class="line">    participant S as 源服务器</span><br><span class="line"></span><br><span class="line">    Note over C,S: 客户端想升级到WebSocket协议</span><br><span class="line">    C-&gt;&gt;P: 请求:&lt;br&gt;Host: ...&lt;br&gt;&lt;b&gt;Upgrade: websocket&lt;/b&gt;&lt;br&gt;&lt;b&gt;Connection: Upgrade&lt;/b&gt;</span><br><span class="line"></span><br><span class="line">    Note over P: 代理服务器处理...</span><br><span class="line">    Note over P: 1. 看到Connection: Upgrade&lt;br&gt;2. 知道Upgrade是逐跳首部&lt;br&gt;3. &lt;b&gt;删除这两个首部&lt;/b&gt;再转发</span><br><span class="line">    P-&gt;&gt;S: 转发后的请求:&lt;br&gt;Host: ...&lt;br&gt;(Upgrade和Connection已被删除)</span><br><span class="line">    </span><br><span class="line">    Note over S: 源服务器收到的是一个普通的HTTP请求</span><br></pre></td></tr></table></figure><h4 id="经典问题-11"><a href="#经典问题-11" class="headerlink" title="经典问题"></a>经典问题</h4><blockquote><p>Connection头部字段有什么作用？</p></blockquote><p>Connection头部在HTTP&#x2F;1.1中是一个非常重要的“逐跳”首部（hop-by-hop header），它主要有两个核心作用：</p><ol><li><strong>控制连接的状态：</strong> 它的值可以是keep-alive或close。在HTTP&#x2F;1.1中，连接默认是持久的，所以我们通常只在需要明确指示在响应后关闭连接时，才会发送Connection: close。这可以用来优雅地通知对端，这是我最后一个请求&#x2F;响应了。</li><li><strong>管理逐跳首部：</strong> 这是它更底层、更关键的作用。Connection头部的值可以是一个逗号分隔的<strong>其他首部字段名列表</strong>。所有被列在这里的首部字段，都被认为是“逐跳”的，即它们只对当前的单次TCP连接有效，<strong>绝不能被代理服务器转发给下一个节点</strong>。在转发报文前，代理必须删除Connection首部以及它里面列出的所有首部。最典型的例子就是Upgrade头部（用于协议升级，如WebSocket），它总是与Connection: Upgrade一起出现，以确保只有直接相连的服务器才会处理这个升级请求。</li></ol><h2 id="TCP-IP基础"><a href="#TCP-IP基础" class="headerlink" title="TCP&#x2F;IP基础"></a>TCP&#x2F;IP基础</h2><h3 id="OSI七层-TCP-IP四层模型及协议对应关系"><a href="#OSI七层-TCP-IP四层模型及协议对应关系" class="headerlink" title="OSI七层 &amp; TCP&#x2F;IP四层模型及协议对应关系"></a>OSI七层 &amp; TCP&#x2F;IP四层模型及协议对应关系</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">  %% OSI 七层模型</span><br><span class="line">  subgraph OSI七层模型</span><br><span class="line">    OSI7[&quot;应用层&lt;br&gt;🌐&quot;]:::osi7</span><br><span class="line">    OSI6[&quot;表示层&lt;br&gt;📝&quot;]:::osi6</span><br><span class="line">    OSI5[&quot;会话层&lt;br&gt;🔗&quot;]:::osi5</span><br><span class="line">    OSI4[&quot;传输层&lt;br&gt;📦&quot;]:::osi4</span><br><span class="line">    OSI3[&quot;网络层&lt;br&gt;🌍&quot;]:::osi3</span><br><span class="line">    OSI2[&quot;数据链路层&lt;br&gt;🪢&quot;]:::osi2</span><br><span class="line">    OSI1[&quot;物理层&lt;br&gt;⚡&quot;]:::osi1</span><br><span class="line">    OSI7--&gt;OSI6--&gt;OSI5--&gt;OSI4--&gt;OSI3--&gt;OSI2--&gt;OSI1</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  %% TCP/IP 四层模型</span><br><span class="line">  subgraph TCPIP四层模型</span><br><span class="line">    TCP4[&quot;应用层&lt;br&gt;🌐&quot;]:::tcp4</span><br><span class="line">    TCP3[&quot;传输层&lt;br&gt;📦&quot;]:::tcp3</span><br><span class="line">    TCP2[&quot;网络层&lt;br&gt;🌍&quot;]:::tcp2</span><br><span class="line">    TCP1[&quot;链路层&lt;br&gt;🪢&quot;]:::tcp1</span><br><span class="line">    TCP4--&gt;TCP3--&gt;TCP2--&gt;TCP1</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  %% 协议举例</span><br><span class="line">  subgraph 协议</span><br><span class="line">    APP[&quot;HTTP&lt;br&gt;FTP&lt;br&gt;SMTP&lt;br&gt;DNS&lt;br&gt;Telnet&quot;]:::app</span><br><span class="line">    TRANS[&quot;TCP&lt;br&gt;UDP&quot;]:::trans</span><br><span class="line">    NET[&quot;IP&lt;br&gt;ICMP&lt;br&gt;ARP&quot;]:::net</span><br><span class="line">    LINK[&quot;Ethernet&lt;br&gt;PPP&lt;br&gt;Wi-Fi&quot;]:::link</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  %% 对应关系</span><br><span class="line">  TCP4---APP</span><br><span class="line">  OSI7 &amp; OSI6 &amp; OSI5---APP</span><br><span class="line">  TCP3---TRANS</span><br><span class="line">  OSI4---TRANS</span><br><span class="line">  TCP2---NET</span><br><span class="line">  OSI3---NET</span><br><span class="line">  TCP1---LINK</span><br><span class="line">  OSI2 &amp; OSI1---LINK</span><br><span class="line"></span><br><span class="line">  %% 样式</span><br><span class="line">  classDef osi7 fill:#e0e7ff,stroke:#6366f1,stroke-width:2px;</span><br><span class="line">  classDef osi6 fill:#c7d2fe,stroke:#6366f1,stroke-width:2px;</span><br><span class="line">  classDef osi5 fill:#a5b4fc,stroke:#6366f1,stroke-width:2px;</span><br><span class="line">  classDef osi4 fill:#f9fafb,stroke:#6366f1,stroke-width:2px;</span><br><span class="line">  classDef osi3 fill:#a7f3d0,stroke:#059669,stroke-width:2px;</span><br><span class="line">  classDef osi2 fill:#fde68a,stroke:#b45309,stroke-width:2px;</span><br><span class="line">  classDef osi1 fill:#fca5a5,stroke:#b91c1c,stroke-width:2px;</span><br><span class="line">  classDef tcp4 fill:#e0f2fe,stroke:#0ea5e9,stroke-width:2px;</span><br><span class="line">  classDef tcp3 fill:#bae6fd,stroke:#0369a1,stroke-width:2px;</span><br><span class="line">  classDef tcp2 fill:#a7f3d0,stroke:#059669,stroke-width:2px;</span><br><span class="line">  classDef tcp1 fill:#fef9c3,stroke:#ca8a04,stroke-width:2px;</span><br><span class="line">  classDef app fill:#f3e8ff,stroke:#9333ea,stroke-width:2px;</span><br><span class="line">  classDef trans fill:#fef3c7,stroke:#ca8a04,stroke-width:2px;</span><br><span class="line">  classDef net fill:#bbf7d0,stroke:#22d3ee,stroke-width:2px;</span><br><span class="line">  classDef link fill:#fce7f3,stroke:#db2777,stroke-width:2px;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">  HTTP[&quot;🌐 HTTP数据&lt;br&gt;应用层&quot;]:::app</span><br><span class="line">  HTTP--&quot;封装HTTP头部&quot;--&gt;TCP[&quot;📦 TCP报文段&lt;br&gt;传输层&quot;]:::trans</span><br><span class="line">  TCP--&quot;封装TCP头部&quot;--&gt;IP[&quot;🌍 IP数据包&lt;br&gt;网络层&quot;]:::net</span><br><span class="line">  IP--&quot;封装IP头部&quot;--&gt;ETH[&quot;🪢 以太网帧&lt;br&gt;链路层&quot;]:::link</span><br><span class="line">  ETH--&quot;封装MAC帧头部&quot;--&gt;BITS[&quot;⚡ 比特流&lt;br&gt;物理层&quot;]:::phy</span><br><span class="line"></span><br><span class="line">  BITS--&gt;PHYNET[&quot;🌐 物理网络&quot;]:::phy</span><br><span class="line"></span><br><span class="line">  classDef app fill:#e0e7ff,stroke:#6366f1,stroke-width:2px;</span><br><span class="line">  classDef trans fill:#fef3c7,stroke:#ca8a04,stroke-width:2px;</span><br><span class="line">  classDef net fill:#bbf7d0,stroke:#22d3ee,stroke-width:2px;</span><br><span class="line">  classDef link fill:#fce7f3,stroke:#db2777,stroke-width:2px;</span><br><span class="line">  classDef phy fill:#fca5a5,stroke:#b91c1c,stroke-width:2px;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生活案例-11"><a href="#生活案例-11" class="headerlink" title="生活案例"></a>生活案例</h3><p>TCP&#x2F;IP的数据传输就像一次<strong>国际快递</strong>。</p><ul><li><strong>应用层 (HTTP):</strong> 你要寄送的“商品”（比如一部手机）。</li><li><strong>传输层 (TCP):</strong> 你把手机装进一个<strong>带有联系方式的</strong>快递盒。盒子上写着你和收件人的电话（<strong>端口号</strong>），并选择了“顺丰保价”（<strong>TCP</strong>，确保可靠送达）。</li><li><strong>网络层 (IP):</strong> 快递公司在你的盒子上贴上国际运单，上面有收件人的详细家庭地址（<strong>IP地址</strong>）。</li><li><strong>链路层 (MAC):</strong> 本地快递员来取件，他只关心下一站是哪个集散中心（下一个路由器的<strong>MAC地址</strong>），把你的包裹装上他的车。</li><li>整个过程，你的“商品”被一层层地包装起来，这就是<strong>封装（Encapsulation）</strong>。</li></ul><h3 id="真实案例-11"><a href="#真实案例-11" class="headerlink" title="真实案例"></a>真实案例</h3><p>思考一个在线直播应用。它同时需要传输两种数据：</p><ol><li><strong>控制信令：</strong> 你发送的弹幕、点赞、送礼物。这些信息<strong>绝对不能丢失</strong>，必须准确送达。因此，承载这些信令的协议（比如一个自定义协议或HTTP）必须运行在<strong>TCP</strong>之上。</li><li><strong>音视频流：</strong> 直播的画面和声音。这些数据量巨大，更强调<strong>实时性</strong>。偶尔丢掉一两帧画面（表现为轻微卡顿或花屏）是可以接受的，但不能因为重传一个旧数据包而导致整个画面延迟。因此，音视频流数据通常运行在<strong>UDP</strong>之上（使用RTP&#x2F;RTCP等协议）。</li></ol><h3 id="经典问题-12"><a href="#经典问题-12" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>简单说说TCP和UDP的区别以及它们各自的应用场景。</p></blockquote><p>TCP和UDP都位于传输层，但它们的设计哲学和应用场景完全不同。</p><p><strong>核心区别有三点：</strong></p><ol><li><strong>连接性与可靠性：</strong> TCP是<strong>面向连接</strong>的，通信前必须“三次握手”建立连接，它提供<strong>可靠的、有序的</strong>数据传输，保证不丢包、不乱序。而UDP是<strong>无连接</strong>的，它只管发，不保证对方是否收到，是一种“尽力而为”的<strong>不可靠</strong>传输。</li><li><strong>开销与速度：</strong> 因为TCP要维护连接状态、进行确认、重传和拥塞控制，所以它的头部开销大（至少20字节），速度相对较慢。UDP没有这些复杂的机制，头部开销极小（固定8字节），速度非常快。</li><li><strong>数据形态：</strong> TCP提供的是<strong>字节流</strong>服务，数据像水流一样没有边界。UDP提供的是<strong>数据报</strong>服务，发送方发送一个个独立的数据包，接收方也必须按包接收。</li></ol><p><strong>应用场景的选择完全基于这些区别：</strong></p><ul><li><strong>选择TCP的场景：</strong> 凡是要求数据<strong>绝对完整、准确</strong>的应用，都必须使用TCP。例如：<strong>HTTP&#x2F;HTTPS</strong>浏览网页、<strong>FTP</strong>文件传输、<strong>SMTP&#x2F;POP3</strong>电子邮件。</li><li><strong>选择UDP的场景：</strong> 凡是追求<strong>实时性</strong>、能容忍一定丢包率的应用，都适合UDP。例如：<strong>DNS解析</strong>（追求快速响应）、<strong>音视频通话&#x2F;直播</strong>、<strong>在线游戏</strong>的数据同步。</li></ul><h3 id="补充知识-2"><a href="#补充知识-2" class="headerlink" title="补充知识"></a>补充知识</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    %% 配色阶段一：DNS 查询</span><br><span class="line">    rect rgb(237,247,255)</span><br><span class="line">        participant Browser as 浏览器&lt;br/&gt;&amp;#128187;</span><br><span class="line">        participant DNS_Server as DNS服务器&lt;br/&gt;&amp;#128424;</span><br><span class="line">        participant Web_Server as Web服务器&lt;br/&gt;&amp;#128187;</span><br><span class="line">        Note over Browser, DNS_Server: &lt;b&gt;第一步：域名解析（DNS）&lt;/b&gt;</span><br><span class="line">        Browser-&gt;&gt;DNS_Server: 1. 查询域名IP&lt;br/&gt;（www.example.com）</span><br><span class="line">        DNS_Server--&gt;&gt;Browser: 2. 返回IP地址&lt;br/&gt;（93.184.216.34）</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 配色阶段二：TCP连接（三次握手）</span><br><span class="line">    rect rgb(230,255,239)</span><br><span class="line">        Note over Browser, Web_Server: &lt;b&gt;第二步：建立TCP连接（三次握手）&lt;/b&gt;</span><br><span class="line">        Browser-&gt;&gt;Web_Server: 3. SYN（请求建立连接）</span><br><span class="line">        Web_Server--&gt;&gt;Browser: 4. SYN, ACK（确认+回应请求）</span><br><span class="line">        Browser-&gt;&gt;Web_Server: 5. ACK（连接建立完成）</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 配色阶段三：HTTP/HTTPS请求</span><br><span class="line">    rect rgb(255,248,225)</span><br><span class="line">        Note over Browser, Web_Server: &lt;b&gt;第三步：发送HTTP请求/响应&lt;/b&gt;</span><br><span class="line">        Browser-&gt;&gt;Web_Server: 6. 发送HTTP请求&lt;br/&gt;（如GET /index.html）</span><br><span class="line">        Web_Server--&gt;&gt;Browser: 7. 返回HTTP响应&lt;br/&gt;（如200 OK，网页内容）</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 可选阶段：关闭连接</span><br><span class="line">    rect rgb(245,245,245)</span><br><span class="line">        Note over Browser, Web_Server: &lt;b&gt;第四步：关闭TCP连接（四次挥手）&lt;/b&gt;</span><br><span class="line">        Browser-&gt;&gt;Web_Server: 8. FIN（请求断开连接）</span><br><span class="line">        Web_Server--&gt;&gt;Browser: 9. ACK（确认收到断开请求）</span><br><span class="line">        Web_Server-&gt;&gt;Browser: 10. FIN（服务器断开）</span><br><span class="line">        Browser--&gt;&gt;Web_Server: 11. ACK（断开完成）</span><br><span class="line">    end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>DNS是互联网的基石服务。不理解DNS，你甚至不知道请求该发往何处。它是所有网络请求的第一步。</p><ol><li><strong>缓存是关键：</strong> 为了性能，DNS查询结果会被层层缓存，顺序是：<strong>浏览器缓存 -&gt; 操作系统缓存 -&gt; 路由器缓存 -&gt; 本地DNS服务器缓存</strong>。这极大地减少了对根DNS服务器的请求压力。</li><li><strong>记录类型多样化：</strong> 除了将域名指向IPv4地址的A记录，还有指向IPv6的AAAA记录，定义别名的CNAME记录，以及邮件服务器的MX记录等。</li><li><strong>智能DNS与负载均衡：</strong> 现代DNS服务（如CDN服务商提供的GeoDNS）能识别用户的地理位置，返回离他最近的服务器IP地址，这是实现CDN内容就近分发和全局负载均衡的核心技术。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    subgraph DNS查询流程</span><br><span class="line">        direction TB</span><br><span class="line">        A[&quot;fa:fa-chrome 浏览器&quot;]</span><br><span class="line">        B&#123;&#123;&quot;fa:fa-database 本地缓存有吗?&quot;&#125;&#125;</span><br><span class="line">        C[&quot;fa:fa-arrow-rotate-left 直接返回IP&quot;]</span><br><span class="line">        D[&quot;fa:fa-network-wired 本地DNS服务器&quot;]</span><br><span class="line">        E[&quot;fa:fa-globe 根DNS服务器&quot;]</span><br><span class="line">        F[&quot;fa:fa-layer-group .com顶级域DNS&quot;]</span><br><span class="line">        G[&quot;fa:fa-server 权威DNS example.com&quot;]</span><br><span class="line"></span><br><span class="line">        %% 主流程</span><br><span class="line">        A -- &quot;1. 查缓存&quot; --&gt; B</span><br><span class="line">        B -- &quot;有&quot; --&gt; C</span><br><span class="line">        C -- &quot;返回IP&quot; --&gt; A</span><br><span class="line">        B -- &quot;没有&quot; --&gt; D</span><br><span class="line">        D -- &quot;2. 递归/迭代查询&quot; --&gt; E</span><br><span class="line">        E --&gt; F</span><br><span class="line">        F --&gt; G</span><br><span class="line">        G -- &quot;IP地址&quot; --&gt; D</span><br><span class="line">        D -- &quot;缓存结果并返回&quot; --&gt; A</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 节点配色，兼容性极佳</span><br><span class="line">    style A fill:#e8f4fd,stroke:#1976d2,stroke-width:2px</span><br><span class="line">    style B fill:#fff6db,stroke:#e6a500,stroke-width:2px</span><br><span class="line">    style C fill:#d9f9e5,stroke:#21a366,stroke-width:2px</span><br><span class="line">    style D fill:#f3e8fd,stroke:#9c27b0,stroke-width:2px</span><br><span class="line">    style E fill:#ffe5f1,stroke:#d81b60,stroke-width:2px</span><br><span class="line">    style F fill:#fef6e0,stroke:#ff9800,stroke-width:2px</span><br><span class="line">    style G fill:#ffecec,stroke:#d72638,stroke-width:2px</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>面试题:  除了A记录，你还知道哪些常见的DNS记录类型，它们分别有什么作用？</p></blockquote><p>除了最常见的、将域名映射到IPv4地址的<strong>A记录</strong>外，我还了解以下几种关键的DNS记录：</p><ul><li><strong>AAAA记录：</strong> 功能与A记录类似，但用于将域名映射到<strong>IPv6地址</strong>，是IPv6时代的基础。</li><li><strong>CNAME记录（别名记录）：</strong> 允许将一个域名指向另一个域名。比如，我可以把blog.example.com的CNAME记录指向user.github.io，这样访问我的博客就会被解析到GitHub Pages的服务。它常用于CDN加速，将用户域名指向CDN服务商的域名。</li><li><strong>MX记录（邮件交换记录）：</strong> 指向负责处理该域电子邮件的服务器。比如example.com的MX记录会指向mail.example.com，这样发往<a href="mailto:&#x78;&#120;&#120;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;">xxx@example.com</a>的邮件才知道该送往哪里。</li><li><strong>NS记录（域名服务器记录）：</strong> 指定了哪个DNS服务器是该域的权威服务器，负责该域的解析。</li></ul><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    %% 阶段一：客户端发起 SYN</span><br><span class="line">    rect rgb(220,245,255)</span><br><span class="line">        participant Client as 🧑‍💻 客户端&lt;br/&gt;Client</span><br><span class="line">        participant Server as 🖥️ 服务器&lt;br/&gt;Server</span><br><span class="line">        Client-&gt;&gt;Server: 1. SYN (seq=x, 源端口/目标端口)</span><br><span class="line">        Note over Client,Server: 请求建立连接&lt;br/&gt;SYN=1, ISN=x&lt;br/&gt;“我想建立连接, 我的初始序列号是x”</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 阶段二：服务器响应 SYN, ACK</span><br><span class="line">    rect rgb(228,255,237)</span><br><span class="line">        Server--&gt;&gt;Client: 2. SYN, ACK (seq=y, ack=x+1)</span><br><span class="line">        Note over Client,Server: 同意连接，确认收到SYN&lt;br/&gt;SYN=1, ACK=1, ISN=y, ACK=x+1&lt;br/&gt;“我的初始序列号是y, 我确认收到了你的x”</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 阶段三：客户端确认 ACK</span><br><span class="line">    rect rgb(255,249,220)</span><br><span class="line">        Client-&gt;&gt;Server: 3. ACK (seq=x+1, ack=y+1)</span><br><span class="line">        Note over Client,Server: 确认收到SYN和ACK&lt;br/&gt;ACK=1, seq=x+1, ack=y+1&lt;br/&gt;“我确认收到了你的y, 连接建立”</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 阶段四：连接建立后，传输数据</span><br><span class="line">    rect rgb(237,245,255)</span><br><span class="line">        Client-&gt;&gt;Server: 4. 数据传输（如GET请求）</span><br><span class="line">        Server--&gt;&gt;Client: 5. 数据响应（如HTTP响应）</span><br><span class="line">        Note over Client,Server: 连接已建立，可以开始数据通信</span><br><span class="line">    end</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>面试题:  为什么TCP建立连接需要三次握手，而不是两次或者四次？</p></blockquote><p>这个问题核心在于理解TCP作为<strong>全双工、可靠通信</strong>协议的本质。</p><ul><li><strong>不能是两次的原因：</strong> 无法防止历史的、已失效的连接请求报文突然又传送到了服务器，从而引发错误。如果只有两次握手，服务器收到一个旧的SYN包就会立即建立连接并等待客户端数据，这将浪费服务器资源。而三次握手时，客户端不会对旧连接的SYN+ACK进行确认，服务器收不到ACK就不会建立连接。更关键的是，两次握手无法让双方都确认对方的接收和发送能力都正常。</li><li><strong>不需要四次的原因：</strong> 三次握手已经足够验证双方的收发能力并同步初始序列号了。服务器的确认（ACK）和同步请求（SYN）可以在第二步中合并为一个报文（SYN+ACK）发送，没有必要拆成两次。因此，四次握手虽然也能工作，但效率不如三次。</li></ul><p>总结来说，<strong>三次握手是保证双方建立可靠连接所需的最少步骤。</strong></p><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><ul><li><strong>IPv4地址耗尽：</strong> 32位的IPv4地址空间（约43亿个）已经完全耗尽，这是向IPv6迁移的根本动力。</li><li><strong>IPv6的优势：</strong> 128位的IPv6提供了近乎无限的地址空间，彻底解决了地址短缺问题。同时，它简化了报文头部，提高了路由效率，并且原生支持IPSec，安全性更好。</li><li><strong>NAT的角色：</strong> 了解IPv4时代广泛使用的NAT（网络地址转换）技术，它虽然缓解了地址不足，但也破坏了IP的端到端通信模型，给一些P2P应用带来了麻烦。</li></ul><h4 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h4><p><strong>在应用层重新实现了一个更智能、更适合现代网络的“TCP”</strong>,它之所以能做到这一点，主要依靠三大核心武器：<strong>流（Stream）、0-RTT&#x2F;1-RTT握手、以及连接迁移</strong>。</p><ul><li><p>基于“流”的多路复用，彻底消灭队头阻塞</p><ul><li><p><strong>TCP的问题（传输层队头阻塞）：</strong><br>想象一下TCP连接是一条<strong>单车道的高速公路</strong>。所有的数据包（HTTP请求1、请求2、图片数据等）都必须在这条单车道上排队行驶。如果其中一辆车（一个数据包）在路上抛锚了（网络丢包），后面的所有车都得堵着，等待这辆车被拖走（TCP重传机制）。这就是<strong>传输层的队头阻塞（Head-of-Line Blocking）</strong>。即使HTTP&#x2F;2在应用层实现了多路复用，但它仍然跑在TCP上，这条高速公路还是单车道，堵车问题依旧存在。</p></li><li><p><strong>QUIC的解决方案（在连接内部开辟多条车道）：</strong><br>QUIC依然是建立一个连接，但它在这条连接内部，开辟了<strong>多条逻辑上独立的“流”（Stream）</strong>。每个HTTP请求-响应对（比如一个HTML请求，一个CSS请求）都跑在自己专属的流里。</p><p>现在，如果承载CSS的那个流里的一个数据包丢失了，它<strong>只会阻塞CSS流自己</strong>。承载HTML和图片的流完全不受影响，它们的数据包会绕过这个“事故点”，继续被处理和交付</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    %% --- TCP 部分 ---</span><br><span class="line">    subgraph TCP [TCP 传输层 - 队头阻塞]</span><br><span class="line">        direction LR</span><br><span class="line">        P1[&quot;fa:fa-html5 包1: HTML&quot;]</span><br><span class="line">        P2[&quot;fa:fa-css3-alt 包2: CSS&quot;]</span><br><span class="line">        P3_lost[&quot;fa:fa-css3-alt 包3: CSS 丢失!&quot;]</span><br><span class="line">        P4[&quot;fa:fa-js 包4: JS (必须等待丢失包重传)&quot;]</span><br><span class="line"></span><br><span class="line">        P1 --&gt; P2 --&gt; P3_lost -- X --&gt; P4</span><br><span class="line"></span><br><span class="line">        style P3_lost fill:#ffbcbc,stroke:#c0392b,stroke-width:2px</span><br><span class="line">        style TCP fill:#e7f1fb,stroke:#3498db,stroke-width:3px</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% --- QUIC 部分 ---</span><br><span class="line">    subgraph QUIC [QUIC 多流 无队头阻塞]</span><br><span class="line">        direction LR</span><br><span class="line">        Q1[&quot;fa:fa-html5 流1: HTML 包1 (可立即处理)&quot;]</span><br><span class="line">        Q2[&quot;fa:fa-css3-alt 流2: CSS 包2&quot;]</span><br><span class="line">        Q3_lost[&quot;fa:fa-css3-alt 流2: CSS 包3 丢失!&quot;]</span><br><span class="line">        Q4[&quot;fa:fa-js 流3: JS 包4 (可立即处理)&quot;]</span><br><span class="line"></span><br><span class="line">        Q2 --&gt; Q3_lost</span><br><span class="line"></span><br><span class="line">        style Q3_lost fill:#ffbcbc,stroke:#c0392b,stroke-width:2px</span><br><span class="line">        style QUIC fill:#e8fbe7,stroke:#27ae60,stroke-width:3px</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% --- 节点配色 ---</span><br><span class="line">    classDef html fill:#e3f2fd,stroke:#1976d2;</span><br><span class="line">    classDef css fill:#f9fbe7,stroke:#009688;</span><br><span class="line">    classDef js fill:#fff8e1,stroke:#ffa000;</span><br><span class="line"></span><br><span class="line">    class P1,Q1 html;</span><br><span class="line">    class P2,Q2,Q3_lost css;</span><br><span class="line">    class P4,Q4 js;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>0-RTT&#x2F;1-RTT快速握手，抢占先机</p><ul><li><p><strong>TCP+TLS的问题：握手延迟高</strong></p><ul><li>一个普通的HTTPS连接建立需要：<ol><li>TCP三次握手（耗时1个RTT）</li><li>TLS握手（通常是1-2个RTT）</li></ol></li><li>加起来总共需要<strong>2-3个RTT</strong>才能开始发送第一个HTTP请求数据，这在移动网络环境下延迟非常明显。</li></ul></li><li><p><strong>QUIC的解决方案：集成的加密和传输握手</strong><br>QUIC把“我是谁”（加密认证）和“怎么通信”（传输控制）这两件事合并在一起做了。</p><p><strong>首次连接 (1-RTT)：</strong> 客户端和服务器在第一个RTT内就能完成所有必要的加密和传输参数交换，之后立刻可以开始发送应用数据。</p><p><strong>恢复连接 (0-RTT - 这是真正的黑魔法)：</strong> 如果客户端之前访问过这个服务器，服务器会给它一个“凭证”。下次再访问时，客户端可以在<strong>第一个发送的数据包里就带上这个凭证和加密后的HTTP请求</strong>。服务器验证凭证后，无需任何等待，直接处理请求并返回数据。实现了真正的“零延迟”连接建立。</p></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    autonumber</span><br><span class="line"></span><br><span class="line">    %% --- TCP + TLS (3 RTT) ---</span><br><span class="line">    participant C1 as 🧑‍💻 Client</span><br><span class="line">    participant S1 as 🖥️ Server</span><br><span class="line"></span><br><span class="line">    C1-&gt;&gt;S1: TCP SYN</span><br><span class="line">    S1--&gt;&gt;C1: TCP SYN ACK</span><br><span class="line">    C1-&gt;&gt;S1: TCP ACK (TCP established)</span><br><span class="line">    Note over C1,S1: RTT 1 (TCP Handshake)</span><br><span class="line">    C1-&gt;&gt;S1: TLS ClientHello</span><br><span class="line">    S1--&gt;&gt;C1: TLS ServerHello, Certificate</span><br><span class="line">    S1--&gt;&gt;C1: TLS Finished</span><br><span class="line">    Note over C1,S1: RTT 2 (TLS Handshake)</span><br><span class="line">    C1-&gt;&gt;S1: TLS Finished</span><br><span class="line">    C1-&gt;&gt;S1: HTTP Data</span><br><span class="line">    Note over C1,S1: RTT 3 (HTTP can be sent)</span><br><span class="line"></span><br><span class="line">    %% --- QUIC (1 RTT) ---</span><br><span class="line">    participant C2 as 🧑‍💻 Client2</span><br><span class="line">    participant S2 as 🖥️ Server2</span><br><span class="line"></span><br><span class="line">    C2-&gt;&gt;S2: QUIC Initial (with TLS info)</span><br><span class="line">    S2--&gt;&gt;C2: QUIC Initial and Handshake (key agreement)</span><br><span class="line">    C2-&gt;&gt;S2: HTTP Data</span><br><span class="line">    Note over C2,S2: RTT 1 (HTTP can be sent)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>连接迁移，无缝切换网络<ul><li><strong>TCP的问题：连接与IP地址强绑定</strong><br>TCP连接由一个四元组定义：(源IP, 源端口, 目标IP, 目标端口)。当你的手机从Wi-Fi切换到4G网络时，你的<strong>源IP地址变了</strong>，这个四元组就失效了，<strong>TCP连接会立刻中断</strong>。所有正在进行中的下载、上传、网页加载都必须重新开始。</li><li><strong>QUIC的解决方案：基于连接ID（Connection ID）</strong><br>QUIC连接不依赖于IP地址，而是由一个64位的<strong>连接ID</strong>来唯一标识。只要这个ID不变，无论你的手机IP地址和端口怎么变，QUIC连接都能继续保持。它会无缝地将数据包从旧地址迁移到新地址上，应用层完全无感。</li><li><strong>生活中的比喻：</strong><ul><li><strong>TCP连接</strong>就像你家的<strong>座机电话</strong>，它绑定在你家的物理地址上，你一出门，电话就断了。</li><li><strong>QUIC连接</strong>就像你的<strong>手机</strong>，它绑定在你的手机号（连接ID）上，无论你是在家、在公司还是在地铁上，电话都能一直保持通话。</li></ul></li></ul></li></ul><h2 id="Http的安全问题"><a href="#Http的安全问题" class="headerlink" title="Http的安全问题"></a>Http的安全问题</h2><p><img src="https://img.996007.icu/file/1752720583236_mermaid-ai-diagram-2025-07-17-024905.png" alt="mermaid-ai-diagram-2025-07-17-024905"></p><p>《图解HTTP》和《权威指南》都明确指出了HTTP协议在设计之初，并未过多考虑安全问题，其核心缺陷主要有三点：</p><ol><li><strong>通信使用明文，内容可能被窃听：</strong> HTTP报文在网络中以纯文本的形式传输，任何在传输路径上的节点（如路由器、网络运营商、黑客）都可以轻易地截获并查看通信内容，包括用户名、密码、信用卡号等敏感信息。</li><li><strong>不验证通信方身份，可能遭遇伪装：</strong> HTTP协议本身无法验证客户端和服务器的真实身份。你以为你在访问银行网站，但实际上可能连接到了一个精心伪装的“钓鱼”网站。反之，服务器也无法确定请求是否真的来自一个合法的用户。</li><li><strong>无法证明报文的完整性，可能遭篡改：</strong> HTTP协议没有提供校验机制来确保报文在传输过程中未被修改。攻击者可以在中途拦截报文，篡改内容（比如在网页中植入恶意广告或脚本），而接收方对此一无所知。这种攻击被称为<strong>中间人攻击（Man-in-the-Middle, MITM）</strong>。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant C as 客户端</span><br><span class="line">    participant M as 中间人攻击者</span><br><span class="line">    participant S as 真实服务器</span><br><span class="line"></span><br><span class="line">    C-&gt;&gt;M: HTTP请求 (发往S)</span><br><span class="line">    Note over C,M: &lt;b&gt;1. 窃听:&lt;/b&gt; 中间人截获了明文请求</span><br><span class="line">    </span><br><span class="line">    M-&gt;&gt;S: 转发/篡改后的请求</span><br><span class="line">    Note over S,M: S以为请求来自C (&lt;b&gt;2. 伪装&lt;/b&gt;)</span><br><span class="line">    </span><br><span class="line">    S--&gt;&gt;M: HTTP响应</span><br><span class="line">    Note over M,C: &lt;b&gt;3. 篡改:&lt;/b&gt; 中间人修改响应内容</span><br><span class="line">    </span><br><span class="line">    M--&gt;&gt;C: 返回篡改后的响应</span><br><span class="line">    Note over C: C以为响应来自S, 未察觉内容被修改</span><br></pre></td></tr></table></figure><h3 id="生活案例-12"><a href="#生活案例-12" class="headerlink" title="生活案例"></a>生活案例</h3><p>使用HTTP通信<strong>就像是在公共场合用</strong>明信片**写信和收信。</p><ul><li><strong>明文传输&#x2F;窃听：</strong> 任何人（邮递员、邻居）在传递过程中都可以看到明信片上写了什么。</li><li><strong>不验证身份&#x2F;伪装：</strong> 你收到一张署名“你妈妈”的明信片，但你没法确定这真是你妈妈写的，可能是骗子冒充的。</li><li><strong>不保完整&#x2F;篡改：</strong> 有人在你的明信片上用涂改液改了几个字，你收到后也无法发现。</li></ul><h3 id="真实案例-12"><a href="#真实案例-12" class="headerlink" title="真实案例"></a>真实案例</h3><ul><li>最典型的案例就是<strong>公共Wi-Fi陷阱</strong>。当你在咖啡馆连接一个不安全的免费Wi-Fi时，这个Wi-Fi的提供者（可能是个黑客）就处在了你的通信链路上，成为了一个“中间人”。</li><li>如果你此时访问一个HTTP的网站并输入密码，黑客可以<strong>直接看到</strong>你的密码。</li><li>黑客还可以将你访问的HTTP网站<strong>重定向</strong>到一个他制作的假冒网站，骗取你的信任和信息。</li><li>他甚至可以在你正常浏览的HTTP网页中，<strong>动态注入</strong>恶意JavaScript脚本，来窃取你的其他信息。</li><li>而如果网站使用了HTTPS，上述所有攻击都将因为无法解密通信内容和伪造证书而失效。</li></ul><h3 id="经典问题-13"><a href="#经典问题-13" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>为什么说HTTP是“不安全”的？请从协议层面具体说明其存在的主要风险。</p></blockquote><p>HTTP协议在设计之初主要目标是高效地传输超文本，因此并未内置安全机制，这使其在今天的互联网环境中存在三大核心风险，通常被称为“不安全”：</p><ol><li><strong>明文传输导致窃听风险：</strong> HTTP报文在网络上是以纯文本形式传输的，没有进行任何加密。这意味着在请求从客户端到服务器的整个传输路径上，任何一个中间节点（如路由器、恶意网关、网络嗅探工具）都能轻易地截获并直接读取通信的全部内容，包括像密码、支付信息这样的敏感数据。</li><li><strong>缺少身份验证导致伪装风险：</strong> HTTP协议本身无法验证通信双方的身份。客户端无法确认它正在对话的服务器就是它声称的那个服务器，这为“钓鱼网站”等中间人攻击提供了可能。同样，服务器也无法确认请求方的真实身份，这使得它容易受到恶意请求的攻击。</li><li><strong>缺乏完整性校验导致篡改风险：</strong> HTTP没有机制来保证报文在传输过程中不被修改。攻击者可以在中间环节拦截报文，任意篡改其内容（比如植入广告、病毒或恶意代码），然后再转发给接收方。由于没有校验机制，接收方无法察觉到报文已经被篡改，从而可能造成严重后果。</li></ol><p>这三个根本性的缺陷——<strong>窃听、伪装、篡改</strong>——使得HTTP在处理任何涉及隐私、交易或需要信任的场景时都是完全不可靠的。而HTTPS正是为了解决这三大问题而诞生的。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p><strong>HTTPS不是一个新协议。</strong> 它的全称是“HTTP over SSL&#x2F;TLS”。它并不是在HTTP基础上修改，而是在HTTP和TCP之间增加了一个<strong>安全层（SSL&#x2F;TLS）</strong>。</p><p>这个安全层提供了三大核心能力，正好对应了HTTP的三大缺陷：</p><ol><li><strong>内容加密：</strong> 通过<strong>混合加密</strong>算法，将HTTP报文加密成密文传输，解决了<strong>窃听</strong>问题。</li><li><strong>身份认证：</strong> 通过<strong>数字证书（CA体系）</strong>，验证服务器的身份，解决了<strong>伪装</strong>问题。</li><li><strong>数据完整性：</strong> 通过<strong>报文摘要（MAC）</strong>，确保数据在传输过程中未被篡改，解决了<strong>篡改</strong>问题。</li></ol><p><strong>SSL已死，TLS当立：</strong> 严格来说，SSL（Secure Sockets Layer）的所有版本都已因安全漏洞被废弃。现在我们使用的协议是其继任者<strong>TLS（Transport Layer Security）</strong>。目前业界主流是 <strong>TLS 1.2</strong>，而 <strong>TLS 1.3</strong> 因为其更高的性能和更强的安全性，正在迅速普及。面试时，能清晰说出TLS 1.2和1.3握手过程的区别，是巨大的加分项。</p><p><strong>握手的核心目标：</strong> 不要陷入繁杂的步骤细节。TLS握手的核心目标只有<strong>两个</strong>：</p><ol><li><strong>安全地协商出会话密钥：</strong> 客户端和服务器需要商定一个<strong>对称加密</strong>的密钥，用于后续的HTTP报文加密。这个协商过程本身必须是安全的，不能被中间人窃听和篡改。</li><li><strong>验证服务器身份：</strong> 客户端必须确认它正在与之通信的服务器是它声称的那个，而不是一个冒牌货。</li></ol><p><strong>混合加密：</strong> 为什么不直接用非对称加密传数据？因为<strong>非对称加密非常慢</strong>，只适合加密少量数据。而<strong>对称加密快得多</strong>，适合加密大量数据。所以TLS采用了<strong>混合加密</strong>的策略：用<strong>非对称加密</strong>来安全地交换<strong>对称加密的密钥</strong>，然后用这个对称密钥来加密真正的HTTP报文。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    autonumber</span><br><span class="line">    participant C as 客户端</span><br><span class="line">    participant S as 服务器</span><br><span class="line"></span><br><span class="line">    C-&gt;&gt;S: SYN</span><br><span class="line">    S--&gt;&gt;C: SYN, ACK</span><br><span class="line">    C-&gt;&gt;S: ACK</span><br><span class="line"></span><br><span class="line">    Note over C,S: TLS 1.2 握手开始 (2个RTT)</span><br><span class="line"></span><br><span class="line">    C-&gt;&gt;S: 1. ClientHello (支持的加密套件, 随机数C)</span><br><span class="line">    S--&gt;&gt;C: 2. ServerHello (选定的加密套件, 随机数S)</span><br><span class="line">    S--&gt;&gt;C: 3. Certificate (服务器的数字证书)</span><br><span class="line">    S--&gt;&gt;C: 4. ServerHelloDone</span><br><span class="line"></span><br><span class="line">    Note right of C: (客户端验证证书)</span><br><span class="line"></span><br><span class="line">    C-&gt;&gt;S: 5. ClientKeyExchange (用证书公钥加密的预主密钥)</span><br><span class="line">    C-&gt;&gt;S: 6. ChangeCipherSpec</span><br><span class="line">    C-&gt;&gt;S: 7. Finished (加密后的握手摘要)</span><br><span class="line"></span><br><span class="line">    S--&gt;&gt;C: 8. ChangeCipherSpec</span><br><span class="line">    S--&gt;&gt;C: 9. Finished (加密后的握手摘要)</span><br><span class="line"></span><br><span class="line">    Note over C,S: 握手结束,双方已安全地生成了会话密钥</span><br><span class="line"></span><br><span class="line">    C-&gt;&gt;S: 加密的HTTP请求</span><br><span class="line">    S--&gt;&gt;C: 加密的HTTP响应</span><br></pre></td></tr></table></figure><h3 id="生活案例-13"><a href="#生活案例-13" class="headerlink" title="生活案例"></a>生活案例</h3><p>HTTPS握手就像一次高度机密的<strong>线下交易</strong>。</p><ul><li><strong>ClientHello:</strong> 你（客户端）对卖家（服务器）说：“我们来交易吧！我懂得用A、B、C三种暗号（加密套件）。”</li><li><strong>ServerHello &amp; Certificate:</strong> 卖家说：“好的，我们就用A暗号吧。这是我的<strong>身份证和营业执照</strong>（数字证书），由工商局（CA）颁发，你可以去验证真伪。”</li><li><strong>客户端验证证书 &amp; ClientKeyExchange:</strong> 你打电话给工商局验证了执照是真的。然后你把交易的**接头暗语（预主密钥）<strong>写在一张纸条上，放进一个只有卖家用他私钥才能打开的</strong>保险箱（证书公钥加密）**里，交给了卖家。</li><li><strong>双方生成会话密钥 &amp; Finished:</strong> 卖家用私钥打开保险箱，拿到接头暗语。现在，你们双方都用这个暗语推算出了今天交易用的<strong>最终密码本（会话密钥）</strong>。为了确认无误，你们各自把之前的对话内容用这个密码本加密算了个摘要，发给对方验证。</li><li><strong>加密通信：</strong> 验证通过，交易正式开始。你们所有的对话（HTTP报文）都用这个最终密码本加密。</li></ul><h3 id="经典问题-14"><a href="#经典问题-14" class="headerlink" title="经典问题"></a>经典问题</h3><blockquote><p>请简述一下HTTPS的握手过程。TLS 1.3相比于1.2做了哪些核心优化？</p></blockquote><p>HTTPS的核心是其底层的TLS握手过程。我以目前最主流的TLS 1.2为例，其握手过程可以概括为以下几个核心步骤，主要目的是<strong>安全地协商会话密钥</strong>并<strong>验证服务器身份</strong>。</p><p><strong>TLS 1.2 握手流程 (简化版):</strong></p><ol><li><strong>客户端问候 (ClientHello):</strong> 客户端向服务器发送它支持的TLS版本、一组加密套件（包含密钥交换算法、对称加密算法、MAC算法）和一个随机数。</li><li><strong>服务器响应 (ServerHello &amp; Certificate):</strong> 服务器从客户端的加密套件中选择一个双方都支持的，并返回给客户端。同时，服务器会将其<strong>数字证书</strong>和另一个随机数一并发送给客户端。</li><li><strong>客户端验证与密钥交换:</strong><ul><li>客户端首先验证服务器证书的有效性，包括检查签发机构是否受信任、是否过期、域名是否匹配等。</li><li>验证通过后，客户端生成一个**“预主密钥”(Pre-Master Secret)<strong>，然后用证书中的</strong>公钥**对其进行加密，并通过ClientKeyExchange消息发送给服务器。</li></ul></li><li><strong>生成会话密钥与结束:</strong><ul><li>服务器用自己的<strong>私钥</strong>解密ClientKeyExchange消息，获取到预主密钥。</li><li>现在，客户端和服务器都拥有了三个相同的输入：客户端随机数、服务器随机数、预主密钥。它们各自使用相同的算法，将这三个输入混合生成最终的<strong>会话密钥（对称密钥）</strong>。</li><li>最后，双方互发一个Finished消息，将之前所有握手报文的摘要用这个刚生成的会话密钥加密后发送给对方，以验证握手过程没有被篡改。</li></ul></li></ol><p><strong>TLS 1.3 的核心优化：</strong><br>TLS 1.3 对这个过程进行了大刀阔斧的简化，主要目标就是<strong>提升性能和安全性</strong>：</p><ol><li><strong>减少RTT：</strong> TLS 1.3的握手过程从2个RTT（往返时延）缩减到了<strong>1个RTT</strong>。它在ClientHello时就会猜测服务器可能支持的加密参数并发过去，服务器在ServerHello中一次性返回所有需要的信息，大大缩短了连接建立时间。</li><li><strong>更安全的加密套件：</strong> 废除了所有不安全的、过时的加密算法（如RC4, MD5）和密钥交换方式（如静态RSA），只保留了少数几个安全性极高的算法。</li><li><strong>0-RTT模式：</strong> 对于恢复连接，TLS 1.3引入了0-RTT模式，允许客户端在第一个包中就带上加密的应用数据，实现了零延迟的连接恢复，这对于API调用和移动端应用是巨大的性能提升。</li></ol><h2 id="Web攻击"><a href="#Web攻击" class="headerlink" title="Web攻击"></a>Web攻击</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[常见Web攻击] --&gt; B[注入型攻击]</span><br><span class="line">    B --&gt; B1[SQL注入]</span><br><span class="line">    B1 --&gt; B1a[攻击点: 后端数据库查询]</span><br><span class="line">    B1 --&gt; B1b[防御: 参数化查询]</span><br><span class="line">    B --&gt; B2[OS命令注入]</span><br><span class="line">    B2 --&gt; B2a[攻击点: 调用系统命令]</span><br><span class="line">    B2 --&gt; B2b[防御: 严格过滤用户输入]</span><br><span class="line"></span><br><span class="line">    A --&gt; C[跨站攻击]</span><br><span class="line">    C --&gt; C1[跨站脚本]</span><br><span class="line">    C1 --&gt; C1a[攻击点: 浏览器渲染HTML]</span><br><span class="line">    C1 --&gt; C1b[防御: 输入过滤]</span><br><span class="line">    C --&gt; C2[跨站请求伪造]</span><br><span class="line">    C2 --&gt; C2a[攻击点: 浏览器携带Cookie]</span><br><span class="line">    C2 --&gt; C2b[防御: SameSite Cookie]</span><br><span class="line"></span><br><span class="line">    A --&gt; D[会话管理攻击]</span><br><span class="line">    D --&gt; D1[会话劫持]</span><br><span class="line">    D1 --&gt; D1a[攻击点: 窃取会话ID]</span><br><span class="line">    D1 --&gt; D1b[防御: HTTPS, HttpOnly Cookie]</span><br><span class="line">    D --&gt; D2[会话固定]</span><br><span class="line">    D2 --&gt; D2a[攻击点: 强行指定会话ID]</span><br><span class="line">    D2 --&gt; D2b[防御: 登录后立即重置Session ID]</span><br></pre></td></tr></table></figure><h3 id="跨站脚本攻击-XSS"><a href="#跨站脚本攻击-XSS" class="headerlink" title="跨站脚本攻击(XSS)"></a>跨站脚本攻击(XSS)</h3><p><strong>核心思想：</strong> XSS的本质是“<strong>恶意代码注入</strong>”。攻击者设法将恶意的HTML或JavaScript代码，注入到一个受信任的网站中。当其他用户访问这个网站时，这些恶意代码就会在用户的<strong>浏览器</strong>中被执行，从而达到窃取信息、破坏页面的目的。</p><p><strong>攻击对象：</strong> XSS攻击的目标是<strong>用户（的浏览器）</strong>，而不是服务器本身。它利用的是网站对用户的<strong>信任</strong>。</p><p><strong>分类：</strong></p><ol><li><strong>存储型XSS (Stored XSS):</strong> 最危险的一种。恶意代码被<strong>存储在服务器的数据库</strong>中（比如一篇包含<script>标签的博客文章）。每个访问这个页面的用户都会被攻击。</li><li><strong>反射型XSS (Reflected XSS):</strong> 恶意代码存在于<strong>URL</strong>中。攻击者需要诱骗用户点击一个构造好的恶意链接，服务器从URL中获取数据并<strong>不加过滤地</strong>在页面上“反射”出来，导致脚本执行。</li><li><strong>DOM型XSS (DOM-based XSS):</strong> 一种特殊的反射型XSS，其攻击的触发完全在<strong>客户端</strong>发生。恶意代码在URL中，但服务器并未参与，是客户端的JavaScript代码在处理URL时，不慎将恶意代码执行了。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Attacker as 攻击者</span><br><span class="line">    participant Server as 易受攻击的网站 (如: 博客)</span><br><span class="line">    participant Victim as 普通用户</span><br><span class="line">    </span><br><span class="line">    Attacker-&gt;&gt;Server: 1. 发布一篇包含恶意脚本的文章&lt;br&gt;内容: &quot;文章内容...&lt;script&gt;steal_cookie()&lt;/script&gt;&quot;</span><br><span class="line">    Note over Server: 服务器将恶意内容&lt;br&gt;存储到数据库</span><br><span class="line">    </span><br><span class="line">    Victim-&gt;&gt;Server: 2. 请求浏览这篇文章</span><br><span class="line">    Server--&gt;&gt;Victim: 3. 返回包含恶意脚本的HTML页面</span><br><span class="line">    </span><br><span class="line">    Note over Victim: 浏览器解析HTML...</span><br><span class="line">    Victim-&gt;&gt;Victim: 4. &lt;b&gt;执行了恶意脚本!&lt;/b&gt;&lt;br&gt;steal_cookie()函数被调用</span><br><span class="line">    Victim--&gt;&gt;Attacker: 5. 用户的Cookie被发送到攻击者服务器</span><br></pre></td></tr></table></figure><h4 id="生活案例-14"><a href="#生活案例-14" class="headerlink" title="生活案例"></a>生活案例</h4><p>XSS攻击就像是在一个公共的<strong>留言板</strong>上搞破坏。</p><ul><li>你（<strong>攻击者</strong>）没有直接去砸留言板（服务器），而是用一种<strong>隐形墨水</strong>（恶意脚本）在上面写了一句咒语：“凡看到此留言者，钱包自动交给我。”</li><li>当其他路人（<strong>受害者</strong>）过来看留言时，这条用隐形墨水写的咒语在他们眼里突然显形并生效（<strong>浏览器执行脚本</strong>），结果他们的钱包（<strong>Cookie</strong>）就都飞到了你的口袋里。</li></ul><h4 id="经典问题-15"><a href="#经典问题-15" class="headerlink" title="经典问题"></a>经典问题</h4><blockquote><p> 什么是XSS攻击？如何有效防御？</p></blockquote><p>XSS，即跨站脚本攻击，其核心是攻击者将恶意脚本注入到受信任的网页中，当其他用户浏览该网页时，这些脚本在用户的浏览器端被执行，从而窃取用户信息（如Cookie）、或进行其他恶意操作。</p><p>防御XSS的核心原则是：<strong>永远不要信任用户的任何输入，并对所有输出到前端页面的数据进行适当的转义或过滤。</strong></p><p>具体的防御手段主要有以下几种：</p><ol><li><strong>输入过滤：</strong> 在数据存入数据库之前，对用户的输入进行校验，过滤掉潜在的恶意代码。但这通常不被视为主要防御手段，因为可能会误伤正常输入，且难以覆盖所有攻击模式。</li><li><strong>输出转义（最核心的防御手段）：</strong> 当服务器端将数据显示到HTML页面上时，对所有特殊字符进行HTML实体转义。比如，将&lt;转义为&lt;，&gt;转义为&gt;。这样一来，即使用户输入了<script>标签，它在浏览器中也只会被当作普通文本显示出来，而不会被当作代码执行。现代的模板引擎（如Vue, React）默认都会进行这种输出转义。</li><li><strong>设置HttpOnly Cookie：</strong> 如我们之前所学，这是防止XSS攻击者窃取会话Cookie的釜底抽薪之计。即使脚本被执行，它也无法通过document.cookie读到关键的会话信息。</li><li><strong>内容安全策略（CSP - Content Security Policy）：</strong> 这是更高级的纵深防御手段。通过在HTTP响应头中设置Content-Security-Policy，我们可以精确地告诉浏览器，该页面只允许加载和执行来自特定来源的脚本。这样即使攻击者成功注入了脚本，只要其来源不被信任，浏览器就会拒绝执行它。</li></ol><h3 id="跨站请求伪造攻击-CSRF"><a href="#跨站请求伪造攻击-CSRF" class="headerlink" title="跨站请求伪造攻击(CSRF)"></a>跨站请求伪造攻击(CSRF)</h3><p><strong>核心思想：</strong> CSRF的本质是<strong>利用了浏览器在跨域请求时会自动携带目标站点Cookie的特性</strong>，来冒用用户的身份，在用户不知情的情况下，执行非用户本意的操作。</p><p><strong>攻击对象：</strong> CSRF攻击的目标是<strong>服务器</strong>，它利用的是服务器对用户的<strong>信任</strong>（通过Cookie来认证）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant User as 已登录银行网站的用户</span><br><span class="line">    participant Bank as 银行网站 (bank.com)</span><br><span class="line">    participant Attacker as 恶意网站 (hacker.com)</span><br><span class="line"></span><br><span class="line">    User-&gt;&gt;Bank: 1. 正常登录, 浏览器保存了bank.com的Cookie</span><br><span class="line">    </span><br><span class="line">    Note over User, Attacker: 用户被诱导访问恶意网站</span><br><span class="line">    User-&gt;&gt;Attacker: 2. GET /index.html</span><br><span class="line">    Attacker--&gt;&gt;User: 3. 返回页面,其中包含&lt;img src=&quot;https://bank.com/transfer?to=hacker&amp;amount=10000&quot;&gt;</span><br><span class="line"></span><br><span class="line">    Note over User, Bank: 浏览器自动加载图片, 向银行发起请求</span><br><span class="line">    User-&gt;&gt;Bank: 4. GET /transfer?to=hacker...&lt;br&gt;&lt;b&gt;自动携带了bank.com的Cookie!&lt;/b&gt;</span><br><span class="line">    </span><br><span class="line">    Note over Bank: 服务器验证Cookie, 认为是合法用户的操作</span><br><span class="line">    Bank-&gt;&gt;Bank: 5. &lt;b&gt;执行转账操作!&lt;/b&gt;</span><br></pre></td></tr></table></figure><h4 id="生活案例-15"><a href="#生活案例-15" class="headerlink" title="生活案例"></a>生活案例</h4><p>CSRF攻击就像是，你（<strong>用户</strong>）已经跟银行（<strong>服务器</strong>）出示过身份证（<strong>登录并获得Cookie</strong>），银行认识你了。这时，一个骗子（<strong>攻击者</strong>）递给你一张看起来无害的<strong>传单</strong>（恶意网站），传单背面用极小的字写着一张“授权转账1万元给我”的<strong>委托书</strong>，并伪造了你的签名。你没注意，接过了传单。银行的摄像头（<strong>浏览器</strong>）看到了这张委托书，并且因为认识你（<strong>自动携带了Cookie</strong>），就误以为这是你的真实意愿，于是把钱转走了。</p><h4 id="经典问题-16"><a href="#经典问题-16" class="headerlink" title="经典问题"></a>经典问题</h4><blockquote><p>什么是CSRF攻击？它的攻击原理是什么？有哪些防御方法？</p></blockquote><p>CSRF，即跨站请求伪造，是一种利用用户已登录的身份，在用户不知情的情况下，构造请求来执行非本意操作的攻击。</p><p><strong>攻击原理：</strong> CSRF的核心是利用了浏览器的身份验证机制，特别是Cookie的自动发送机制。攻击流程通常是：</p><ol><li>用户登录了受信任的网站A，浏览器保存了A网站的Cookie。</li><li>用户在没有退出A网站的情况下，被诱导访问了恶意的网站B。</li><li>网站B向网站A发起一个请求（比如通过一个隐藏的<img>标签或表单）。</li><li>浏览器在发送这个请求时，会自动带上网站A的Cookie。</li><li>网站A的服务器收到请求后，验证Cookie是合法的，误以为是用户本人的操作，于是执行了该请求（比如转账、修改密码等）。</li></ol><p><strong>防御方法：</strong> 防御CSRF的关键在于，如何验证一个请求确实是用户本人在网站内部主动发起的，而不是来自第三方网站的“伪造”。主要方法有：</p><ol><li><strong>验证Referer头部：</strong> 检查HTTP请求的Referer头部，确保请求来自合法的源域名。这是一种简单的方法，但Referer可以被客户端伪造，所以并非完全可靠。</li><li><strong>使用Anti-CSRF Token：</strong> 这是最常用和最可靠的方法。服务器在渲染表单时，生成一个随机的、不可预测的Token，并将其同时放在用户的Session和表单的一个隐藏字段中。当用户提交表单时，服务器会验证Session中的Token和表单提交的Token是否一致。由于攻击者无法获取到这个随机Token，因此无法成功伪造请求。</li><li><strong>使用SameSite Cookie属性：</strong> 这是从协议层面提供的更现代、更根本的防御手段。通过将关键Cookie设置为SameSite=Strict或SameSite=Lax，可以指示浏览器在跨站请求中不发送该Cookie，从而直接切断CSRF的攻击链。这是目前推荐的最佳实践。</li></ol>]]></content>
    
    
    <summary type="html">一份人人都能看懂的HTTP学习笔记,从基础概念到实际应用,通俗易懂,适合初学者和有经验的开发者。包含HTTP请求响应流程、无状态协议、Cookie等核心知识点,帮助你快速掌握HTTP的精髓。</summary>
    
    
    
    <category term="网站" scheme="https://www.wangwangit.com/categories/%E7%BD%91%E7%AB%99/"/>
    
    
    <category term="PDF" scheme="https://www.wangwangit.com/tags/PDF/"/>
    
  </entry>
  
  <entry>
    <title>电脑重装新姿势: 一键切换</title>
    <link href="https://www.wangwangit.com/%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85%E6%96%B0%E5%A7%BF%E5%8A%BF%E4%B9%8B%E4%B8%80%E9%94%AE%E5%88%87%E6%8D%A2%E7%B3%BB%E7%BB%9F/"/>
    <id>https://www.wangwangit.com/%E7%94%B5%E8%84%91%E9%87%8D%E8%A3%85%E6%96%B0%E5%A7%BF%E5%8A%BF%E4%B9%8B%E4%B8%80%E9%94%AE%E5%88%87%E6%8D%A2%E7%B3%BB%E7%BB%9F/</id>
    <published>2025-07-23T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.948Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.996007.icu/file/1753182969778_20250722191601890.png" alt="1753182947573"></p><p>最近搞了台“云电脑”玩，就是那种按月付费的远程Windows桌面。本来想着挺好，但到手就傻眼了，预装的系统带了一堆用不上的软件，控制面板里想换个纯净版的系统？没门。</p><p>这种感觉特难受，就像买了个手机却不能自己选装App。我寻思着，既然我能远程登录，理论上就有办法把这系统给整个换掉。</p><p>在GitHub上瞎逛的时候，翻到了一个叫 <code>bin456789/reinstall</code> 的项目，扫了一眼介绍，感觉这东西就是为我这种情况量身定做的。它号称能把Linux刷成Windows，Windows刷成Linux，而且全过程只需要一条命令。</p><blockquote><p>地址: <a href="https://img.996007.icu/file/1753181602891_20250722185312203.png">https://img.996007.icu/file/1753181602891_20250722185312203.png</a></p></blockquote><p><img src="https://img.996007.icu/file/1753183180001_20250722191932871.png" alt="image-20250722185305038"></p><p>看着几千个星标，心想应该挺靠谱，就决定拿我的云电脑试试水。</p><h2 id="这脚本牛在哪？"><a href="#这脚本牛在哪？" class="headerlink" title="这脚本牛在哪？"></a>这脚本牛在哪？</h2><p>简单说几个让我眼前一亮的地方：</p><ol><li><strong>跨平台硬核重装</strong>：最强的就是能 <code>Linux -&gt; Windows</code> 和 <code>Windows -&gt; Linux</code> 互换。大部分服务商的后台可没这功能。</li><li><strong>网络配置全自动</strong>：远程重装最怕的就是配错IP、网关，导致机器直接“失联”。这脚本能自动识别网络环境，省去了手动配置的风险。</li><li><strong>系统来源干净</strong>：它不是用那种来路不明的“一键包”，而是从官方源拉取系统镜像，心理上感觉踏实很多。</li></ol><h2 id="操作系统安装方法综合比较"><a href="#操作系统安装方法综合比较" class="headerlink" title="操作系统安装方法综合比较"></a>操作系统安装方法综合比较</h2><p>有任何一种工具是万能的。选择哪种方法取决于您的具体场景、技术水平、可用资源和核心目标。下表对多种方法进行了综合比较，帮助您做出明智的决策。</p><table><thead><tr><th>方法</th><th>易用性</th><th>前提条件</th><th>典型用例</th><th>核心优势</th><th>核心局限性</th></tr></thead><tbody><tr><td><strong><code>reinstall</code> 脚本</strong></td><td>非常高</td><td>现有系统可启动，有 SSH&#x2F;CMD 访问权限</td><td>远程 VPS&#x2F;服务器更换或重装系统</td><td>极简操作，跨平台，无需物理接触，自动化程度高</td><td>无法在系统完全崩溃时使用</td></tr><tr><td><strong>云平台工具</strong></td><td>高</td><td>拥有云平台（如天翼云）账户和管理权限</td><td>在 DaaS&#x2F;IaaS 平台上标准化和批量部署桌面&#x2F;服务器</td><td>官方支持，稳定可靠，与平台生态集成度高</td><td>灵活性受限，通常无法安装平台不支持的系统</td></tr><tr><td><strong>系统恢复分区</strong></td><td>中等</td><td>系统可引导至恢复菜单（如 WinRE, GRUB）</td><td>修复损坏的引导加载程序、系统文件或配置</td><td>速度快，不需外部介质，可保留用户数据</td><td>功能有限，无法解决严重的系统损坏或硬盘故障</td></tr><tr><td><strong>U 盘安装</strong></td><td>中等</td><td>物理接触或远程操作权限，U 盘</td><td>本地电脑或数据中心服务器的全新安装&#x2F;修复</td><td>最可靠、最通用的方法，不受现有系统状态影响</td><td>需要物理访问，操作步骤相对繁琐</td></tr><tr><td><strong>PXE 网络引导</strong></td><td>低</td><td>专门的 DHCP&#x2F;TFTP&#x2F;文件服务器基础设施</td><td>企业数据中心大规模、自动化服务器部署</td><td>极致的自动化和扩展性，可实现零接触部署</td><td>设置和维护复杂，需要专业知识和基础设施投资</td></tr></tbody></table><h2 id="实战：在云电脑上操作的“求生指南”"><a href="#实战：在云电脑上操作的“求生指南”" class="headerlink" title="实战：在云电脑上操作的“求生指南”"></a>实战：在云电脑上操作的“求生指南”</h2><p>普通的VPS服务器，用这个脚本很简单。但在“天翼云电脑”或“移动云电脑”这种高度托管的环境里，事情就没那么简单了。<strong>教程同样适用于自己的电脑或者服务器!操作方式类似!只是不需要frp穿透!</strong></p><p><strong>开工前最重要的事，没有之一：</strong></p><p>在你敲下任何代码之前，<strong>先去云电脑服务商的管理后台，找到那个“重置系统”、“恢复出厂设置”或者类似功能的按钮</strong>。点一点，看一看，确保你知道怎么用它。</p><p>因为我们接下来的操作属于“非官方玩法”，一旦玩脱了，比如脚本执行失败、网络中断，你的云电脑很可能就变成一块无法连接的“砖头”。这时候，官方的重置功能，是你唯一的救命稻草。如果找不到这个功能，或者不确定怎么用，我劝你到此为止，别往下看了。</p><p><strong>第二个挑战：网络</strong></p><p>云电脑的网络通常藏在一个大内网里，防火墙策略非常严格。脚本在重装过程中，会开一个临时的SSH或者Web端口让你监控进度，但这个端口从公网是绝对访问不到的。</p><p>怎么办？用 <code>frp</code> 搭个桥。</p><p><code>frp</code> 是一个内网穿透工具。简单说，就是找一台有公网IP的服务器（比如你自己的另一台VPS）当跳板，把云电脑的内部端口“映射”到这台公网服务器上。</p><blockquote><p>frp官方教程: <a href="https://gofrp.org/zh-cn/docs/setup/">https://gofrp.org/zh-cn/docs/setup/</a></p></blockquote><p><strong>实战开始：<code>frp</code> 配合 <code>reinstall</code> 重装云电脑</strong></p><p>假设我的云电脑是Windows，我想把它换成一个干净的Windows 11。我还需要一台有公网IP的Linux VPS。<strong>关于frp的详细介绍请查看官方文档!</strong></p><p><strong>1. 在你的公网VPS上（服务端 frps）</strong></p><ul><li>下载 <code>frp</code>，解压。</li><li>编辑 <code>frps.ini</code> 文件，内容很简单，只需要一行：<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span> </span><br></pre></td></tr></table></figure></li><li>启动服务端：<code>./frps -c ./frps.toml</code></li></ul><p><strong>2. 在你的云电脑上（客户端 frpc）</strong></p><ul><li><p>同样下载 <code>frp</code>，解压。</p></li><li><p>编辑 <code>frpc.toml</code> 文件。这是关键，我们要把重装脚本将要用到的临时端口都转发出去。windows的远程桌面端口默认是3389!</p><p><img src="https://img.996007.icu/file/1753182370291_20250722190558936.png" alt="image-20250722190558885"></p></li></ul><p><strong>3. 在云电脑上执行重装</strong></p><ul><li><p>打开一个新的CMD窗口（必须是管理员权限）。</p></li><li><p>下载 <code>reinstall.bat</code> 脚本。(请先关闭 <code>Windows Defender</code> 的 <code>实时保护</code> 功能。该功能会阻止 <code>certutil</code> 下载任何文件 )</p><blockquote><p>certutil -urlcache -f -split <a href="https://cnb.cool/bin456789/reinstall/-/git/raw/main/reinstall.bat">https://cnb.cool/bin456789/reinstall/-/git/raw/main/reinstall.bat</a></p></blockquote></li><li><p>执行命令。<strong>注意:最后的指定了frp文件的路径</strong>,请自行修改对应的镜像,以及frp文件路径!</p><figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">reinstall.bat windows --image-name &quot;Windows <span class="number">11</span> Pro&quot;  --iso &quot;https://software.download.prss.microsoft.com/dbazure/Win11_24H2_Chinese_Simplified_x64.iso?t=ad063ddd-<span class="number">24</span>ff-<span class="number">4930</span>-<span class="number">8</span>fde-b6852e621338&amp;P1=<span class="number">1748655755</span>&amp;P2=<span class="number">601</span>&amp;P3=<span class="number">2</span>&amp;P4=m9mV9P1Uq8J65OYq3pKi4IpYEZJXiZ6<span class="variable">%2fhlxowSrz5mpYsgefGFxy%</span><span class="number">2</span>fRn0hGSdWT9H75WBcBUviFgoohH9RkjQ<span class="variable">%2fWduMguJNSm9AyWFQ1V%</span><span class="number">2</span>bjZ30ugPxFVm2cxm6OyvM3h1Oqr9QtyxI7<span class="variable">%2bMtFWfwkcbhnFSn7uxIr%</span><span class="number">2</span>fnvui2BJjYNATu3iHn5QuecU16fWkqdQKPeRYH61P3FppHer6RhECDAHcz<span class="variable">%2fQTfNe8tfyx6o5UpASJdpYMDADOb%</span><span class="number">2</span>bSv<span class="variable">%2bR9Ds8JcLIvjlx%</span><span class="number">2</span>bthWffrB6dhIcUgMDIOGwIs9S2mQDKJsjbESpqVG8qIFzyUpiWYZKuXALIVO6bIeZ1krjbH6<span class="variable">%2bQXn%</span><span class="number">2</span>fYc4OA<span class="variable">%3d%</span><span class="number">3</span>d&quot; --frpc-toml D://frpc.toml</span><br></pre></td></tr></table></figure></li></ul><p>脚本跑起来后，你云电脑的远程桌面会断开，这是正常的。</p><p><img src="https://img.996007.icu/file/1753183129500_20250722191838792.png" alt="image-20250722191838716"></p><p><strong>3. 监控进度</strong></p><p>整个过程大概需要20-40分钟，取决于网络和机器性能。完成后，你就可以用新的密码，通过电脑自带的远程桌面即可连接!</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>总的来说，<code>reinstall</code> 脚本就像一把瑞士军刀，功能强大，能解决很多棘手问题。但它不是万能的，尤其是在云电脑这种受限环境下，更像是一项“黑魔法”，使用前必须想清楚后果!</p><p>对于大多数只想安稳使用云电脑的朋友，我还是建议优先使用官方工具。但如果你和我一样，就是喜欢那种突破限制、把机器完全掌控在自己手里的感觉，那这个脚本绝对值得一试。</p>]]></content>
    
    
    <summary type="html">在GitHub上瞎逛的时候，翻到了一个叫 `bin456789/reinstall` 的项目，扫了一眼介绍，感觉这东西就是为我这种情况量身定做的。它号称能把Linux刷成Windows，Windows刷成Linux，而且全过程只需要一条命令。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="系统" scheme="https://www.wangwangit.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>关于个人微信机器人，我把我知道的都写在了这里</title>
    <link href="https://www.wangwangit.com/%E5%85%B3%E4%BA%8E%E4%B8%AA%E4%BA%BA%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%8C%E6%88%91%E6%8A%8A%E6%88%91%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%86%99%E5%9C%A8%E4%BA%86%E8%BF%99%E9%87%8C/"/>
    <id>https://www.wangwangit.com/%E5%85%B3%E4%BA%8E%E4%B8%AA%E4%BA%BA%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%8C%E6%88%91%E6%8A%8A%E6%88%91%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%86%99%E5%9C%A8%E4%BA%86%E8%BF%99%E9%87%8C/</id>
    <published>2025-07-20T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.946Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.996007.icu/file/1752494828621_20250714200701238.png" alt="ChatGPT Image 2025年7月14日 20_06_53"></p><p>前几天，我分享了一篇关于实现企业微信机器人的文章，反响很不错。同时我也注意到，在评论和私信中，大家的需求非常明确：相比于企业场景，更多人渴望能直接在个人微信号上实现自动化，打造一个真正属于自己的智能助理。</p><p>理解这份期待，所以今天，我将全面地介绍当前实现<strong>微信个人号机器人</strong>的各类技术方案。</p><p>在开始之前，我要说一个注意事项：与企业微信不同，腾讯官方从未为个人微信号提供过任何公开的API。这意味着，我们接下来要探讨的所有非官方技术路径，都或多或少地游走在平台规则的边缘，并伴随着从功能限制到账号封禁不等的风险。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>先给大家分享一下我正在用方案吧!我目前主要用的是windows hook的方案!<strong>安全问题请自己斟酌,请用小号测试!</strong></p><blockquote><p>文件地址: <a href="https://ali.wangwangit.com/%F0%9F%91%80%E5%88%86%E4%BA%AB%E4%B8%93%E7%94%A8/wx.7z">https://ali.wangwangit.com/%F0%9F%91%80%E5%88%86%E4%BA%AB%E4%B8%93%E7%94%A8/wx.7z</a></p></blockquote><p>1.安装文件中对应版本的微信,并且打开,如下图页面.</p><p>2.在文件目录打开cmd窗口,执行对应的命令,返回Successfully,表明成功</p><p>3.下面地址可查看对应的API,不过我测试有一些API无法使用! 接收消息需要调用接口设置hook地址!</p><blockquote><p><a href="https://github.com/ttttupup/wxhelper/blob/main/doc/3.9.5.81.md">https://github.com/ttttupup/wxhelper/blob/main/doc/3.9.5.81.md</a></p></blockquote><p><img src="https://img.996007.icu/file/1752492431210_20250714192702116.png" alt="image-20250714192702013"></p><p><img src="https://img.996007.icu/file/1752493037448_20250714193704889.png" alt="image-20250714193704797"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="1-官方路径：企业微信机器人"><a href="#1-官方路径：企业微信机器人" class="headerlink" title="1. 官方路径：企业微信机器人"></a>1. 官方路径：企业微信机器人</h3><p>尽管我们的焦点是个人号，但任何全面的讨论都绕不开官方提供的唯一合规方案——企业微信机器人。了解它的能力边界，有助于我们理解为什么开发者们会去探索非官方路径。</p><blockquote><p>教程地址: <a href="https://developer.work.weixin.qq.com/document/path/91770">https://developer.work.weixin.qq.com/document/path/91770</a></p></blockquote><ul><li><p><strong>实现原理：</strong> 基于Webhook机制。管理员在企业微信群内创建机器人后，会得到一个专属的Webhook URL。任何应用只需向此URL发送一个符合规范的HTTP POST请求，就能将消息推送到群里。其实现过程简单直接，你可以在此查阅完整的进行实践。</p></li><li><p><strong>核心限制：</strong> 企业微信机器人的本质是一个<strong>单向的通知工具</strong>。它无法读取群内消息，不能主动私聊或添加好友，其所有行为都局限在指定群聊内，被动地等待指令。</p></li></ul><p><img src="https://img.996007.icu/file/1752491776813_20250714191606758.png" alt="image-20250714191559616"></p><p>在手机企业微信群聊中,添加机器人,即可获得Webhook地址!后续就可以在微信群接收到群消息了!</p><p><img src="https://img.996007.icu/file/1752491863785_20250714191730936.png" alt="image-20250714191730707"></p><p><img src="https://img.996007.icu/file/1752491940961_20250714191855180.png" alt="image-20250714191855123"></p><p><strong>结论：</strong> 如果你的需求是系统告警、应用通知等面向内部的、无交互的场景，企业微信是零风险且功能强大的不二之选。但若想实现更动态、更具交互性的个人助理，我们就必须转向非官方的解决方案。</p><h3 id="2-非官方技术方案：四条不同的探索路径"><a href="#2-非官方技术方案：四条不同的探索路径" class="headerlink" title="2. 非官方技术方案：四条不同的探索路径"></a>2. 非官方技术方案：四条不同的探索路径</h3><p>以下是社区经过多年探索后，沉淀下来的四种主流非官方技术方案。</p><h4 id="2-1-网页版API-Web-API-已失效的历史方案"><a href="#2-1-网页版API-Web-API-已失效的历史方案" class="headerlink" title="2.1 网页版API (Web API) - 已失效的历史方案"></a>2.1 网页版API (Web API) - 已失效的历史方案</h4><p>这是最早、也曾是最流行的实现方式，许多经典项目（如Python的<code>ItChat</code>、<code>wxpy</code>）都基于此构建。</p><blockquote><p>github地址: <a href="https://github.com/littlecodersh/ItChat">https://github.com/littlecodersh/ItChat</a></p></blockquote><ul><li><strong>工作机制：</strong> 通过程序模拟浏览器登录网页版微信（web.wechat.com），然后调用其基于HTTP的API来收发消息和管理联系人。</li><li><strong>当前状态：</strong> <strong>基本失效</strong>。自2017年起，微信官方已不再为新注册的账号提供网页版登录入口。绝大多数存量账号也已无法登录。因此，该方案已不具备可行性，仅作为技术发展的历史背景供了解。任何新项目都不应再考虑此路径。</li></ul><h4 id="2-2-协议模拟-Protocol-Simulation"><a href="#2-2-协议模拟-Protocol-Simulation" class="headerlink" title="2.2 协议模拟 (Protocol Simulation)"></a>2.2 协议模拟 (Protocol Simulation)</h4><p>随着网页版API的落幕，此方案成为当前功能最强大的主流选择。</p><ul><li><strong>工作机制：</strong> 通过逆向工程破解微信某个原生客户端（主要是iPad或PC版）与服务器之间的私有通信协议。程序通过模拟一个合法的客户端，直接与微信服务器进行数据交互。</li><li><strong>优点：</strong> 功能完备，可实现几乎所有原生功能；可后台静默运行；不强依赖于特定客户端版本。</li><li><strong>缺点与风险：</strong> 技术壁垒极高，个人开发者难以维护；稳定服务通常需要付费购买<code>Token</code>；存在中等程度的封号风险，异常行为可能被平台风控系统捕获。</li></ul><h4 id="2-3-客户端Hook-Client-Hooking"><a href="#2-3-客户端Hook-Client-Hooking" class="headerlink" title="2.3 客户端Hook (Client Hooking)"></a>2.3 客户端Hook (Client Hooking)</h4><p>这是一种更为激进的、直接作用于微信客户端的方案。</p><ul><li><strong>工作机制：</strong> 在PC端，通过DLL注入等技术侵入正在运行的微信进程，直接调用其内存中的内部函数来实现消息收发等控制。</li><li><strong>优点：</strong> 功能同样强大，甚至能实现防撤回、多开等突破客户端限制的功能。</li><li><strong>缺点与风险：</strong> <strong>稳定性极差</strong>，强依赖于特定的微信客户端版本，一旦微信更新，立即失效；<strong>封号风险最高</strong>，修改客户端运行时行为是平台严厉打击的对象；存在未知的安全隐患。</li></ul><h4 id="2-4-UI自动化-UI-Automation"><a href="#2-4-UI自动化-UI-Automation" class="headerlink" title="2.4 UI自动化 (UI Automation)"></a>2.4 UI自动化 (UI Automation)</h4><p>这是一种“曲线救国”的方案，它不触及微信的任何代码或协议。</p><ul><li><strong>工作机制：</strong> 利用操作系统层面的辅助功能（如Android的无障碍服务），编写脚本来模拟人的手指在屏幕上进行点击、输入和滑动等操作。</li><li><strong>优点：</strong> <strong>封号风险最低</strong>，因为其行为模式与真人操作无异；对微信版本更新不敏感。</li><li><strong>缺点：</strong> 效率和可靠性较低；必须保持微信在前台运行；功能受限于屏幕上可见的UI元素。</li></ul><h3 id="3-技术方案全景对比"><a href="#3-技术方案全景对比" class="headerlink" title="3. 技术方案全景对比"></a>3. 技术方案全景对比</h3><p>为了帮你更直观地做出判断，我将所有方案的核心特性总结在下表中：</p><table><thead><tr><th align="left">实现方案</th><th align="left">实现原理</th><th align="left">功能完备性</th><th align="left">稳定性&#x2F;维护成本</th><th align="left">风险等级</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong>企业微信</strong></td><td align="left">官方Webhook API</td><td align="left">有限（仅通知）</td><td align="left">极高 &#x2F; 官方维护</td><td align="left"><strong>无</strong></td><td align="left">企业内部通知、系统集成</td></tr><tr><td align="left"><strong>协议模拟</strong></td><td align="left">逆向私有网络协议</td><td align="left">高</td><td align="left">较高 &#x2F; 依赖服务商</td><td align="left"><strong>中</strong></td><td align="left">需要完整功能、可后台运行的机器人</td></tr><tr><td align="left"><strong>客户端Hook</strong></td><td align="left">注入DLL，修改进程内存</td><td align="left">极高</td><td align="left">极低 &#x2F; 强依赖版本</td><td align="left"><strong>高</strong></td><td align="left">短期技术验证、高风险功能实验</td></tr><tr><td align="left"><strong>UI自动化</strong></td><td align="left">模拟屏幕点击与输入</td><td align="left">中等</td><td align="left">中等 &#x2F; 依赖UI布局</td><td align="left"><strong>低</strong></td><td align="left">简单的自动回复、轻量级自动化任务</td></tr><tr><td align="left"><strong>网页版API</strong></td><td align="left">模拟浏览器HTTP API</td><td align="left">有限</td><td align="left"><strong>已失效</strong></td><td align="left"><strong>N&#x2F;A</strong></td><td align="left">历史项目研究</td></tr></tbody></table><h3 id="4-开源社区的框架与工具"><a href="#4-开源社区的框架与工具" class="headerlink" title="4. 开源社区的框架与工具"></a>4. 开源社区的框架与工具</h3><ul><li><strong>Wechaty:</strong> 当前最成熟的机器人框架。其核心的<strong>Puppet（傀儡）架构</strong>是应对微信多变环境的绝佳设计。开发者可以编写一套业务逻辑，通过切换不同的Puppet插件来适配不同的底层实现（无论是付费的协议模拟，还是免费但高风险的Hook方案），极大地提升了项目的适应性和生命周期。</li><li><strong>chatgpt-on-wechat:</strong> 一个现象级的应用项目，它将大型语言模型与微信打通，并灵活支持多种后端渠道，是快速体验AI聊天机器人的优秀选择。</li><li><strong>其他项目:</strong> 社区中还有许多基于特定方案的开源项目（如基于Hook的<code>ComWeChatRobot</code>），它们通常开箱即用，但使用者必须清醒地认识到其背后方案所固有的风险和不稳定性。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在个人微信机器人这个领域，不存在完美的“银弹”，所有的选择都是在功能、成本、稳定性与风险之间的权衡。</p><ul><li><strong>追求安全合规：</strong> <strong>企业微信</strong>是唯一选择。</li><li><strong>追求强大功能与相对稳定：</strong> <strong>协议模拟</strong>是当前最现实的路径。建议使用 <code>Wechaty</code> 框架，并准备为稳定的协议服务支付费用。使用小号进行充分测试是必不可少的步骤。</li><li><strong>追求低风险的简单自动化：</strong> <strong>UI自动化</strong>方案值得尝试，尤其适合个人娱乐或轻量级任务。</li><li><strong>仅为技术探索：</strong> <strong>客户端Hook</strong>方案可用于短期实验，但绝不应投入到任何有价值的账号或严肃应用中。</li></ul>]]></content>
    
    
    <summary type="html">前几天，我分享了一篇关于实现企业微信机器人的文章，反响很不错。同时我也注意到，在评论和私信中，大家的需求非常明确：相比于企业场景，更多人渴望能直接在个人微信号上实现自动化，打造一个真正属于自己的智能助理。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="工具" scheme="https://www.wangwangit.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="导航站" scheme="https://www.wangwangit.com/tags/%E5%AF%BC%E8%88%AA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>为什么你的同事从不迟到？一文看懂虚拟定位的&quot;黑科技&quot;</title>
    <link href="https://www.wangwangit.com/%E8%99%9A%E6%8B%9F%E5%AE%9A%E4%BD%8D%E5%A4%A7%E6%8F%AD%E7%A7%98%EF%BC%9A%E9%82%A3%E4%BA%9B%E7%8E%AF%E7%90%83%E6%97%85%E8%A1%8C%E5%AE%B6%EF%BC%8C%E5%85%B6%E5%AE%9E%E4%B8%80%E6%AD%A5%E9%83%BD%E6%B2%A1%E5%87%BA%E9%97%A8/"/>
    <id>https://www.wangwangit.com/%E8%99%9A%E6%8B%9F%E5%AE%9A%E4%BD%8D%E5%A4%A7%E6%8F%AD%E7%A7%98%EF%BC%9A%E9%82%A3%E4%BA%9B%E7%8E%AF%E7%90%83%E6%97%85%E8%A1%8C%E5%AE%B6%EF%BC%8C%E5%85%B6%E5%AE%9E%E4%B8%80%E6%AD%A5%E9%83%BD%E6%B2%A1%E5%87%BA%E9%97%A8/</id>
    <published>2025-07-20T22:25:00.000Z</published>
    <updated>2025-11-12T02:28:07.949Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.996007.icu/file/1753095125559_20250721185153546.png" alt="ip"></p><p>前几天刷短视频，看到一个很有意思的现象：</p><p>一个博主上午还在冰岛拍极光，下午就”飞”到了非洲看大象，晚上又出现在日本泡温泉。而且都标着”刚刚发布”，时间差不超过10分钟。</p><p>我寻思，这人是开了私人飞机，还是练成了瞬移神功？</p><p>或者你身边是不是也有这样的同事：天天神龙见首不见尾，但考勤打卡从来没迟到过，定位总是准确无误地显示在办公室。</p><p>别纳闷了，他们可能只是掌握了一门”黑科技”——<strong>虚拟定位</strong>。</p><h2 id="虚拟定位到底是啥？"><a href="#虚拟定位到底是啥？" class="headerlink" title="虚拟定位到底是啥？"></a>虚拟定位到底是啥？</h2><p>说白了，就是教你的手机”说谎”。</p><p>你人在家里葛优瘫，但手机却能装作你在巴黎埃菲尔铁塔下发朋友圈。这就像给手机化了个妆，让各种App都认不出你的真实位置。</p><p>要搞明白虚拟定位的原理，得先了解手机平时是怎么知道自己在哪的。</p><p><strong>先打个预防针：</strong></p><p>我分享这个技术，纯粹是为了满足大家的好奇心。但作为一个有良心的科普博主，必须先说清楚：</p><p><strong>千万别拿这玩意儿干违法乱纪的事</strong>，真的得不偿失：</p><ul><li><strong>工作上：</strong> 现在的考勤系统都是老狐狸，为了省几分钟通勤时间丢了饭碗，太不值</li><li><strong>娱乐上：</strong> 游戏公司对作弊零容忍，封号不留情，辛苦练的角色说没就没</li><li><strong>法律上：</strong> 要是用来搞诈骗什么的，那就不是开玩笑了，是要蹲号子的</li></ul><p>咱们就当个科普知识学学，图个乐呵就行。</p><h2 id="虚拟定位的几种”套路”"><a href="#虚拟定位的几种”套路”" class="headerlink" title="虚拟定位的几种”套路”"></a>虚拟定位的几种”套路”</h2><p>想让手机撒谎，得先摸清它平时是怎么说实话的。</p><table><thead><tr><th>定位方式</th><th>工作原理</th><th>准确度</th><th>如何”伪装”</th><th>主要应用场景</th></tr></thead><tbody><tr><td><strong>GPS定位</strong></td><td>接收卫星信号计算位置</td><td>很准（5-10米）</td><td>发射假GPS信号</td><td>导航、运动软件、位置游戏</td></tr><tr><td><strong>IP定位</strong></td><td>根据网络IP判断大概位置</td><td>不太准（城市级）</td><td>用代理</td><td>视频网站、广告推送</td></tr><tr><td><strong>WiFi&#x2F;基站定位</strong></td><td>根据附近WiFi和手机塔定位</td><td>一般准（几十到几百米）</td><td>配合GPS欺骗</td><td>室内导航、辅助定位</td></tr></tbody></table><p>搞清楚了定位原理，”骗术”也就呼之欲出了：</p><p><strong>第一招：GPS信号欺骗</strong><br>这招叫”声东击西”。卫星信号从太空传到地面，到你手机这里已经很微弱了。虚拟定位设备就在你手机旁边发射更强的假GPS信号。你的手机秉承”谁声音大听谁的”原则，自然就被骗了。</p><p><strong>第二招：网络地址伪装</strong><br>这招叫”狸猫换太子”。你连上代理后，所有网络请求都先绕到别的国家的服务器，再转发出去。网站看到的只是那台服务器的地址，自然以为你在那个国家。比如抖音上的IP,就是基于这种方式修改的!</p><p><img src="https://img.996007.icu/file/1753094909013_20250721184816319.png" alt="image-20250721184816230"></p><h2 id="安卓手机的玩法"><a href="#安卓手机的玩法" class="headerlink" title="安卓手机的玩法"></a>安卓手机的玩法</h2><p>安卓系统比较开放，从新手到高手都有对应的方法。</p><h3 id="1-系统自带的模拟定位"><a href="#1-系统自带的模拟定位" class="headerlink" title="1. 系统自带的模拟定位"></a>1. 系统自带的模拟定位</h3><p><strong>操作很简单：</strong></p><ul><li>狂点”版本号”7下，开启开发者模式（感觉像在输入秘籍）</li><li>在开发者选项里找”模拟位置应用”</li><li>选一个虚拟定位App就行</li></ul><p><img src="https://img.996007.icu/file/1753094543850_20250721184218939.png" alt="image-20250721184218871"></p><p><img src="https://img.996007.icu/file/1753094555684_20250721184231591.png" alt="image-20250721184231495"></p><p><strong>好用的工具：</strong></p><ul><li><strong>Fake GPS Location：</strong> 新手友好，地图上想点哪点哪</li><li><strong>GPS JoyStick：</strong> 功能强大，还能设计移动路线</li></ul><p><strong>优点：</strong> 官方认可，操作简单<br><strong>缺点：</strong> 容易被App识破</p><p>我们以<strong>Fake GPS Location</strong>为例来测试一下! 软件请前往下面地址下载</p><blockquote><p>地址: <a href="https://ali.wangwangit.com/%F0%9F%91%80%E5%88%86%E4%BA%AB%E4%B8%93%E7%94%A8/Fake%20GPS.apk">https://ali.wangwangit.com/%F0%9F%91%80%E5%88%86%E4%BA%AB%E4%B8%93%E7%94%A8/Fake%20GPS.apk</a></p></blockquote><p>打开软件,按下图设置Map Type,然后点击<code>Go to</code>设置一个地区的经纬度!或则拖动页面上的箭头也可以!</p><p><img src="https://img.996007.icu/file/1753094356411_20250721183902239.png" alt="image-20250721183855133"></p><p>然后,你打开高德地图,就会发现位置已经跑到别的地方了!</p><p><img src="https://img.996007.icu/file/1753094628124_20250721184335741.png" alt="image-20250721184335489"></p><h3 id="2-虚拟空间大法"><a href="#2-虚拟空间大法" class="headerlink" title="2. 虚拟空间大法"></a>2. 虚拟空间大法</h3><p>简单说就是在手机里再造一个”小手机”，专门用来运行需要虚拟定位的App。就像俄罗斯套娃一样。</p><p><strong>代表工具：</strong> VirtualXposed、Parallel Space、虚拟大师等!</p><p><img src="https://img.996007.icu/file/1753094754410_20250721184550737.png" alt="image-20250721184550678"></p><h3 id="3-Hook技术"><a href="#3-Hook技术" class="headerlink" title="3. Hook技术"></a>3. Hook技术</h3><p>这是最高级的玩法，通过在系统底层”动手脚”，让App压根察觉不到异常。相当于给手机做了个完美整容手术。</p><p><strong>好处：</strong> 几乎检测不出来<br><strong>坏处：</strong> 技术门槛高，一般人玩不转</p><h3 id="4-Root方式"><a href="#4-Root方式" class="headerlink" title="4. Root方式"></a>4. Root方式</h3><p>Root相当于获得了手机的”管理员权限”，理论上可以为所欲为。</p><p><strong>但风险太大了：</strong></p><ul><li>手机安全防护被破坏</li><li>银行App直接罢工不干了</li><li>保修服务说拜拜</li><li>搞砸了手机变砖头</li></ul><p>所以现在基本没人走这条路了。</p><h2 id="iPhone的”曲线救国”"><a href="#iPhone的”曲线救国”" class="headerlink" title="iPhone的”曲线救国”"></a>iPhone的”曲线救国”</h2><p>苹果管得严，iPhone只能借助外力：</p><h3 id="主要方法：电脑软件辅助"><a href="#主要方法：电脑软件辅助" class="headerlink" title="主要方法：电脑软件辅助"></a>主要方法：电脑软件辅助</h3><p>由于iOS把门看得死死的，只能通过数据线连电脑，用专门的软件往iPhone里”灌输”假位置信息。</p><p><strong>常用工具：</strong></p><ul><li>爱思助手</li><li>iTools</li><li>AnyGo</li></ul><p><strong>使用流程：</strong></p><ol><li>电脑装好软件</li><li>数据线连iPhone</li><li>软件里选位置</li><li>同步到手机</li></ol><h3 id="⚠️-风险提醒"><a href="#⚠️-风险提醒" class="headerlink" title="⚠️ 风险提醒"></a>⚠️ 风险提醒</h3><p>用这些第三方工具有安全隐患：</p><ul><li>Apple ID可能被盗</li><li>个人信息泄露</li><li>设备被植入病毒</li></ul><p>所以要三思而后行。</p><h2 id="魔高一尺，道高一丈"><a href="#魔高一尺，道高一丈" class="headerlink" title="魔高一尺，道高一丈"></a>魔高一尺，道高一丈</h2><p>虚拟定位在进步，各大平台的反制技术也没闲着。这就是一场没完没了的”猫鼠游戏”。</p><h3 id="App的检测手段"><a href="#App的检测手段" class="headerlink" title="App的检测手段"></a>App的检测手段</h3><ol><li><strong>直接检查：</strong> 看系统有没有开启模拟位置</li><li><strong>环境检测：</strong> 检查是否启用了开发者模式</li><li><strong>权限分析：</strong> 判断设备是否被破解</li></ol><h3 id="服务器的”火眼金睛”"><a href="#服务器的”火眼金睛”" class="headerlink" title="服务器的”火眼金睛”"></a>服务器的”火眼金睛”</h3><p>现在的检测系统越来越聪明，不光看数据，还要分析行为：</p><ol><li><strong>瞬移识别：</strong> 1分钟从上海到北京？当我是傻子吗？</li><li><strong>数据异常分析：</strong> 真实GPS会有小幅波动，太完美的数据反而可疑</li><li><strong>轨迹合理性：</strong> 你的移动路径和速度符合物理规律吗？</li></ol><p>举个例子，我有个朋友想用虚拟定位”环游世界”，结果被系统识破了。因为他设置的路线是从北京直接”飞”到纽约，中间没有任何过渡，系统一看就知道有问题。</p><h2 id="结语：技术向善，用之有度"><a href="#结语：技术向善，用之有度" class="headerlink" title="结语：技术向善，用之有度"></a>结语：技术向善，用之有度</h2><p>虚拟定位技术本身没有对错，关键在于怎么用。</p><p>了解这些知识，不是为了去钻空子，而是为了在这个数字化时代更好地保护自己，看透那些看似高大上的”数字假象”。</p><p>我始终相信一句话：<strong>技术可以复制，但人生体验无法伪造</strong>。</p><p>与其费尽心思制造虚假的”环球旅行”，不如踏踏实实规划一次真正的说走就走。毕竟，真实体验带来的快乐和成长，是任何技术都无法替代的。</p><p>做个有趣的人，也要做个诚实的人。这样的人生，才真正值得”定位”。</p>]]></content>
    
    
    <summary type="html">或者你身边是不是也有这样的同事：天天神龙见首不见尾，但考勤打卡从来没迟到过，定位总是准确无误地显示在办公室。</summary>
    
    
    
    <category term="教程" scheme="https://www.wangwangit.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="虚拟定位" scheme="https://www.wangwangit.com/tags/%E8%99%9A%E6%8B%9F%E5%AE%9A%E4%BD%8D/"/>
    
  </entry>
  
</feed>
